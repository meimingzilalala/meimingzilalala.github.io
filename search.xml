<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo+github/aliyun搭建静态博客</title>
    <url>/archives/15b1edd7.html</url>
    <content><![CDATA[<p><strong>写在前面：本来是用windows搭建的博客，但奈何Linux太香了，加上之前装过wsl，所以打算用Linux再搭建一下。</strong></p>
<h2 id="下载nodejs和cnpm"><a class="markdownIt-Anchor" href="#下载nodejs和cnpm"></a> 下载nodejs和cnpm</h2>
<p>Windows下：</p>
<p>直接在<a href="https://nodejs.org/zh-cn/">nodejs官网</a>进行下载并安装<br />
<code>node -v</code>命令查看node的版本<br />
<code>npm -v</code>命令查看npm的版本<br />
然后利用npm安装淘宝的cnpm，下载速度快一些<br />
<code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code>命令安装淘宝的cnpm包管理器<br />
<code>cnpm -v</code>命令查看cnpm的版本</p>
<span id="more"></span>
<hr />
<h2 id="下载hexo并创建本地的静态博客"><a class="markdownIt-Anchor" href="#下载hexo并创建本地的静态博客"></a> 下载hexo并创建本地的静态博客</h2>
<p><code>cnpm install -g hexo-cli</code>安装hexo<br />
<code>hexo -v</code>查看hexo版本<br />
然后创建一个你存博客的目录并进入到该目录，你可能会用到<code>mkdir blog</code>,<code>cd blog</code><br />
<code>hexo init</code>在当前目录下生成博客的框架<br />
你可以使用<code>hexo s</code>开启博客，进入<code>http://localhost:4000/</code>查看本地博客内容<br />
<code>hexo n &quot;文章名&quot;</code>创建新的文章<br />
然后找到<code>\source\_post</code>目录下编辑文章即可，使用markdown语法</p>
<hr />
<h2 id="部署到github上"><a class="markdownIt-Anchor" href="#部署到github上"></a> 部署到GitHub上</h2>
<p>首先在你的GitHub上新建一个仓库，命名为<code>YourGithubName.github.io</code><br />
然后<code>cnpm install --save hexo-deployer-git</code>在blog目录下安装git部署插件<br />
下面配置_config.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line"> 		<span class="built_in">type</span>: git</span><br><span class="line">		repo: https://github.com/YourGithubName/YourGithubName.github.io.git</span><br><span class="line"> 		branch: master</span><br></pre></td></tr></table></figure>
<p>最后运行以下三条命令：<br />
<code>hexo clean</code>清理<br />
<code>hexo g</code>生成<br />
<code>hexo d</code>部署<br />
以上三条命令基本是每次修改博客后都要运行的<br />
最后在<code>https://YourGithubName.github.io</code>下就可以查看啦！</p>
<hr />
<h2 id="主题的更换"><a class="markdownIt-Anchor" href="#主题的更换"></a> 主题的更换</h2>
<p>更改主题一般分两步：<br />
1、<code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code>利用git将别人仓库里的主题克隆到自己的blog下的themes文件夹里<br />
2、修改blog目录下的 _config.yml 文件中的  theme改为theme: yilia<br />
<strong>注意：这里的GitHub地址是示例，虽然这个大佬写的也挺好看的；themes下的文件夹名要和theme冒号后面的名称一样</strong><br />
更改完成，运行上面的三条命令就可以看到变化啦（比较慢，多等一会，用本地查看会快一些）</p>
<hr />
<h2 id="一些个性化的定制"><a class="markdownIt-Anchor" href="#一些个性化的定制"></a> 一些个性化的定制</h2>
<h3 id="看板娘的添加"><a class="markdownIt-Anchor" href="#看板娘的添加"></a> 看板娘的添加</h3>
<p>明天再更</p>
<h3 id="网址小图标的添加"><a class="markdownIt-Anchor" href="#网址小图标的添加"></a> 网址小图标的添加</h3>
<p>内容</p>
<h3 id="主题里一些内容的简单定制"><a class="markdownIt-Anchor" href="#主题里一些内容的简单定制"></a> 主题里一些内容的简单定制</h3>
<p>内容</p>
<hr />
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<p>1、<a href="https://www.bilibili.com/video/BV1Yb411a7ty">b站大佬视频讲解</a></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>自学</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl的安装与配置</title>
    <url>/archives/cee22f12.html</url>
    <content><![CDATA[<h1 id="wslwindows-subsystem-for-linux的安装与配置"><a class="markdownIt-Anchor" href="#wslwindows-subsystem-for-linux的安装与配置"></a> wsl（Windows Subsystem for Linux）的安装与配置</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>之前上过一个Linux的选修课，了解了Linux系统的一些知识，越用越觉得一些需要命令行的软件用Linux来简直太方便了，这篇文章就介绍以下如何在windows系统上搭建Linux子系统（也就是wsl），这样就不用使用VMware来装虚拟机了</p>
<span id="more"></span>
<h2 id="windows-10-开启wsl功能"><a class="markdownIt-Anchor" href="#windows-10-开启wsl功能"></a> windows 10 开启wsl功能</h2>
<ol>
<li>按Windows+Q进入搜索功能，也可以右键点击开始，选择里面的搜索功能</li>
<li>在Windows 10的搜索框中输入<code>启用或关闭Windows功能</code></li>
<li>打开后选中<code>适用于Linux的Windows子系统</code><br />
<img src="/images/wsl%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/image-20210503170452634.png" alt="image-20210503170452634" /></li>
</ol>
<h2 id="linux的安装"><a class="markdownIt-Anchor" href="#linux的安装"></a> Linux的安装</h2>
<ol>
<li>打开微软商店（Microsoft Store）</li>
<li>搜索Linux</li>
<li>选择其中的一个发行版本进行安装，本文以debian为例</li>
</ol>
<p><img src="/images/wsl%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/image-20210503171000458.png" alt="image-20210503171000458" /></p>
<p><img src="/images/wsl%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/image-20210503171035452.png" alt="image-20210503171035452" /></p>
<h2 id="linux初始化"><a class="markdownIt-Anchor" href="#linux初始化"></a> Linux初始化</h2>
<ol>
<li>
<p>打开刚下好的Linux，等一小会它的安装</p>
</li>
<li>
<p>输入新创建的用户名</p>
</li>
<li>
<p>输入该用户的密码，输入两次后就进入了Linux系统，新用户也创建完成</p>
</li>
<li>
<p>输入<code>sudo passwd</code>更改root的密码</p>
</li>
<li>
<p>一些知识</p>
<blockquote>
<p>输入<code>su</code>再输入密码进入root模式<br />
输入<code>exit</code>或者按<code>ctrl+d</code>退出root模式<br />
输入<code>sudo 命令</code>可以在普通用户下执行root权限的命令，密码是普通用户的密码</p>
</blockquote>
</li>
</ol>
<h2 id="terminal安装"><a class="markdownIt-Anchor" href="#terminal安装"></a> Terminal安装</h2>
<p>Terminal是一款高颜值的管理命令行软件，如果你习惯于PowerShell或者cmd的话可以跳过此步骤</p>
<ol>
<li>打开微软商店（MicroSoft Store）</li>
<li>搜索Terminal</li>
<li>点击安装</li>
</ol>
<h2 id="terminal配置"><a class="markdownIt-Anchor" href="#terminal配置"></a> Terminal配置</h2>
<p>简单配置一下Terminal，让你用起来更舒服，可跳过</p>
<ol>
<li>打开Terminal</li>
<li>打开设置</li>
</ol>
<p><img src="/images/wsl%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/image-20210503171852186.png" alt="image-20210503171852186" /></p>
<ol start="3">
<li>点击左下角的设置图标，进入Terminal的配置文件，如下，<strong>为了安全起见建议备份一下，不然出问题不好还原</strong></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This file was initially generated by Windows Terminal 1.4.3243.0</span></span><br><span class="line"><span class="comment">// It should still be usable in newer versions, but newer versions might have additional</span></span><br><span class="line"><span class="comment">// settings, help text, or changes that you will not see unless you clear this file</span></span><br><span class="line"><span class="comment">// and let us generate a new one for you.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To view the default settings, hold &quot;alt&quot; while clicking on the &quot;Settings&quot; button.</span></span><br><span class="line"><span class="comment">// For documentation on these settings, see: https://aka.ms/terminal-documentation</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span>: <span class="string">&quot;https://aka.ms/terminal-profiles-schema&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;defaultProfile&quot;</span>: <span class="string">&quot;&#123;58ad8b0c-3ef8-5f4d-bc6f-13e4c00f2530&#125;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;initialRows&quot;</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">&quot;initialCols&quot;</span>: <span class="number">90</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// You can add more global application settings here.</span></span><br><span class="line">  <span class="comment">// To learn more about global settings, visit https://aka.ms/terminal-global-settings</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If enabled, selections are automatically copied to your clipboard.</span></span><br><span class="line">  <span class="attr">&quot;copyOnSelect&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If enabled, formatted data is also copied to your clipboard</span></span><br><span class="line">  <span class="attr">&quot;copyFormatting&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A profile specifies a command to execute paired with information about how it should look and feel.</span></span><br><span class="line">  <span class="comment">// Each one of them will appear in the &#x27;New Tab&#x27; dropdown,</span></span><br><span class="line">  <span class="comment">//   and can be invoked from the commandline with `wt.exe -p xxx`</span></span><br><span class="line">  <span class="comment">// To learn more about profiles, visit https://aka.ms/terminal-profile-settings</span></span><br><span class="line">  <span class="attr">&quot;profiles&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;defaults&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">// Put settings here that you want to apply to all profiles.</span></span><br><span class="line">      <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;acrylicOpacity&quot;</span>: <span class="number">0.75</span>,</span><br><span class="line">      <span class="attr">&quot;useAcrylic&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;colorScheme&quot;</span>: <span class="string">&quot;Campbell&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fontFace&quot;</span>: <span class="string">&quot;Consolas&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fontSize&quot;</span>: <span class="number">11</span>,</span><br><span class="line">      <span class="attr">&quot;cursorColor&quot;</span>: <span class="string">&quot;#00FF00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;cursorHeight&quot;</span>: <span class="number">25</span>,</span><br><span class="line">      <span class="attr">&quot;cursorShape&quot;</span>: <span class="string">&quot;vintage&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;snapOnInput&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;padding&quot;</span>: <span class="string">&quot;0, 0, 0, 0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;closeOnExit&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;list&quot;</span>: [</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;58ad8b0c-3ef8-5f4d-bc6f-13e4c00f2530&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Debian&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;Windows.Terminal.Wsl&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;startingDirectory&quot;</span>: <span class="string">&quot;//wsl$/Debian/home/tom/&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// Make changes here to the cmd.exe profile.</span></span><br><span class="line">        <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Command Prompt&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;commandline&quot;</span>: <span class="string">&quot;cmd.exe&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hidden&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hidden&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Azure Cloud Shell&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;Windows.Terminal.Azure&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// Make changes here to the powershell.exe profile.</span></span><br><span class="line">        <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Windows PowerShell&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;commandline&quot;</span>: <span class="string">&quot;powershell.exe&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add custom color schemes to this array.</span></span><br><span class="line">  <span class="comment">// To learn more about color schemes, visit https://aka.ms/terminal-color-schemes</span></span><br><span class="line">  <span class="attr">&quot;schemes&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Campbell&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;foreground&quot;</span>: <span class="string">&quot;#A7B191&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;background&quot;</span>: <span class="string">&quot;#0C0C0C&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;#0C0C0C&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#C50F1F&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#13A10E&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#C19C00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#0037DA&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#881798&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#3A96DD&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#CCCCCC&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#767676&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#E74856&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#16C60C&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#F9F1A5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#3B78FF&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#B4009E&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#61D6D6&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#F2F2F2&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Solarized Dark&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;foreground&quot;</span>: <span class="string">&quot;#FDF6E3&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;background&quot;</span>: <span class="string">&quot;#073642&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;#073642&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#D30102&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#859900&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#B58900&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#268BD2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#D33682&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#2AA198&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#EEE8D5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#002B36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#CB4B16&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#586E75&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#657B83&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#839496&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#6C71C4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#93A1A1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#FDF6E3&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Solarized Light&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;foreground&quot;</span>: <span class="string">&quot;#073642&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;background&quot;</span>: <span class="string">&quot;#FDF6E3&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;#073642&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#D30102&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#859900&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#B58900&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#268BD2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#D33682&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#2AA198&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#EEE8D5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#002B36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#CB4B16&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#586E75&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#657B83&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#839496&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#6C71C4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#93A1A1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;#FDF6E3&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add custom actions and keybindings to this array.</span></span><br><span class="line">  <span class="comment">// To unbind a key combination from your defaults.json, set the command to &quot;unbound&quot;.</span></span><br><span class="line">  <span class="comment">// To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings</span></span><br><span class="line">  <span class="attr">&quot;actions&quot;</span>: [</span><br><span class="line">    <span class="comment">// Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.</span></span><br><span class="line">    <span class="comment">// These two lines additionally bind them to Ctrl+C and Ctrl+V.</span></span><br><span class="line">    <span class="comment">// To learn more about selection, visit https://aka.ms/terminal-selection</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;action&quot;</span>: <span class="string">&quot;copy&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;singleLine&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;keys&quot;</span>: <span class="string">&quot;ctrl+c&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;paste&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;keys&quot;</span>: <span class="string">&quot;ctrl+v&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Press Ctrl+Shift+F to open the search box</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;find&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;keys&quot;</span>: <span class="string">&quot;ctrl+shift+f&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Press Alt+Shift+D to open a new pane.</span></span><br><span class="line">    <span class="comment">// - &quot;split&quot;: &quot;auto&quot; makes this pane open in the direction that provides the most surface area.</span></span><br><span class="line">    <span class="comment">// - &quot;splitMode&quot;: &quot;duplicate&quot; makes the new pane use the focused pane&#x27;s profile.</span></span><br><span class="line">    <span class="comment">// To learn more about panes, visit https://aka.ms/terminal-panes</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;action&quot;</span>: <span class="string">&quot;splitPane&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;split&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;splitMode&quot;</span>: <span class="string">&quot;duplicate&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;keys&quot;</span>: <span class="string">&quot;alt+shift+d&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>更改配置的几个地方（不要直接复制粘贴，一些值不同）
<ul>
<li>更改<code>defaultProfile</code>，后面的值就粘贴<code>list</code>里面的几个项的<code>guid</code>，这是默认启动打开哪个命令行，我设置的是Debian的</li>
<li><code>initialRows</code>和<code>initialCols</code>设置打开后初始宽高</li>
<li><code>profiles</code>中的<code>defaults</code>是全局设置，可以对照更改。<code>list</code>里面就是Terminal管理的几个命令行软件，有刚装的debian，cmd，Powershell等</li>
<li>我在<code>list</code>里<code>Debian</code>的设置中加了<code>&quot;startingDirectory&quot;:&quot;//wsl$/Debian/home/tom/&quot;</code>，这是默认打开Debian后的目录，tom是我的用户名，大家可以改成自己的</li>
<li><code>schemes</code>中的配置是主题的一些配置，大家可以直接复制粘贴过去添加上</li>
<li><code>actions</code>中是快捷键的配置，大家自行参考</li>
</ul>
</li>
</ol>
<p>恭喜，至此Terminal配置完毕，我用的也是老师给的配置，觉得挺简约还挺好看的，一些其他更花里胡哨的配置请自行网上冲浪</p>
<h2 id="配置wsl"><a class="markdownIt-Anchor" href="#配置wsl"></a> 配置wsl</h2>
<p>言归正传，接下来我们可以使用terminal打开debian，可以在那个加号后面的向下的小箭头里面选择打开的命令行</p>
<h3 id="换源"><a class="markdownIt-Anchor" href="#换源"></a> 换源</h3>
<p>因为debian使用apt作为包管理器，而apt的默认服务器在国外，网速很慢，我们可以换到国内的镜像源来</p>
<ol>
<li>
<p>使用<code>su</code>切换到root权限</p>
</li>
<li>
<p>输入<code>cd /etc/apt</code>切换到对应目录</p>
</li>
<li>
<p>输入<code>cp /etc/apt/sources.list /etc/apt/sources.list_backup</code>备份一下源文件，出错的话便于还原</p>
</li>
<li>
<p>输入<code>nano sources.list</code>利用nano打开<code>sources.list</code>文件</p>
<blockquote>
<p>如果你会使用其他文本编辑器也是一样的<br />
实在不会用的话也可以用记事本，wsl的根目录在windows的<code>C:\Users\Admin\AppData\Local\Packages\TheDebianProject.DebianGNULinux_76v4gfsz19hv4\LocalState\rootfs</code>下，其中用户名和装的Linux有出入，大家对照自己的就行<br />
用记事本打开并做下面更改，保存即可</p>
</blockquote>
</li>
<li>
<p>删除所有内容，将以下内容复制粘贴进去**（命令行中复制和粘贴都是右键）**</p>
<p>debian源：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 中科大源</span><br><span class="line">deb http:<span class="comment">//mirrors.ustc.edu.cn/debian stable main contrib non-free</span></span><br><span class="line"><span class="meta"># deb-src http:<span class="comment">//mirrors.ustc.edu.cn/debian stable main contrib non-free</span></span></span><br><span class="line">deb http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-updates main contrib non-free</span></span><br><span class="line"><span class="meta"># deb-src http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-updates main contrib non-free</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># deb http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free</span></span></span><br><span class="line"><span class="meta"># deb-src http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free</span></span></span><br></pre></td></tr></table></figure>
<p>Ubuntu源：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#  阿里源</span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>ctrl+x</code>退出，输入<code>y</code>再点<code>enter</code>确定修改</p>
</li>
<li>
<p>换源完成</p>
</li>
</ol>
<h2 id="更新包"><a class="markdownIt-Anchor" href="#更新包"></a> 更新包</h2>
<ol>
<li><code>sudo apt update</code>会将新的包下载下来</li>
<li><code>sudo apt upgrade</code>会升级为最新的包，两条命令顺序不要反了</li>
<li>以后安装软件就可以<code>sudo apt install 软件名</code>了，嘻嘻，快捷方便</li>
</ol>
<p><strong>恭喜你，你的wsl已经搞定啦，享受Linux带来的快乐吧！</strong></p>
]]></content>
      <categories>
        <category>wsl</category>
      </categories>
      <tags>
        <tag>自学</tag>
        <tag>Linux</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒-基础-代码初始</title>
    <url>/archives/b087ef83.html</url>
    <content><![CDATA[<h3 id="病毒基础-代码初始"><a class="markdownIt-Anchor" href="#病毒基础-代码初始"></a> 病毒基础-代码初始</h3>
<h4 id="1-代码初识"><a class="markdownIt-Anchor" href="#1-代码初识"></a> 1. 代码初识</h4>
<p>我们需要掌握的工具</p>
<ol>
<li>vc反汇编调试</li>
<li>文本编辑工具UltraEdit（UE）</li>
<li>ollydebug调试（od）</li>
<li>静态反汇编工具ida</li>
<li>汇编代码撰写工具nasm</li>
</ol>
<span id="more"></span>
<h4 id="2-大端机和小端机"><a class="markdownIt-Anchor" href="#2-大端机和小端机"></a> 2. 大端机和小端机</h4>
<p>小端机：高位地址存放高位数据、低位地址存放低位数据。例如Intel的X86系列CPU<br />
小端机：高位地址存放低位数据、低位地址存放高位数据。例如PowerPC、Sun的SPARC、Motorola 6800</p>
<h4 id="3-jmp指令解析"><a class="markdownIt-Anchor" href="#3-jmp指令解析"></a> 3. JMP指令解析</h4>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E5%88%9D%E5%A7%8B/image-20210425160344966.png" alt="image-20210425160344966" /></p>
<p>Jmp 无条件跳转指令，有以下四种用法：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E5%88%9D%E5%A7%8B/image-20210425160536816.png" alt="image-20210425160536816" /></p>
<p>注意：在上述PPT中使用了Jmp offset的方式，其中地址2的地址是地址1的地址加上5个字节</p>
<p><strong>使用反汇编修改内存和使用工具修改硬盘文件步骤一样，工具不同，本质相同</strong></p>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒-基础-文件系统</title>
    <url>/archives/c3d31f32.html</url>
    <content><![CDATA[<h3 id="病毒基础-文件系统"><a class="markdownIt-Anchor" href="#病毒基础-文件系统"></a> 病毒基础-文件系统</h3>
<h4 id="初识文件系统"><a class="markdownIt-Anchor" href="#初识文件系统"></a> 初识文件系统</h4>
<p>文件系统就是组织文件的一种方式<br />
文件管理包括文件生成、删除、目录查询等<br />
eg：</p>
<ol>
<li>Windows文件系统：FAT12、FAT16、FAT32、NTFS</li>
<li>Linux文件系统：EXT2</li>
</ol>
<span id="more"></span>
<h4 id="fat12文件系统的磁盘格式"><a class="markdownIt-Anchor" href="#fat12文件系统的磁盘格式"></a> FAT12文件系统的磁盘格式</h4>
<ol>
<li>引导扇区（DBR）：记录各种参数，比如扇区大小，一簇的扇区数</li>
<li>文件分配表（FAT）：记录已分配的扇区和可用扇区</li>
<li>文件目录表（DIR）：记录根目录文件项的表，文件项包括文件，目录。</li>
<li>用户数据：存放数据的区域</li>
</ol>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210425164158141.png" alt="image-20210425164158141" /></p>
<p>注：左侧为扇区号、第二个FAT12为备用FAT</p>
<h4 id="如何定位到一个文件"><a class="markdownIt-Anchor" href="#如何定位到一个文件"></a> 如何定位到一个文件</h4>
<h5 id="fat表的格式"><a class="markdownIt-Anchor" href="#fat表的格式"></a> FAT表的格式</h5>
<p>在文件系统中，文件分配的最小单位是簇，哪怕只有一个字节也会分配一簇<br />
簇是由n个扇区组成<br />
其中n在引导扇区的引导记录中定义</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428094415697.png" alt="image-20210428094415697" /></p>
<h5 id="fat表的本质"><a class="markdownIt-Anchor" href="#fat表的本质"></a> FAT表的本质</h5>
<p>FAT表的本质是<strong>磁盘簇分配情况的数据表示</strong></p>
<p>在FAT12文件系统中，FAT表以3个<strong>半字节</strong>（3*0.5Byte=1.5Byte=12bit）来记录一个簇的相关情况，这也是FAT12中12的由来</p>
<p>FAT表中每3个<strong>半字节</strong>为一个元素，这个元素就代表一个簇，簇号从0开始，这个元素中<strong>存放的整数值</strong>表示其链接的下一簇的簇号</p>
<h5 id="fat表的查找与遍历机制"><a class="markdownIt-Anchor" href="#fat表的查找与遍历机制"></a> FAT表的查找与遍历机制</h5>
<p>FAT表是一个数组，数组中每个元素是1.5字节的整数，为了查找FAT表中簇号为N的元素，只需用N作索引查找FAT[N]元素，如下图：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428095326854.png" alt="image-20210428095326854" /></p>
<p>真正在FAT12表中的查找方法：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428095655541.png" alt="image-20210428095655541" /></p>
<p><strong>注意：三个字节中如何分配的两个半字节，可以结合小端机中数据的存放规则记忆</strong></p>
<h5 id="遍历一个文件占用的簇"><a class="markdownIt-Anchor" href="#遍历一个文件占用的簇"></a> 遍历一个文件占用的簇</h5>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428100002898.png" alt="image-20210428100002898" /></p>
<h5 id="如何获取首簇号"><a class="markdownIt-Anchor" href="#如何获取首簇号"></a> 如何获取首簇号</h5>
<p>根目录区有根目录表，其记录了文件的各种信息。<br />
根目录表中包含多条记录，每条记录占32个字节</p>
<p>现在我们关注根目录表中的<strong>文件名</strong>字段和<strong>首簇号</strong>字段<br />
文件名</p>
<blockquote>
<p>在记录首部偏移0开始，共11字节，前8个字节记录文件名，后3个字节记录扩展名（中间的.不需要记录）名字的结束以空格表示（即0x20）</p>
</blockquote>
<p>首簇号</p>
<blockquote>
<p>首簇号首部偏移0x1A开始，共2个字节</p>
</blockquote>
<p>下图是getexe.com的文件名与首簇号图示，getexe只占用6个字节，后两个字节用空格填充，首簇号是0003</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428160041729.png" alt="image-20210428160041729" /></p>
<h5 id="如何查找根目录"><a class="markdownIt-Anchor" href="#如何查找根目录"></a> 如何查找根目录</h5>
<ol>
<li>从磁盘0头0道1扇区读出引导区（Boot）512字节，从其中引导记录获取相关信息：Boot区占用扇区数，FAT表数目，每个FAT表的扇区数，1个扇区的字节数</li>
<li>计算根目录区的起始位置为：<br />
[ 1（Boot区扇区数）+2（FAT数目）*9（FAT扇区数）] * 512 = 0x2600<br />
即2600h为根目录区起始位置</li>
<li>从引导记录获取根区记录数，缺省224条，按每条记录32字节读出所有记录</li>
<li>每条记录开始11个字节为文件名，比较文件名匹配则找到记录，从首簇字段（从该记录开始偏移1Ah处）获得首簇号</li>
</ol>
<h5 id="多级目录的查找流程"><a class="markdownIt-Anchor" href="#多级目录的查找流程"></a> 多级目录的查找流程</h5>
<p>以查找a:\tem\tem.txt为例</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210428161152854.png" alt="image-20210428161152854" /></p>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒_概述</title>
    <url>/archives/c513bfe.html</url>
    <content><![CDATA[<h3 id="病毒概述"><a class="markdownIt-Anchor" href="#病毒概述"></a> 病毒概述</h3>
<h4 id="你能学到什么"><a class="markdownIt-Anchor" href="#你能学到什么"></a> 你能学到什么？</h4>
<ol>
<li>代码解密</li>
<li>文件系统和硬盘数据结构</li>
<li>DOS下的病毒技术：文件型病毒，引导型病毒，中断型病毒</li>
<li>Windows下的病毒：PE病毒，导入表，导出表，病毒的入口点模糊技术</li>
</ol>
<h4 id="先决课程"><a class="markdownIt-Anchor" href="#先决课程"></a> 先决课程</h4>
<ol>
<li>汇编语言</li>
<li>计算机组成原理</li>
</ol>
<span id="more"></span>
<h4 id="11-病毒定义"><a class="markdownIt-Anchor" href="#11-病毒定义"></a> 1.1 病毒定义</h4>
<p>计算机病毒：病毒特征+程序代码</p>
<h4 id="12-病毒的本质与特征"><a class="markdownIt-Anchor" href="#12-病毒的本质与特征"></a> 1.2 病毒的本质与特征</h4>
<p><strong>病毒的固有本质属性：人为的特制程序</strong><br />
程序性和客观性决定了病毒的可防治性和可清除性<br />
人为性和主观性导致了病毒各异多变</p>
<h5 id="基本特征传染性"><a class="markdownIt-Anchor" href="#基本特征传染性"></a> 基本特征：传染性</h5>
<p>传染性是指计算机病毒把自身复制到其他程序的能力<br />
即将自身的代码<strong>强行</strong>传染到<strong>一切符合其传染条件</strong>的程序之上<br />
是否具有传染性是判别一个程序是否为计算机病毒的<strong>首要条件</strong></p>
<h5 id="基本特征隐蔽性"><a class="markdownIt-Anchor" href="#基本特征隐蔽性"></a> 基本特征：隐蔽性</h5>
<p>传染过程的隐蔽性<br />
病毒存在的隐蔽性</p>
<h5 id="基本特征可触发性"><a class="markdownIt-Anchor" href="#基本特征可触发性"></a> 基本特征：可触发性</h5>
<p>可触发性是指因某个事件或数值的出现，触发病毒实施感染或攻击破坏<br />
即隐藏又保持破坏力</p>
<h5 id="其他基本特征"><a class="markdownIt-Anchor" href="#其他基本特征"></a> 其他基本特征</h5>
<ol>
<li>欺骗性</li>
<li>非授权性</li>
<li>寄生性</li>
<li>衍生性</li>
<li>持久性</li>
<li>破坏性</li>
<li>针对性</li>
<li>不可预见性</li>
</ol>
<h4 id="13-病毒的分类"><a class="markdownIt-Anchor" href="#13-病毒的分类"></a> 1.3 病毒的分类</h4>
<ol>
<li>
<p>根据病毒表现行为分类</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E6%A6%82%E8%BF%B0/image-20210422205247089.png" alt="image-20210422205247089" /></p>
</li>
<li>
<p>根据病毒的内部机理分类<br />
<img src="/images/%E7%97%85%E6%AF%92-%E6%A6%82%E8%BF%B0/image-20210422205355394.png" alt="image-20210422205355394" /></p>
</li>
</ol>
<h4 id="14-恶意程序-蠕虫-木马"><a class="markdownIt-Anchor" href="#14-恶意程序-蠕虫-木马"></a> 1.4 恶意程序 蠕虫 木马</h4>
<p>恶意程序：未经授权便干扰或破坏计算机系统/网络的程序或代码，早期恶意代码的主要形式是计算机病毒<br />
蠕虫：独立的可执行程序，不需要寄生在宿主程序中，通过网络分发自己的副本<br />
病毒和蠕虫的区别：<br />
<img src="/images/%E7%97%85%E6%AF%92-%E6%A6%82%E8%BF%B0/image-20210422205811795.png" alt="image-20210422205811795" /><br />
特洛伊木马：在远程计算机之间建立连接，使得远程计算机能通过网络控制本地计算机的非法程序</p>
<h4 id="15-病毒的命名规则"><a class="markdownIt-Anchor" href="#15-病毒的命名规则"></a> 1.5 病毒的命名规则</h4>
<p>一些普通命名规则</p>
<ol>
<li>按病毒的发作时间命名</li>
<li>按病毒的发作症状命名</li>
<li>按病毒的发现地命名</li>
<li>按病毒的字节长度命名</li>
</ol>
<p>国际命名惯例<br />
前缀（病毒的种类）+病毒名（病毒家族的特征）+后缀（区分病毒变种）</p>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>系统结构第一章_量化设计与分析基础</title>
    <url>/archives/6f1a4250.html</url>
    <content><![CDATA[<h1 id="系统结构第一章-量化设计与分析基础"><a class="markdownIt-Anchor" href="#系统结构第一章-量化设计与分析基础"></a> 系统结构第一章-量化设计与分析基础</h1>
<h2 id="1-计算机的分类"><a class="markdownIt-Anchor" href="#1-计算机的分类"></a> 1. 计算机的分类</h2>
<h3 id="11-flynns分类"><a class="markdownIt-Anchor" href="#11-flynns分类"></a> 1.1 Flynn’s分类</h3>
<p>定义：基于指令流和数据流数量的计算机结构分类</p>
<ol>
<li>
<p>SISD</p>
<p>串行计算机、确定执行<br />
在任一时钟周期只有单个指令流在CPU执行<br />
在任一时钟周期只有单个数据流用作输入</p>
</li>
<li>
<p>SIMD</p>
<p>数据级并行、适用于处理高度规整操作的问题，如图像处理、同步和确定执行<br />
在任一时钟周期，所有处理单元执行相同的指令<br />
每个处理单元能对不同数据元素进行操作</p>
<span id="more"></span>
</li>
<li>
<p>MISD</p>
<p>少有<br />
单个数据流进入多个处理单元<br />
每个处理单元用单个数据流对数据进行独立操作</p>
</li>
<li>
<p>MIMD</p>
<p>线程级或任务级并行、可同步或异步、可确定或非确定<br />
每个处理器可以执行不同的指令流<br />
每个处理器可以对不同数据流进行操作</p>
</li>
</ol>
<h3 id="12-市场分类"><a class="markdownIt-Anchor" href="#12-市场分类"></a> 1.2 市场分类</h3>
<ol>
<li>个人移动设备</li>
<li>桌面计算机</li>
<li>服务器</li>
<li>集群/仓库级计算机</li>
<li>嵌入式计算机</li>
</ol>
<h2 id="2-系统结构定义和任务"><a class="markdownIt-Anchor" href="#2-系统结构定义和任务"></a> 2. 系统结构定义和任务</h2>
<h3 id="21-定义"><a class="markdownIt-Anchor" href="#21-定义"></a> 2.1 定义</h3>
<p>传统定义：由程序员（机器语言）看见的（计算）系统属性，即概念性结构和功能行为，以区分数据流动和控制逻辑设计的组成及物理实现</p>
<p>现代定义：在满足功能、性能和价格目标的条件下，设计、选择和互连硬件部件构成计算机</p>
<p>区分：</p>
<ol>
<li><strong>经典的计算机系统结构</strong>是机器语言程序员所看到的传统机器级所具有的属性。它确定计算机系统的软、硬件界面。</li>
<li><strong>计算机组成</strong>指的是计算机系统结构的逻辑实现，包括五大功能部件组成以及逻辑设计等。它着眼于机器级内各事件的排序方式与控制方式，各部件的功能以及各部件的联系。</li>
<li><strong>计算机实现</strong>指的是计算机组成的物理实现，包括处理机、主存等部件的物理结构，器件的集成度和速度功耗，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。它着眼于器件技术和微组装技术，其中器件技术在实现技术中占主导作用。</li>
</ol>
<p>例题：</p>
<ol>
<li>主存容量与编址方式(按位、按字节、按字访问等)的确定属于<u>计算机系统结构</u></li>
<li>为达到所定性能价格比，主存速度应多快，在逻辑结构上需采用什么措施(如多体交叉存储等)属于<u>计算机组成</u></li>
<li>主存系统的物理实现，如存储器器件的选定、逻辑电路的设计、微组装技术的选定属于<u>计算机实现</u></li>
</ol>
<p>影响：</p>
<ol>
<li>相同的计算机系统结构的计算机可以有不同的计算机组成</li>
<li>相同的计算机组成可以有不同的计算机实现</li>
</ol>
<p>系列机：</p>
<p>​	是指由一个制造商生产的具有相同的系统结构，但具有不同组成和实现的一系列不同型号的计算机</p>
<p>软件兼容性：</p>
<p>​	同一个软件可以不加修改地运行于系统结构相同的各档机器上，而且运行结果一样，差别只是运行时间不同</p>
<p>向后兼容：</p>
<p>​	在某一时间生产的机器上运行的目标软件能够直接运行于更晚生产的机器上</p>
<p>向上兼容：</p>
<p>​	在低档机器上运行的目标软件能够直接运行于高档机器上</p>
<p>指令集系统结构ISA的7个重要特征：</p>
<ol>
<li>ISA的类型：现代通用寄存器结构、早期累加器结构</li>
<li>存储器访问：字节访问等</li>
<li>寻址方式</li>
<li>操作数类型和大小：8位字符、32位整型数</li>
<li>操作类型：数据传输，算术/逻辑</li>
<li>控制流指令：转移，子程序调用/返回</li>
<li>ISA编码：固定长度，可变长度</li>
</ol>
<h3 id="22-任务"><a class="markdownIt-Anchor" href="#22-任务"></a> 2.2 任务</h3>
<ol>
<li>
<p>考虑</p>
<p>摩尔定律：集成在一个计算机芯片上的元件数量每两年翻一番<br />
经验法则：成本减少速度与密度增加速度成比例<br />
性能趋势：带宽改进优于时延<br />
经验法则：带宽增加速度与时延平方改进速度成比例</p>
</li>
<li>
<p>依据</p>
</li>
<li>
<p>量化原则</p>
</li>
</ol>
<h2 id="3-性能"><a class="markdownIt-Anchor" href="#3-性能"></a> 3. 性能</h2>
<p>SPEC率：一个测试程序在参考计算机上执行时间与被测计算机上执行时间的比值，越大说明被测计算机性能越高</p>
<p>Amdahl定律：采用更快执行方式后所带来的系统性能提高，与这种执行方式的使用频率或占总执行时间的比例有关</p>
<p>改进比例Fe：可改进部分执行时间与改进前整个任务的执行时间的比值</p>
<p>改进加速比Se：改进前改进部分的执行时间与改进后改进部分的执行时间的比值</p>
<p>改进后整个系统的加速比Sn=1/((1-Fe)+Fe/Se)</p>
<p>CPU<sub>time</sub> =指令数量*CPI*时钟周期</p>
]]></content>
      <categories>
        <category>系统结构</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title>系统结构第二章_指令系统原理与实例</title>
    <url>/archives/a6c351d5.html</url>
    <content><![CDATA[<h1 id="系统结构第二章-指令系统原理与实例"><a class="markdownIt-Anchor" href="#系统结构第二章-指令系统原理与实例"></a> 系统结构第二章-指令系统原理与实例</h1>
<h2 id="1-指令集系统结构的分类"><a class="markdownIt-Anchor" href="#1-指令集系统结构的分类"></a> 1. 指令集系统结构的分类</h2>
<p>根本区别：处理器内部数据的存储结构不同</p>
<p>存储结构：</p>
<ol>
<li>堆栈：操作数隐含的位于栈顶</li>
<li>累加器：一个隐含操作数就是累加器</li>
<li>通用寄存器：明确地指定操作数，不是寄存器就是存储器地址
<ol>
<li>register-memory系统结构：一般指令都可以访存</li>
<li>register-register/load-store系统结构：只有load、store指令能访存</li>
</ol>
</li>
</ol>
<span id="more"></span>
<p>图示：</p>
<p>数据流动示意图：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210502145943075.png" alt="image-20210502145943075" /></p>
<p>运算例子示意图：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210502150225975.png" alt="image-20210502150225975" /></p>
<p>通用寄存器ISA运算类指令的两个特性：</p>
<ol>
<li>ALU指令中包括两个或三个操作数</li>
<li>ALU指令中包括0到3个存储器操作数</li>
</ol>
<p>通用寄存器计算机优缺点：</p>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210502151144878.png" alt="image-20210502151144878" /></p>
<h2 id="2-存储器寻址"><a class="markdownIt-Anchor" href="#2-存储器寻址"></a> 2. 存储器寻址</h2>
<h3 id="21-寻址方式"><a class="markdownIt-Anchor" href="#21-寻址方式"></a> 2.1 寻址方式</h3>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210502152010830.png" alt="image-20210502152010830" /></p>
<h3 id="22-小结"><a class="markdownIt-Anchor" href="#22-小结"></a> 2.2 小结</h3>
<ol>
<li>一般ISA支持的基本寻址方式：立即数寻址、位移量寻址、寄存器间接寻址</li>
<li>位移量为13-16位、立即数为16位</li>
<li>立即数寻址通常用于：运算类指令、置常数到寄存器指令</li>
</ol>
<h2 id="3-mips系统结构"><a class="markdownIt-Anchor" href="#3-mips系统结构"></a> 3. MIPS系统结构</h2>
<p>特点：</p>
<ol>
<li>一种简单64位load-store系统结构</li>
<li>固定长度指令编码</li>
</ol>
<p>寄存器：</p>
<ol>
<li>32个64位通用寄存器（GPR），R0……R31，<strong>R0永远是0</strong></li>
<li>32个浮点寄存器（FPR），F0……F31，可作为32位单精度寄存器使用，也可作为64位双精度寄存器使用</li>
</ol>
<p>寻址方式：</p>
<ol>
<li>16位立即数寻址</li>
<li>16位基址寻址，当位移量为0时是寄存器间接寻址、当R0作为基址寄存器时是16位绝对寻址</li>
</ol>
<p>指令格式：</p>
<ol>
<li>指令长度：32位，6位为基本操作码</li>
<li>两种存储器寻址方式：编码到操作码中</li>
</ol>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210503153254772.png" alt="image-20210503153254772" /></p>
<p>操作：</p>
<ol>
<li>载入和存储
<ul>
<li>所有通用寄存器和浮点数寄存器都可以被载入或存储，除了R0</li>
<li><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210503153545936.png" alt="image-20210503153545936" /></li>
<li>上述图示说明：
<ol>
<li>⬅的下标表示传送n位</li>
<li>Mem表示主存，按字节编址</li>
<li>下标标识字段中特定的位，从以0开始的最高位开始标注</li>
<li>上标表示对字段的复制</li>
<li>##表示字段的连接</li>
</ol>
</li>
</ul>
</li>
<li>ALU操作
<ul>
<li>都是寄存器-寄存器指令</li>
<li>包括算术和逻辑操作：加、减、与、或、异或、移位</li>
<li><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210503154351355.png" alt="image-20210503154351355" /></li>
</ul>
</li>
<li>分支和跳转
<ul>
<li><img src="/images/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/image-20210503154602183.png" alt="image-20210503154602183" /></li>
</ul>
</li>
<li>浮点操作
<ul>
<li>浮点指令指出操作数是单精度（SP）还是双精度（DP）</li>
<li>MOV.S和MOV.D分别复制单精度和双精度的寄存器</li>
<li>MFC1、MTC1、DMFC1、DMTC1在一个单精度或双精度浮点数寄存器和一个定点寄存器之间传送数据</li>
</ul>
</li>
</ol>
<h2 id="4-一些误区"><a class="markdownIt-Anchor" href="#4-一些误区"></a> 4. 一些误区</h2>
<ol>
<li>专门设计支持高级语言结构的“高级”指令功能</li>
<li>存在一种典型的程序</li>
<li>可以不考虑编译器而改进指令系统以缩减代码大小</li>
<li>有缺陷的系统结构不可能是一种成功的系统结构</li>
<li>可以设计一个没有缺陷的系统结构</li>
</ol>
]]></content>
      <categories>
        <category>系统结构</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title>系统结构第三章_流水线</title>
    <url>/archives/ef24c61a.html</url>
    <content><![CDATA[<h1 id="系统结构第三章-流水线"><a class="markdownIt-Anchor" href="#系统结构第三章-流水线"></a> 系统结构第三章-流水线</h1>
<span id="more"></span>]]></content>
      <categories>
        <category>系统结构</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>系统结构</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第三章</title>
    <url>/archives/542a11c0.html</url>
    <content><![CDATA[<h3 id="编译原理第三章-控制结构"><a class="markdownIt-Anchor" href="#编译原理第三章-控制结构"></a> 编译原理第三章-控制结构</h3>
<p>定义：规定程序语句和程序单元的执行流程</p>
<p>分类：语句级控制结构、单元级控制结构</p>
<h4 id="语句级控制结构"><a class="markdownIt-Anchor" href="#语句级控制结构"></a> 语句级控制结构</h4>
<p>定义：用来构造语句执行流程的机制</p>
<p>分类：顺序、选择（分支）、重复（循环）</p>
<span id="more"></span>
<ol>
<li>
<p>顺序</p>
<blockquote>
<p>语句结束标记 ；</p>
<p>复合语句：begin……end、{……}</p>
</blockquote>
</li>
<li>
<p>选择</p>
<blockquote>
<p>单选if then</p>
<p>二选一if then else</p>
<p>多选一 嵌套if then else</p>
</blockquote>
</li>
<li>
<p>重复</p>
<blockquote>
<p>计数器制导</p>
<p>条件制导</p>
</blockquote>
</li>
</ol>
<h4 id="单元级控制结构"><a class="markdownIt-Anchor" href="#单元级控制结构"></a> 单元级控制结构</h4>
<p>定义：规定程序单元之间控制流程的机制</p>
<h5 id="显式调用从属单元"><a class="markdownIt-Anchor" href="#显式调用从属单元"></a> 显式调用从属单元</h5>
<blockquote>
<p>eg：</p>
<p>FORTRAN语言的子程序和函数</p>
<p>PASCAL语言的函数和过程</p>
<p>C语言的函数</p>
</blockquote>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20210413150345535.png" alt="image-20210413150345535" /></p>
<h5 id="隐式调用单元异常处理"><a class="markdownIt-Anchor" href="#隐式调用单元异常处理"></a> 隐式调用单元——异常处理</h5>
<p>异常定义：导致程序正常执行中止的事件</p>
<p>异常处理的主要问题：</p>
<blockquote>
<ol>
<li>异常如何说明，它的作用域是什么？</li>
<li>异常如何发生？（如何捕获异常）</li>
<li>发生异常时，流程如何转移？</li>
<li>发生异常时，如何绑定相应的异常处理程序？</li>
<li>处理异常之后，控制流程转向何处？</li>
</ol>
</blockquote>
<blockquote>
<p>问题（5）的解决方法：</p>
<ol>
<li>
<p>允许控制返回发生异常事件的执行点</p>
<p>这种情况下，异常处理程序可对执行的程序进行“修补”，终止相应的异常事件，以便程序继续正常地执行。</p>
<p>解决了程序继续执行的问题，但并未真正消除发生异常的因素。</p>
</li>
<li>
<p>由异常处理程序进行控制的转移</p>
<p>意味着引起异常的单元不能恢复执行；从实现的观点来看，这意味着删除异常单元的活动记录。</p>
</li>
</ol>
</blockquote>
<p>C++语言的异常处理：</p>
<blockquote>
<p>设置陷阱 try</p>
<p>抛出异常 throw</p>
<p>捕获异常 catch</p>
<p>C++的异常处理语句的格式如下：<br />
try  {  … }<br />
catch (异常类型1) { 异常1处理程序 }<br />
catch (异常类型2) {异常2处理程序}<br />
……<br />
catch (异常类型n) {异常n处理程序}</p>
</blockquote>
<p>协同程序间的控制转移关系：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20210413151632600.png" alt="image-20210413151632600" /></p>
<h4 id="并发单元"><a class="markdownIt-Anchor" href="#并发单元"></a> 并发单元</h4>
<p>eg：“生产者-消费者”问题</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20210413151822744.png" alt="image-20210413151822744" /></p>
<h5 id="并行与并发的区别"><a class="markdownIt-Anchor" href="#并行与并发的区别"></a> 并行与并发的区别</h5>
<blockquote>
<p>并行”是指无论从微观还是宏观，二者都是一起执行的，就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。<br />
而“并发”在微观上不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行，从宏观外来看，好像是这些进程都在执行，这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。<br />
从以上本质不难看出，“并发”执行，在多个进程存在资源冲突时，并没有从根本提高执行效率。</p>
</blockquote>
<h5 id="同步问题"><a class="markdownIt-Anchor" href="#同步问题"></a> 同步问题</h5>
<blockquote>
<p>正确访问存储区</p>
<ul>
<li>不会向已满的缓冲区写数据</li>
<li>不会向空缓冲区读数据</li>
</ul>
</blockquote>
<h5 id="动作的不可分"><a class="markdownIt-Anchor" href="#动作的不可分"></a> 动作的“不可分”</h5>
<blockquote>
<p>append是生产者向缓冲区存数的操作</p>
<p>remove是消费者从缓冲区取数的操作</p>
<p>设t表示所存项目总数</p>
<p>这两个操作都要修改t的值,相应执行操作(1)t:=t+1和(2)t:=t-1来实现。</p>
<p>假定(1)和(2)是这样实现的:<br />
读t到一个专用寄存器;<br />
更新专用寄存器的值;<br />
将专用寄存器的值写到t;</p>
<p>则：</p>
<p>执行(1)时不能执行(2),反之亦然。<br />
即,(1)和(2)必须以互斥的方式执行,(1)或(2)是不可分的操作。</p>
</blockquote>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第一章</title>
    <url>/archives/29225e4a.html</url>
    <content><![CDATA[<h3 id="编译原理第一章"><a class="markdownIt-Anchor" href="#编译原理第一章"></a> 编译原理第一章</h3>
<ol>
<li>
<p>语言的本质<br />
一组规则的组合</p>
<ol>
<li>字母表的定义</li>
<li>词法规则</li>
<li>语法规则</li>
<li>语义规则</li>
<li>语用规则</li>
</ol>
<span id="more"></span>
</li>
<li>
<p>与编译有关的三种语言和三种程序</p>
<table>
<thead>
<tr>
<th>源语言</th>
<th>工具语言</th>
<th>目标语言</th>
</tr>
</thead>
<tbody>
<tr>
<td>源程序</td>
<td>编译程序</td>
<td>目标程序</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>程序设计语言的分类</p>
<table>
<thead>
<tr>
<th>强制式语言</th>
<th>函数式语言</th>
<th>逻辑式语言</th>
<th>对象式语言</th>
</tr>
</thead>
<tbody>
<tr>
<td>冯·诺依曼模型</td>
<td>数学函数（函数运算）</td>
<td>数理逻辑、谓词演算</td>
<td>抽象数据类型</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>冯·诺依曼体系结构</p>
<ol>
<li>构成基础<br />
存储器、控制器、处理器、ip</li>
<li>特点
<ul>
<li>数据、指令以二进制形式存储</li>
<li>存储程序的工作方式</li>
<li>程序顺序执行，可强制修改执行顺序</li>
<li>存储器内容可以被修改</li>
</ul>
</li>
</ol>
</li>
<li>
<p>变量的4个属性</p>
<ol>
<li>
<p>作用域</p>
<blockquote>
<ul>
<li>静态绑定：依据变量定义的位置</li>
<li>动态绑定：依据过程的调用关系</li>
</ul>
</blockquote>
<ul>
<li>全局变量</li>
<li>局部变量</li>
<li>非局部变量</li>
</ul>
</li>
<li>
<p>生存期</p>
<blockquote>
<ul>
<li>全局变量静态分配</li>
<li>局部变量运行前静态分配，运行时动态分配</li>
<li>非局部变量可静态分配可动态分配</li>
<li>匿名变量是通过指针访问，是动态分配</li>
</ul>
</blockquote>
</li>
<li>
<p>值</p>
<blockquote>
<ul>
<li>二进制编码</li>
<li>按类型解释</li>
<li>变量与值的绑定是动态的</li>
<li>常量的值不能修改</li>
<li>数据对象表示存储区和它保存的值</li>
</ul>
</blockquote>
</li>
<li>
<p>类型</p>
<blockquote>
<p>静态绑定语言是面向编译的语言<br />
动态绑定语言是面向解释的语言</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>虚拟机<br />
M1是实际的机器<br />
机器语言是汇编语言的M2=M1+汇编程序<br />
机器语言是高级语言的M3=M2+编译程序</p>
</li>
<li>
<p>程序单元</p>
<ol>
<li>
<p>定义：程序执行过程中被独立调用单元，包括子程序、分程序、过程等</p>
</li>
<li>
<p>表示：</p>
<blockquote>
<ul>
<li>
<p>编译时：单元的源程序</p>
</li>
<li>
<p>运行时：一个代码段和一个活动记录组成，称为单元实例</p>
</li>
<li>
<blockquote>
<p>活动记录：执行单元需要的信息和局部变量等数据存储区</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li>
<p>实例：</p>
<blockquote>
<ul>
<li>非局部变量：一个程序单元可以引用未被本单元说明而被其它单元说明的变量</li>
<li>全局变量：一个程序中各个程序单元都可以引用的变量</li>
</ul>
</blockquote>
</li>
</ol>
</li>
<li>
<p>C程序运行时的存储空间</p>
<ol>
<li>
<p>程序代码区：存储程序代码（编译后形成的二进制机器指令序列）</p>
</li>
<li>
<p>数据静态存储区：存储程序的<strong>常量数据、全局数据、static数据</strong></p>
</li>
<li>
<p>数据动态存储区：</p>
<blockquote>
<p>栈：存储返回地址、CPU现场、临时变量、<strong>形参、局部变量</strong><br />
堆：存储动态内存申请数据</p>
</blockquote>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第二章</title>
    <url>/archives/1934b292.html</url>
    <content><![CDATA[<h3 id="编译原理第二章"><a class="markdownIt-Anchor" href="#编译原理第二章"></a> 编译原理第二章</h3>
<ol>
<li>
<p>数据类型的分类</p>
<ol>
<li>
<p>内部类型</p>
<blockquote>
<p>优点：</p>
<ol>
<li>基本表示的不可见性</li>
<li>编译时能检查变量使用的正确性</li>
<li>编译时可以确定无二义的操作</li>
<li>精度控制</li>
</ol>
</blockquote>
</li>
</ol>
</li>
</ol>
<span id="more"></span>
<ol start="2">
<li>
<p>用户定义类型</p>
<blockquote>
<ol>
<li>有限映像：<br />
定义：从定义域类型DT值的有限集合，到值域类型RT值的有限集合的函数（映射）<br />
eg：array[1…50] of char 中整数1至50到字符集的有限映像</li>
<li>序列：<br />
定义：任意多个数据项组成，数据项称为序列的成分，且<strong>类型相同</strong></li>
<li>判定或：<br />
定义：可以选择不同成员的构造机制<br />
eg：PASCAL的变体记录、C的联合<br />
eg：<br />
变体记录定义如下：</li>
</ol>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> dept=(house,sports,drugs,food,liquor);</span><br><span class="line">month=<span class="number">1</span>..<span class="number">12</span>;</span><br><span class="line">item=<span class="keyword">record</span></span><br><span class="line">    price:real;</span><br><span class="line">    <span class="keyword">case</span> available:boolean <span class="keyword">of</span></span><br><span class="line">        true:(amount:integer;  </span><br><span class="line">            where:dept);</span><br><span class="line">        false:(month_expected:month)</span><br><span class="line"> <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>实现代码如下：</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  i1,i2:item:</span><br><span class="line">i1.price:=<span class="number">5.24</span>;i1.available:=true;</span><br><span class="line">i1.amount:=<span class="number">29</span>;i1.where:=liquor;</span><br><span class="line">i2.price:=<span class="number">324.99</span>;i2.available:=false;</span><br><span class="line">i2.month_expect:=<span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>则空间分配情况如下：</p>
<center>i1</center>
<table>
<thead>
<tr>
<th>变量名</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>price</td>
<td>5.24</td>
</tr>
<tr>
<td>available</td>
<td>true</td>
</tr>
<tr>
<td>amount</td>
<td>29</td>
</tr>
<tr>
<td>where</td>
<td>liquor</td>
</tr>
</tbody>
</table>
<center>i2</center>
<table>
<thead>
<tr>
<th>变量名</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>price</td>
<td>324.99</td>
</tr>
<tr>
<td>available</td>
<td>false</td>
</tr>
<tr>
<td>month_expected</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ol start="4">
<li>幂集<br />
定义：类型T的元素的所有子集的集合，T为基类型</li>
</ol>
</blockquote>
</li>
<li>
<p>抽象数据类型</p>
</li>
<li>
<p>C语言的数据类型</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210414193241257.png" alt="image-20210414193241257" /></p>
<ol>
<li>非结构类型：<br />
1.内部类型<br />
整型：int、short、long、unsigned<br />
浮点型：float、double<br />
字符型：char（有限字符集的元素）</li>
<li>用户定义的非结构类型<br />
枚举：enum</li>
<li>结构类型
<ol>
<li>数组</li>
<li>结构struct</li>
<li>联合union（C的联合是不安全的）</li>
<li>文件FILE</li>
</ol>
</li>
<li>指针</li>
<li>空类型void</li>
</ol>
<blockquote>
<p>不允许定义空类型变量，可以定义空类型指针变量</p>
</blockquote>
</li>
<li>
<p>类型检查<br />
定义：对数据的操作和对应的类型是否匹配的一致性检查<br />
eg：非法运算、赋值运算、形参实参类型是否匹配</p>
<ol>
<li>静态检查和动态检查</li>
</ol>
<blockquote>
<p>静态检查使程序更有效<br />
动态检查是编程更方便，但是影响了可靠性且降低了执行效率</p>
</blockquote>
<ol start="2">
<li>语言分类</li>
</ol>
<blockquote>
<p>无类型语言：没有数据类型<br />
eg：函数式语言（FP）、泛函程序设计语言（FFP）<br />
弱类型语言：类型检查全部或部分在运行时完成<br />
eg：PASCAL<br />
强类型语言：类型检查都在编译时完成<br />
eg：C、ADA</p>
</blockquote>
</li>
<li>
<p>实现模型<br />
在程序中，数据由常量或变量表示<br />
在实现模型中，数据由描述符（描述数据对象的属性）和数据对象（存储区及其内容）表示</p>
<blockquote>
<ol>
<li>内部类型和用户定义的非结构类型：描述符一般由类型描述和指针组成<br />
<strong>多个变量的描述符形成变量名表</strong><br />
eg：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> numb;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210411152405051.png" alt="image-20210411152405051" /></p>
<ol start="2">
<li>结构类型</li>
</ol>
<ul>
<li>笛卡尔积<br />
各成分按顺序存储，每个成分占整数个存储单元<br />
描述符包含：类型名、构造符、若干三元式（选择符名、域类型、指针）（每个域对应一个三元式）<br />
eg：</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> t=recode a:real;</span><br><span class="line">              b:integer;</span><br><span class="line">       <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span> x:t;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210411155756373.png" alt="image-20210411155756373" /></p>
<ul>
<li>有限映像<br />
为每一成分分配整数个可编址的存储单元<br />
描述符包括：类型名、构造符、<strong>定义域的基类型</strong>、下界、上界、成分类型、（每个成分占）单元个数、<strong>首地址</strong><br />
eg：</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> a=<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">10</span>] <span class="keyword">of</span> real;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210411160449254.png" alt="image-20210411160449254" /></p>
<ul>
<li>序列<br />
可变长串的表示：静态描述符+动态描述符+堆</li>
</ul>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210411161113371.png" alt="image-20210411161113371" /></p>
<ul>
<li>判定或<br />
pascal的变体记录：描述符、数据对象、case表、若干变体描述符</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> v=<span class="keyword">record</span> a:integer;</span><br><span class="line">              <span class="keyword">case</span> b:boolean <span class="keyword">of</span></span><br><span class="line">                   true:(c:integer);</span><br><span class="line">                   false:(d:integer;</span><br><span class="line">                          e:real)</span><br><span class="line">       <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210411161638987.png" alt="image-20210411161638987" /></p>
<ul>
<li>
<p>指针</p>
<p>表示与内部类型相同只是其值为地址</p>
<p>指针指向的匿名数据对象分配在堆上</p>
</li>
<li>
<p><strong>编译时所有的描述符保存在一张表中以便编译时使用，甚至有些描述符要保存到运行阶段（数组），并且存储在描述符中的属性可能随运行而变化。</strong></p>
</li>
</ul>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第五章</title>
    <url>/archives/8c99cde2.html</url>
    <content><![CDATA[<h3 id="编译原理第五章-编译概述"><a class="markdownIt-Anchor" href="#编译原理第五章-编译概述"></a> 编译原理第五章-编译概述</h3>
<h4 id="1-不同语言程序之间的翻译"><a class="markdownIt-Anchor" href="#1-不同语言程序之间的翻译"></a> 1. 不同语言程序之间的翻译</h4>
<h5 id="11-翻译"><a class="markdownIt-Anchor" href="#11-翻译"></a> 1.1 翻译</h5>
<p>定义：语法单位之间等价的变换<br />
就是将一种语言编写的程序转换成等价的另一种语言编写的程序</p>
<h5 id="12-特殊的翻译汇编-编译"><a class="markdownIt-Anchor" href="#12-特殊的翻译汇编-编译"></a> 1.2 特殊的翻译：汇编、编译</h5>
<p>汇编：将汇编语言程序翻译为机器语言的程序<br />
编译：将高级语言程序翻译为低级语言的程序</p>
<span id="more"></span>
<h5 id="13-翻译程序"><a class="markdownIt-Anchor" href="#13-翻译程序"></a> 1.3 翻译程序</h5>
<p>定义：完成翻译工作的程序，也叫翻译器</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20210426201154954.png" alt="image-20210426201154954" /></p>
<p>宿主语言：翻译程序对应的语言<br />
宿主机：运行翻译程序的机器</p>
<h5 id="14-编译程序"><a class="markdownIt-Anchor" href="#14-编译程序"></a> 1.4 编译程序</h5>
<p>定义：实现编译的翻译程序，也叫编译器</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20210426201419434.png" alt="image-20210426201419434" /></p>
<p>自驻留的编译程序：编译程序生成宿主机执行的机器代码<br />
自编译的编译程序：编译程序是用源语言写的<br />
交叉编译：编译程序生成的不是宿主机执行的机器代码</p>
<h4 id="2-编译的步骤"><a class="markdownIt-Anchor" href="#2-编译的步骤"></a> 2. 编译的步骤</h4>
<p>逻辑上分为两部分：</p>
<ol>
<li>源程序的分析</li>
<li>目标程序的合成</li>
</ol>
<p>具体为5个步骤：</p>
<ol>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析与中间代码生成</li>
<li>中间代码优化</li>
<li>目标代码生成</li>
</ol>
<p><strong>编译的每个步骤都需要：</strong></p>
<ol>
<li>符号表管理</li>
<li>出错处理</li>
</ol>
<h5 id="21-词法分析"><a class="markdownIt-Anchor" href="#21-词法分析"></a> 2.1 词法分析</h5>
<p>分析输入的字符串，根据词法规则识别出单词符号<br />
单词符号：基本字、标识符、字面常量、运算符、界符</p>
<h5 id="22-语法规则"><a class="markdownIt-Anchor" href="#22-语法规则"></a> 2.2 语法规则</h5>
<p>根据语法规则，识别各类语法单位并进行语法检查<br />
语法单位：表达式、语句、程序单元、程序</p>
<h5 id="23-语义分析与中间代码生成"><a class="markdownIt-Anchor" href="#23-语义分析与中间代码生成"></a> 2.3 语义分析与中间代码生成</h5>
<p>根据语义规则，对语法正确的语法单位进行翻译<br />
注：可以直接生成目标程序，但目标程序执行效率低，故而生成中间代码</p>
<p>中间代码：大多数的编译器采用中间代码来描述源程序的语义，这种中间语言对应某种抽象机，结构简单，语义明确，易于翻译成目标代码，同时也便于优化和移植。</p>
<h5 id="24-优化"><a class="markdownIt-Anchor" href="#24-优化"></a> 2.4 优化</h5>
<p>对中间代码进行等价变换，提高代码的时空效率<br />
注：语义分析产生的中间代码不依赖于实际的机器，故而易于做一些等价变换，使生成的目标程序占用空间更少，执行更快。</p>
<h5 id="25-目标代码生成"><a class="markdownIt-Anchor" href="#25-目标代码生成"></a> 2.5 目标代码生成</h5>
<p>根据优化后的中间代码以及有关信息，可生成较为有效的目标代码<br />
目标代码：目标机的机器语言程序或汇编语言程序<br />
注：若生成的是汇编语言程序，还需将其汇编成机器语言程序</p>
<h5 id="26-符号表管理"><a class="markdownIt-Anchor" href="#26-符号表管理"></a> 2.6 符号表管理</h5>
<p>描述符表：存放实体属性的表格<br />
注：根据实体的不同，表格的形式也不同，其中最主要的是<strong>符号表</strong><br />
注：编译程序应有一组表格管理程序，负责表格的建立、维护、引用、查找、更新</p>
<h5 id="27-出错处理"><a class="markdownIt-Anchor" href="#27-出错处理"></a> 2.7 出错处理</h5>
<p>编译程序发现错误后进行出错处理，包括报告错误的性质和发生错误的位置等</p>
<h5 id="28-编译器的结构"><a class="markdownIt-Anchor" href="#28-编译器的结构"></a> 2.8 编译器的结构</h5>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20210426210832819.png" alt="image-20210426210832819" /></p>
<h4 id="3-完整的程序处理过程"><a class="markdownIt-Anchor" href="#3-完整的程序处理过程"></a> 3. 完整的程序处理过程</h4>
<p>从分析源程序到建立一个可执行的目标程序，处理过程还需要<strong>预处理器、汇编器、连接器、装入器</strong></p>
<h5 id="31-完整的程序处理过程"><a class="markdownIt-Anchor" href="#31-完整的程序处理过程"></a> 3.1 完整的程序处理过程</h5>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20210426211128343.png" alt="image-20210426211128343" /></p>
<h4 id="4-编译前端与后端"><a class="markdownIt-Anchor" href="#4-编译前端与后端"></a> 4. 编译前端与后端</h4>
<p>现代编译器通常将编译过程划分为前端和后端分别实现，它们通过中间代码连接，可极大提高编译器设计与实现的效率</p>
<h5 id="41-前端"><a class="markdownIt-Anchor" href="#41-前端"></a> 4.1 前端</h5>
<p>主要是与源程序相关的部分，包括词法、语法分析、语义分析、中间代码生成等</p>
<h5 id="42-后端"><a class="markdownIt-Anchor" href="#42-后端"></a> 4.2 后端</h5>
<p>主要是与目标程序相关的部分，包括优化、目标代码生成等</p>
<h4 id="5-结语"><a class="markdownIt-Anchor" href="#5-结语"></a> 5. 结语</h4>
<p>词法分析基于有限状态自动机FA<br />
语法分析基于下推自动机PDA</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第六章</title>
    <url>/archives/e997863b.html</url>
    <content><![CDATA[<h1 id="编译原理第六章-词法分析"><a class="markdownIt-Anchor" href="#编译原理第六章-词法分析"></a> 编译原理第六章-词法分析</h1>
<p>词法分析：编译程序对源程序进行分析和目标程序合成，最终生成目标程序</p>
<p>预处理子程序（预处理器）功能：</p>
<ol>
<li>删除编辑用字符，如制表符、换页符等</li>
<li>删除注释</li>
<li>合并多个空白字符为单个空白字符</li>
<li>组合多个独立文件中的源程序</li>
<li>展开宏定义</li>
<li>条件编译的选择等</li>
</ol>
<span id="more"></span>
<blockquote>
<p>其中，2、3等也可以在词法分析的同时进行</p>
</blockquote>
<h2 id="1-词法分析概述"><a class="markdownIt-Anchor" href="#1-词法分析概述"></a> 1. 词法分析概述</h2>
<p>扫描源程序的字符串，按照词法规则，识别出单词符号作为输出；对识别过程发现的词法错误（非法的字符、不正确的常量、程序括号等）进行处理</p>
<p>词法分析器只执行一次：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429084145085.png" alt="image-20210429084145085" /></p>
<p>词法分析器执行多次：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429084219353.png" alt="image-20210429084219353" /></p>
<h2 id="2-词法分析器的输出形式"><a class="markdownIt-Anchor" href="#2-词法分析器的输出形式"></a> 2. 词法分析器的输出形式</h2>
<h3 id="21-单词的种类"><a class="markdownIt-Anchor" href="#21-单词的种类"></a> 2.1 单词的种类</h3>
<ol>
<li>标识符：用来命名程序中的实体，如类型、变量、函数、过程、标号等</li>
<li>基本字（关键字）：如if、while等</li>
<li>常量：各种类型的常量</li>
<li>运算符：如+、-、*、/等</li>
<li>（分）界符：如；、{、}等</li>
</ol>
<p>eg：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429084743808.png" alt="image-20210429084743808" /></p>
<blockquote>
<p>留意最后的换行符‘\n’也是界符</p>
</blockquote>
<h3 id="22-单词的输出形式"><a class="markdownIt-Anchor" href="#22-单词的输出形式"></a> 2.2 单词的输出形式</h3>
<p>使用二元式表示：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429084945101.png" alt="image-20210429084945101" /></p>
<h2 id="3-单词类别的划分"><a class="markdownIt-Anchor" href="#3-单词类别的划分"></a> 3. 单词类别的划分</h2>
<h3 id="31-单词的编码随类别不同而不同"><a class="markdownIt-Anchor" href="#31-单词的编码随类别不同而不同"></a> 3.1 单词的编码随类别不同而不同</h3>
<ol>
<li><strong>基本字、运算符、界符</strong>的数目是确定的，每个单词与它的类别码为一一对应的关系，即<strong>一字一码</strong>，故而它们的第二元可以空缺</li>
<li><strong>标识符</strong>通归一类</li>
<li><strong>常量</strong>可按整型、实型、字符型、布尔型等分类</li>
</ol>
<p>eg：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429085538808.png" alt="image-20210429085538808" /></p>
<blockquote>
<p>通常用常数在常量表（标识符在符号表）中的位置（编号）作为它们的属性值</p>
</blockquote>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429085737912.png" alt="image-20210429085737912" /></p>
<h3 id="32-单词的识别方法"><a class="markdownIt-Anchor" href="#32-单词的识别方法"></a> 3.2 单词的识别方法</h3>
<ol>
<li>
<p>标识符和关键字的识别</p>
<blockquote>
<p>需要<strong>超前搜索</strong>（多读一个字符以确认上一个结束）</p>
<p>读到 非 字母数字停止</p>
</blockquote>
</li>
<li>
<p>常数的识别</p>
<blockquote>
<p>部分常量需要超前搜索</p>
</blockquote>
</li>
<li>
<p>运算符的识别</p>
<blockquote>
<p>1个或多个符号构成</p>
<p>需要超前搜索</p>
</blockquote>
</li>
<li>
<p>界符的识别</p>
<blockquote>
<p>不需要超前搜索</p>
</blockquote>
</li>
</ol>
<h2 id="4-状态转换图"><a class="markdownIt-Anchor" href="#4-状态转换图"></a> 4. 状态转换图</h2>
<p>状态转换图是设计词法分析器的有效工具</p>
<p>状态图特点：</p>
<ol>
<li>有限的有向图</li>
<li>有向边上标记字符</li>
<li>唯一初态</li>
<li>若干终态（至少一个）</li>
</ol>
<p>图示：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429090825221.png" alt="image-20210429090825221" /></p>
<p>eg：</p>
<p>识别标识符和数字串的状态转换图：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429091210263.png" alt="image-20210429091210263" /></p>
<p>它的流程图：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429091340527.png" alt="image-20210429091340527" /></p>
<h2 id="5-词法分析器的设计"><a class="markdownIt-Anchor" href="#5-词法分析器的设计"></a> 5. 词法分析器的设计</h2>
<h3 id="51-单词符号"><a class="markdownIt-Anchor" href="#51-单词符号"></a> 5.1 单词符号</h3>
<p>标识符：begin、end、integer、if、then、else、function、read、write</p>
<p>无符号整型常量</p>
<p>运算符：-、*、&lt;、&lt;=、&lt;&gt;、=、&gt;、&gt;=、:=</p>
<p>分界符：；、（、）、</p>
<h3 id="52-状态转换图"><a class="markdownIt-Anchor" href="#52-状态转换图"></a> 5.2 状态转换图</h3>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429091724175.png" alt="image-20210429091724175" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210429091752010.png" alt="image-20210429091752010" /></p>
<blockquote>
<p>注意：有*标记的状态需要回退一个字符</p>
</blockquote>
<h3 id="53-一个示意算法"><a class="markdownIt-Anchor" href="#53-一个示意算法"></a> 5.3 一个示意算法</h3>
<p>以下是将会用到的变量、函数和过程</p>
<ol>
<li>
<p>cha</p>
<blockquote>
<p>字符变量，存放最新读入的字符</p>
</blockquote>
</li>
<li>
<p>token</p>
<blockquote>
<p>字符数组，存放已读入的字符序列</p>
</blockquote>
</li>
<li>
<p>getchar（）</p>
<blockquote>
<p>读入字符的过程，从输入字符串（源程序文件）中读入一个字符到变量cha中</p>
</blockquote>
</li>
<li>
<p>getnbc（）</p>
<blockquote>
<p>读入非空白字符的函数</p>
</blockquote>
</li>
<li>
<p>concat（）</p>
<blockquote>
<p>连接字符的过程，把cha中的字符连接到token数组的末尾</p>
</blockquote>
</li>
<li>
<p>letter（）</p>
<blockquote>
<p>判断字符是否为字母的函数，若cha中的字符是字母，返回true，否则返回false</p>
</blockquote>
</li>
<li>
<p>digit（）</p>
<blockquote>
<p>判断字符是否为数字的函数，同上</p>
</blockquote>
</li>
<li>
<p>retract（）</p>
<blockquote>
<p>回退字符的过程，将刚读入cha中的字符回退到输入字符串中，并将cha的值置为空白</p>
<p>实现方法：不需要真正回退，可以设置标记位。</p>
</blockquote>
</li>
<li>
<p>reserve（）</p>
<blockquote>
<p>处理保留字的函数，对存放在token中的字符串差保留字表，查到返回该保留字的类别编码，否则返回0（假定0不是任何单词符号的类别编码）</p>
</blockquote>
</li>
<li>
<p>bulidlist（）</p>
<blockquote>
<p>对token中的字符串查符号表，查到返回位置编号，否则将该串存入符号表，并返回它在符号表中的位置编号</p>
</blockquote>
</li>
<li>
<p>dtb（）</p>
<blockquote>
<p>将token中的数字串（字符串）转换成二进制，存入常数表中，并返回它在符号表中的位置编号。若已经存在，则直接返回它在表中的编号</p>
</blockquote>
</li>
<li>
<p>return（num，value）</p>
<blockquote>
<p>返回二元式函数，num为单词类别编码，value是单词在符号表中的位置编号，或是它在常数表中的位置编号，或是0</p>
</blockquote>
</li>
<li>
<p>error（）</p>
<blockquote>
<p>处理出现词法错误的过程。有一类词法错误可以在词法分析时发现，如出现字母表以外的非法字符。不和规则的常数等。但有一类词法错误例如if写成fi，词法分析会将fi当标识符处理，length中多了个空格，词法分析会将le和ngth当作两个标识符处理，这类错误要推迟到语法分析时才能发现，当作语法错误处理</p>
</blockquote>
</li>
</ol>
<p>伪代码：</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">Word_Struct LexAnalyze()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">   start:  token:=‘’ ;</span><br><span class="line">              getchar();</span><br><span class="line">              getnb();</span><br><span class="line">              <span class="keyword">case</span> cha <span class="keyword">of</span> </span><br><span class="line">                ‘a’…‘z’:  <span class="keyword">begin</span> </span><br><span class="line">                  <span class="keyword">while</span> letter() <span class="keyword">or</span> digit() <span class="keyword">do</span></span><br><span class="line">                     <span class="keyword">begin</span> concat ();getchar() <span class="keyword">end</span>;</span><br><span class="line">                     retract(); c:= reserve();</span><br><span class="line">                     <span class="keyword">if</span> c = <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                        val:= buildlist(); return($ID,val)    end</span><br><span class="line">                    <span class="keyword">else</span> return(c,<span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">end</span>;</span><br><span class="line">                ‘<span class="number">0</span>’…‘<span class="number">9</span>’:  <span class="keyword">begin</span></span><br><span class="line">                 <span class="keyword">while</span> digit() <span class="keyword">do</span></span><br><span class="line">                   <span class="keyword">begin</span> concat();getchar() <span class="keyword">end</span>;</span><br><span class="line">                 retract(); val:=dtb();</span><br><span class="line">                 return($INT,val)</span><br><span class="line">                 <span class="keyword">end</span>;</span><br><span class="line">                ‘ = ’:   return(<span class="number">$E</span>Q,<span class="number">0</span>);</span><br><span class="line">                ‘ - ’:    return($SUB,0); </span><br><span class="line">                ‘ * ’:   return($MUL,0);</span><br><span class="line">                ‘ ( ’:    return($LPAR,0);</span><br><span class="line">                ‘ ) ’:    return($RPAR,0);</span><br><span class="line">                ‘ ; ’:    return($SEM,0)</span><br><span class="line">                ‘ &lt; ’:   <span class="keyword">begin</span></span><br><span class="line">                  getchar();</span><br><span class="line">                  if cha = ‘=’ then return($LE, 0)</span><br><span class="line">                  <span class="keyword">else</span> </span><br><span class="line">                    if cha = ‘&gt;’ then return($NE, 0);</span><br><span class="line">                  retract();  return($LT,0)</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">                ‘ &gt; ’:   <span class="keyword">begin</span></span><br><span class="line">                  getchar();</span><br><span class="line">                  if cha= ‘ = ’ then return($GE, 0);</span><br><span class="line">                  retract();</span><br><span class="line">                  return($GT, 0)</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">                ‘ : ’:    <span class="keyword">begin</span></span><br><span class="line">                  getchar();</span><br><span class="line">                  <span class="keyword">if</span> cha = ‘ = ‘ <span class="keyword">then</span>   </span><br><span class="line">                      return(<span class="number">$A</span>SSIGN,<span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">else</span> error(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">                other: error(<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">of</span> <span class="keyword">case</span>;</span><br><span class="line"><span class="keyword">End</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码将词法分析器实现为一个函数LexAnalyze()，函数没执行一次，就会从输入字符串中识别出一个单词符号并按二元式形式返回。</p>
</blockquote>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第四章</title>
    <url>/archives/e30708a5.html</url>
    <content><![CDATA[<h3 id="编译原理第四章程序语言的设计"><a class="markdownIt-Anchor" href="#编译原理第四章程序语言的设计"></a> 编译原理第四章——程序语言的设计</h3>
<h4 id="1-程序设计语言的定义"><a class="markdownIt-Anchor" href="#1-程序设计语言的定义"></a> 1. （程序设计）语言的定义</h4>
<p>语言=语法（规则）+语义（规则）</p>
<p>语法：构造程序及其成分（单词、语法单位）的规则集合</p>
<p>语义：定义语言的单词符号和语法单位的作用和意义的规则组合</p>
<span id="more"></span>
<ul>
<li>
<p>可以从生成（文法）和识别（语法图）的角度描述语法</p>
<h5 id="11-文法描述语法规则生成角度"><a class="markdownIt-Anchor" href="#11-文法描述语法规则生成角度"></a> 1.1 文法描述语法规则：生成角度</h5>
<blockquote>
<p>&lt;标识符&gt;→&lt;字母&gt;<br />
&lt;标识符&gt;→&lt;标识符&gt;&lt;字母&gt;<br />
&lt;标识符&gt;→&lt;标识符&gt;&lt;数字&gt;<br />
&lt;字母&gt;→A|…|Z|a|…|z<br />
&lt;数字&gt;→0|…|9</p>
</blockquote>
<blockquote>
<p>&lt;表达式&gt;→&lt;标识符&gt;<br />
&lt;表达式&gt;→(&lt;表达式&gt;)<br />
&lt;表达式&gt;→&lt;表达式&gt;&lt;运算符&gt;&lt;表达式&gt;<br />
&lt;运算符&gt;→+|-|*|/</p>
<p><strong>注意：这里没有考虑运算符的优先级</strong></p>
</blockquote>
<h5 id="12-语法图描述语法规则识别角度"><a class="markdownIt-Anchor" href="#12-语法图描述语法规则识别角度"></a> 1.2  语法图描述语法规则：识别角度</h5>
<blockquote>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210413153851229.png" alt="image-20210413153851229" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210413153918317.png" alt="image-20210413153918317" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210413153937838.png" alt="image-20210413153937838" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210413154819595.png" alt="image-20210413154819595" /></p>
<h6 id="识别原则"><a class="markdownIt-Anchor" href="#识别原则"></a> 识别原则：</h6>
<ul>
<li>终结符框:标识的终结符与被识别的终结符刚好符合</li>
<li>非终结符框:由该非终结符的语法图识别</li>
<li>分支:若遇到分支，则任选一分支识别；</li>
<li>回溯:若一个分支识别不成功，则选另一分支识别</li>
<li>若一个终结符序列是合法的：<br />
那么,必须从语法图的入口边通过语法图而到达出口边，<br />
且在通过的过程中,恰恰能识别该终结符序列。</li>
<li>语言：语法图能识别的所有终结符序列的集合。称为语言。</li>
</ul>
<h6 id="语法图的构造"><a class="markdownIt-Anchor" href="#语法图的构造"></a> 语法图的构造</h6>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210413155020391.png" alt="image-20210413155020391" /></p>
</blockquote>
<h5 id="13-高级语言语法规则描述方法"><a class="markdownIt-Anchor" href="#13-高级语言语法规则描述方法"></a> 1.3 高级语言语法规则描述方法</h5>
<p>FORTRAN采用自然语言描述语法；<br />
ALGOL 60首次用BNF对语法进行形式描述,为语言定义做出了重要贡献；<br />
Pascal首次采用语法图来定义语言，给出了较为直观的语法结构。</p>
<h5 id="14-语法描述方法等价"><a class="markdownIt-Anchor" href="#14-语法描述方法等价"></a> 1.4 语法描述方法等价</h5>
<p>文法和语法图是语言语法的等价表示<br />
文法从产生的观点来定义语言的语法，通用性好。<br />
语法图以识别的观点定义语言的语法，更直观和清晰。</p>
<h5 id="15-语法的作用"><a class="markdownIt-Anchor" href="#15-语法的作用"></a> 1.5 语法的作用</h5>
<p>①表达语言设计者的意图和设计目标；<br />
②指导语言的使用者编写正确的程序；（先使用语义规则后使用语法规则）<br />
③指导语言的实现者识别所有语法单位。（先使用语法规则后使用语义规则）</p>
</li>
<li>
<p>本章语义使用自然语言描述、下篇语义以操作语义学的方法描述</p>
</li>
</ul>
<h4 id="2-文法"><a class="markdownIt-Anchor" href="#2-文法"></a> 2. 文法</h4>
<p>定义：文法是描述语言语法结构的形式规则</p>
<p>优点：通用、准确、易于理解、描述能力强</p>
<blockquote>
<p>文法G是一个四元式，G=（V<sub>T</sub> ，V<sub>N</sub> ，S ，P ）</p>
<p>V<sub>T</sub> 是有限字符的集合，元素称为字母或者<strong>终结符</strong></p>
<p>V<sub>N</sub> 是有限字符的集合，元素称为变量或<strong>非终结符</strong></p>
<p>S∈V，称为文法的开始符号</p>
<p>P是产生式α-&gt;β的集合</p>
</blockquote>
<blockquote>
<p>α∈(V<sub>T</sub> U V<sub>N</sub> )<sup>+</sup> ，至少包含一个非终结符，α∈V<sup>*</sup> V<sub>N</sub> V<sup>*</sup></p>
<p>β∈(V<sub>T</sub> U V<sub>N</sub> )<sup>*</sup></p>
<p>α-&gt;ε，称为空串产生式或者ε产生式</p>
</blockquote>
<h5 id="21-候选式"><a class="markdownIt-Anchor" href="#21-候选式"></a> 2.1 候选式</h5>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210420083948266.png" alt="image-20210420083948266" /></p>
<h5 id="22-文法的分类"><a class="markdownIt-Anchor" href="#22-文法的分类"></a> 2.2 文法的分类</h5>
<ol>
<li>
<p>0型文法（PSG）</p>
<p>α-&gt;β</p>
</li>
<li>
<p>1型文法（上下文有关文法CSG）</p>
<p>|α|&lt;=|β| （S-&gt;ε例外）</p>
<blockquote>
<p>标准形式：</p>
<p>yAz-&gt;yωz</p>
<p>其中：</p>
<p>A∈V<sub>N</sub> ;</p>
<p>y,z∈(V<sub>T</sub> U V<sub>N</sub> )<sup>*</sup> ;</p>
<p>ω∈(V<sub>T</sub> U V<sub>N</sub> )<sup>+</sup> ;</p>
<p>（S-&gt;ε例外）</p>
</blockquote>
</li>
<li>
<p>2型文法（上下文无关文法CFG）</p>
<p>A-&gt;β</p>
</li>
<li>
<p>3型文法（正则文法RG，或右线性文法RLG）</p>
<p>A-&gt;u或A-&gt;wB</p>
<p>其中u∈V<sub>T</sub> <sup>*</sup> ，w∈V<sub>T</sub> <sup>+</sup></p>
</li>
</ol>
<h4 id="3-文法产生的语言"><a class="markdownIt-Anchor" href="#3-文法产生的语言"></a> 3. 文法产生的语言</h4>
<h5 id="31-推导与归约"><a class="markdownIt-Anchor" href="#31-推导与归约"></a> 3.1 推导与归约</h5>
<ol>
<li>
<p>直接推导</p>
<p>wαv=&gt;wβv，即由产生式右边替换产生式左边</p>
</li>
<li>
<p>任意步推导</p>
<p>y=&gt;<sup>*</sup> z</p>
</li>
<li>
<p>多步推导</p>
<p>y=&gt;<sup>+</sup> z</p>
</li>
</ol>
<blockquote>
<p>eg：已知文法G（E）</p>
<p>E-&gt;E+E|E*E|(E)|i</p>
<ol>
<li>
<p>i+i*i的（其中一种）最左推导过程</p>
<p>E=&gt;E+E=&gt;i+E=&gt;i+E*E=&gt;i+i*E=&gt;i+i*i</p>
<p>E=&gt;E*E=&gt;E+E*E=&gt;i+E*E=&gt;i+i*E=&gt;i+i*i</p>
</li>
<li>
<p>i+i*i的最右推导（规范推导）</p>
<p>E=&gt;E+E=&gt;E+E*E=&gt;E+E*i=&gt;E+i*i=&gt;i+i*i</p>
<p>E=&gt;E*E=&gt;E*i=&gt;E+E*i=&gt;E+i*i=&gt;i+i*i</p>
</li>
</ol>
</blockquote>
<h5 id="32-句型和句子"><a class="markdownIt-Anchor" href="#32-句型和句子"></a> 3.2 句型和句子</h5>
<blockquote>
<p>文法G=（V<sub>T</sub> ,V<sub>N</sub> ,S,P）</p>
<p>S=&gt;<sup>*</sup> w</p>
<p>若w∈V<sup>*</sup> ，则w为文法G的一个句型</p>
<p>若w∈V<sub>T</sub> <sup>*</sup> ，则w是一个句子（只含终结符的句型就是一个句子）</p>
</blockquote>
<blockquote>
<p>所有句子的集合称为文法G产生的语言记为L（G）</p>
<p>即L（G）={α|S=&gt;<sup>+</sup> α且α∈V<sub>T</sub> <sup>*</sup> }</p>
</blockquote>
<h5 id="33-文法的重要特性"><a class="markdownIt-Anchor" href="#33-文法的重要特性"></a> 3.3 文法的重要特性</h5>
<p>有限规则描述无穷语言</p>
<h5 id="34-文法等价"><a class="markdownIt-Anchor" href="#34-文法等价"></a> 3.4 文法等价</h5>
<p>两个文法G和G<sup>’</sup> ，如果有L（G）=L（G<sup>’</sup> ），则称G和G<sup>’</sup> 等价</p>
<h4 id="4-推导树语法树"><a class="markdownIt-Anchor" href="#4-推导树语法树"></a> 4. 推导树（语法树）</h4>
<p>定义：推导树是一颗有序的标记树，每个结点的标记是文法G的非终结符或终结符或空串ε。其中标记为A的内部结点从左到右有子结点x1、x2、……xn，则A-&gt;x1……xn是一个产生式。</p>
<h5 id="41-推导树的边缘"><a class="markdownIt-Anchor" href="#41-推导树的边缘"></a> 4.1 推导树的边缘</h5>
<p>定义：推导树所有叶节点<strong>从左到右</strong>的连接</p>
<h5 id="42-文法的二义性"><a class="markdownIt-Anchor" href="#42-文法的二义性"></a> 4.2 文法的二义性</h5>
<p>定义：一个句子有两颗不同的推导树</p>
<h5 id="43-短语-直接短语-句柄"><a class="markdownIt-Anchor" href="#43-短语-直接短语-句柄"></a> 4.3 短语、直接短语、句柄</h5>
<p>详见第八章</p>
<h4 id="5-语言的设计"><a class="markdownIt-Anchor" href="#5-语言的设计"></a> 5. 语言的设计</h4>
<p>eg：</p>
<p>表达式的设计：</p>
<ol>
<li>逻辑表达式</li>
<li>关系表达式</li>
<li>算术表达式</li>
</ol>
<blockquote>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210426173640256.png" alt="image-20210426173640256" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210426173737710.png" alt="image-20210426173737710" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210426173753654.png" alt="image-20210426173753654" /></p>
</blockquote>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第四章前导</title>
    <url>/archives/5f3d4781.html</url>
    <content><![CDATA[<h3 id="编译原理第零章形式语言与自动机"><a class="markdownIt-Anchor" href="#编译原理第零章形式语言与自动机"></a> 编译原理第零章——形式语言与自动机</h3>
<h4 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h4>
<p>字母表有非空性、有穷性、单一性</p>
<blockquote>
<p>Σ代表字母表<br />
ε代表空串<br />
{ε}代表仅含有空串的集合<br />
Φ代表空集<br />
αβ代表两个字符串α与β的连接（并置）<br />
α<sup>n</sup> 代表α的n次连接，其中α<sup>0</sup> =ε，α<sup>n</sup> =α<sup>n-1</sup> α  其中n&gt;0<br />
AB代表集合A与B的连接，A={a1,a2,a3,…,an}，B={b1,b2,b3,…,bm}</p>
<span id="more"></span>
<blockquote>
<p>则AB=<br />
{ a1b1，a1b2，a1b3，…，a1bm，<br />
a2b1，a2b2，a2b3，…，a2bm，<br />
a3b1，a3b2，a3b3，…，a3bm，<br />
…<br />
anb1，anb2，anb3，…，anbm }</p>
<p>注意：AФ=ФA=Ф，A{ε}={ε}A=A</p>
</blockquote>
<p>A<sup>n</sup> 代表集合A的n次连接（n次幂），A<sup>0</sup> = {ε}，A<sup>n</sup> = A<sup>n-1</sup>A    n ≥ 1<br />
A<sup>*</sup> 代表A上所有字符串的集合，称作集合A的克林闭包<br />
A<sup>*</sup> = A<sup>0</sup> ∪ A<sup>1</sup> ∪ A<sup>2</sup> ∪  …∪ A<sup>n</sup><br />
A<sup>+</sup> 称为A的正闭包<br />
A<sup>+</sup>=A<sup>1</sup>∪A<sup>2</sup>∪A<sup>3</sup>∪…∪A<sup>n</sup></p>
</blockquote>
<p>定义：</p>
<p>给定字母表∑，则∑*的任意子集L称为字母表∑上的一个语言。</p>
<p>设∑是一个字母表，∀L ⊆ ∑*, ∀x ∈ L, x称为L的一个句子。</p>
<blockquote>
<p>eg：Σ＝{0，1}，请给出语言的形式表示</p>
<ol>
<li>所有以0开头，以1结尾的串的语言。</li>
<li>所有以11开头，11结尾的串的语言。</li>
<li>所有长度为偶数的串的语言。</li>
<li>所有长度为奇数的串的语言。</li>
<li>所有包含子串01011的串的语言。</li>
<li>所有的第10个字符是0的串的语言。</li>
</ol>
<p>answer：</p>
<ol>
<li>{0} {0,1}<sup>*</sup> {1}</li>
<li>{11} {0,1}<sup>*</sup> {11} ∪ {11,111}</li>
<li>{00,01,10,11}<sup>*</sup></li>
<li>{00,01,10,11}<sup>*</sup> {0,1}</li>
<li>{0,1}<sup>*</sup> {011011} {0,1}<sup>*</sup></li>
<li>{0,1}<sup>9</sup> {0} {0,1}<sup>*</sup></li>
</ol>
</blockquote>
<h4 id="形式语言与自动机理论简介"><a class="markdownIt-Anchor" href="#形式语言与自动机理论简介"></a> 形式语言与自动机理论简介</h4>
<h5 id="初步认识"><a class="markdownIt-Anchor" href="#初步认识"></a> 初步认识</h5>
<p>语言的定义可以从两个方面进行：</p>
<ol>
<li>从产生语言的角度</li>
<li>从接收（识别）语言的角度</li>
</ol>
<ul>
<li>
<p>产生语言</p>
<p>根据语言中的基本句子和其他句子的形成规则，得到（产生）该语言所包含的所有句子</p>
<p>属于<strong>形式语言</strong>所研究的问题</p>
</li>
<li>
<p>接收语言</p>
<p>使用自动机模型来接收字符串，接收的所有字符串，也形成一个语言</p>
<p>属于<strong>自动机</strong>所研究的问题</p>
</li>
</ul>
<h5 id="统一的理论"><a class="markdownIt-Anchor" href="#统一的理论"></a> 统一的理论</h5>
<p>形式语言与自动机作为统一的理论，实际上包括3个方面的内容：</p>
<ol>
<li>形式语言理论（产生语言）</li>
<li>自动机理论（接收语言）</li>
<li>形式语言与自动机的等价性理论</li>
</ol>
<h5 id="括号匹配串的语言"><a class="markdownIt-Anchor" href="#括号匹配串的语言"></a> 括号匹配串的语言</h5>
<p><strong>自然语言描述：</strong></p>
<blockquote>
<ol>
<li>
<p>（）是该语言的最基本的句子</p>
</li>
<li>
<p>若S是句子，则（S）是句子</p>
</li>
<li>
<p>若S是句子，则SS是句子</p>
</li>
</ol>
</blockquote>
<p>根据以上形成规则，我们可以：</p>
<ol>
<li>产生该语言的任意的句子</li>
<li>判断某个串是否是该语言的句子——<strong>语法分析</strong></li>
</ol>
<p><strong>巴克斯-诺尔范式（BNF）描述：</strong></p>
<blockquote>
<ol>
<li>
<p>&lt;括号匹配串&gt;::=()</p>
</li>
<li>
<p>&lt;括号匹配串&gt;::=(&lt;括号匹配串&gt;)</p>
</li>
<li>
<p>&lt;括号匹配串&gt;::=&lt;括号匹配串&gt;&lt;括号匹配串&gt;</p>
</li>
</ol>
</blockquote>
<p><strong>Chomsky描述：</strong></p>
<blockquote>
<ol>
<li>
<p>S-&gt;()</p>
</li>
<li>
<p>S-&gt;(S)</p>
</li>
<li>
<p>S-&gt;SS</p>
</li>
</ol>
<p><strong>注：为方便起见，箭头打成-&gt;</strong></p>
</blockquote>
<p>术语：</p>
<blockquote>
<ol>
<li>S称为非终结符，是在推导中可以被替代的符号。</li>
<li>（）称为终结符，是在推导中不可以被替代的符号</li>
<li>-&gt;是产生式系统的元符号</li>
</ol>
</blockquote>
<p>结论：</p>
<p>一个语言，可以使用不同的产生式组合来产生。</p>
<p>注意：</p>
<p>D-&gt;0|1|2|3|4|5|6|7|8|9<strong>不能</strong>简写为D-&gt;0|…|9</p>
<p>eg：算术表达式的形成规则</p>
<blockquote>
<p>E-&gt;E+T|E-T|T<br />
T-&gt;T*F|T/F|F<br />
F-&gt;(E)|I<br />
I-&gt;L|IL|ID<br />
L-&gt;a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z<br />
D-&gt;0|1|2|3|4|5|6|7|8|9</p>
</blockquote>
<p>注意：其中E代表表达式，T代表项，F代表因子，先因子再乘除最后加减</p>
<p>注：这是算术表达式，不包含关系表达式的定义（&lt;、&lt;=、&gt;、&gt;=、&lt; &gt;、=），并且标识符没有考虑下划线和大写字母</p>
<h4 id="文法"><a class="markdownIt-Anchor" href="#文法"></a> 文法</h4>
<p>定义：</p>
<blockquote>
<p>文法G是一个四元式，G=（V<sub>T</sub> ，V<sub>N</sub> ，S ，P ）</p>
<p>V<sub>T</sub> 是有限字符的集合，元素称为字母或者<strong>终结符</strong></p>
<p>V<sub>N</sub> 是有限字符的集合，元素称为变量或<strong>非终结符</strong></p>
<p>S∈V，称为文法的开始符号</p>
<p>P是产生式α-&gt;β的集合</p>
<blockquote>
<p>α∈(V<sub>T</sub> U V<sub>N</sub> )<sup>+</sup> ，至少包含一个非终结符</p>
<p>β∈(V<sub>T</sub> U V<sub>N</sub> )<sup>*</sup></p>
<p>α-&gt;ε，称为空串产生式或者ε产生式</p>
</blockquote>
</blockquote>
<h5 id="推导派生"><a class="markdownIt-Anchor" href="#推导派生"></a> 推导（派生）</h5>
<p>定义：文法G，α和β是集合(V<sub>T</sub> ∪V<sub>N</sub> )上的串，α= pvr ，β=pur(p和r可能同时为ε)，而v→u是的一个产生式，则称α直接推导出β，记为α=&gt;β ，即pvr =&gt;pur。</p>
<p>术语：</p>
<blockquote>
<p>y=&gt;<sup>+</sup> z 多步推导<br />
y=&gt;<sup>*</sup> z 任意步推导（多了y=z的情况）</p>
<p>S=&gt;<sup>*</sup> ω 则ω是文法的一个句型<br />
进一步若ω∈V<sub>T</sub> <sup>*</sup> ，ω称为句子</p>
<p>L(G) ={ω|S=&gt;<sup>+</sup> ω，且ω∈V<sub>T</sub>*} ，则L（G）称为文法G产生的语言</p>
<blockquote>
<p>一个语言<strong>可以</strong>由多个不同的文法产生<br />
一个文法<strong>只能</strong>产生一个语言</p>
</blockquote>
</blockquote>
<p>eg：</p>
<blockquote>
<p>产生语言L（G）= { a<sup>n</sup> b<sup>n</sup> c<sup>n</sup> |n&gt;0} 文法</p>
<blockquote>
<p>解一：</p>
<p>S→aSBC        ①<br />
S→aBC          ②<br />
CB→BC         ③<br />
aB→ab          ④<br />
bB→bb          ⑤<br />
bC→bc          ⑥<br />
cC→cc           ⑦</p>
<p>解二：</p>
<p>S→abc|aSBc<br />
cB→Bc<br />
aB→ab<br />
bB→bb</p>
<p><strong>类似思想还可以写出很多文法</strong></p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
</search>
