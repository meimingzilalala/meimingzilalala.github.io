<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo+github/aliyun搭建静态博客</title>
    <url>/archives/15b1edd7.html</url>
    <content><![CDATA[<h2 id="下载nodejs和cnpm"><a class="markdownIt-Anchor" href="#下载nodejs和cnpm"></a> 下载nodejs和cnpm</h2>
<p>直接在<a href="https://nodejs.org/zh-cn/">nodejs官网</a>进行下载并安装<br />
<code>node -v</code>命令查看node的版本<br />
<code>npm -v</code>命令查看npm的版本<br />
然后利用npm安装淘宝的cnpm，下载速度快一些<br />
<code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code>命令安装淘宝的cnpm包管理器<br />
<code>cnpm -v</code>命令查看cnpm的版本</p>
<span id="more"></span>
<hr />
<h2 id="下载hexo并创建本地的静态博客"><a class="markdownIt-Anchor" href="#下载hexo并创建本地的静态博客"></a> 下载hexo并创建本地的静态博客</h2>
<p><code>cnpm install -g hexo-cli</code>安装hexo<br />
<code>hexo -v</code>查看hexo版本<br />
然后创建一个你存博客的目录并进入到该目录，你可能会用到<code>mkdir blog</code>,<code>cd blog</code><br />
<code>hexo init</code>在当前目录下生成博客的框架<br />
你可以使用<code>hexo s</code>开启博客，进入<code>http://localhost:4000/</code>查看本地博客内容<br />
<code>hexo n &quot;文章名&quot;</code>创建新的文章<br />
然后找到<code>\source\_post</code>目录下编辑文章即可，使用markdown语法</p>
<hr />
<h2 id="部署到github上"><a class="markdownIt-Anchor" href="#部署到github上"></a> 部署到GitHub上</h2>
<p>首先在你的GitHub上新建一个仓库，命名为<code>YourGithubName.github.io</code><br />
然后<code>cnpm install --save hexo-deployer-git</code>在blog目录下安装git部署插件<br />
下面配置_config.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line"> 		<span class="built_in">type</span>: git</span><br><span class="line">		repo: https://github.com/YourGithubName/YourGithubName.github.io.git</span><br><span class="line"> 		branch: master</span><br></pre></td></tr></table></figure>
<p>最后运行以下三条命令：<br />
<code>hexo clean</code>清理<br />
<code>hexo g</code>生成<br />
<code>hexo d</code>部署<br />
以上三条命令基本是每次修改博客后都要运行的<br />
最后在<code>https://YourGithubName.github.io</code>下就可以查看啦！</p>
<hr />
<h2 id="主题的更换"><a class="markdownIt-Anchor" href="#主题的更换"></a> 主题的更换</h2>
<p>更改主题一般分两步：<br />
1、<code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code>利用git将别人仓库里的主题克隆到自己的blog下的themes文件夹里<br />
2、修改blog目录下的 _config.yml 文件中的  theme改为theme: yilia<br />
<strong>注意：这里的GitHub地址是示例，虽然这个大佬写的也挺好看的；themes下的文件夹名要和theme冒号后面的名称一样</strong><br />
更改完成，运行上面的三条命令就可以看到变化啦（比较慢，多等一会，用本地查看会快一些）</p>
<hr />
<h2 id="一些个性化的定制"><a class="markdownIt-Anchor" href="#一些个性化的定制"></a> 一些个性化的定制</h2>
<h3 id="看板娘的添加"><a class="markdownIt-Anchor" href="#看板娘的添加"></a> 看板娘的添加</h3>
<p>明天再更</p>
<h3 id="网址小图标的添加"><a class="markdownIt-Anchor" href="#网址小图标的添加"></a> 网址小图标的添加</h3>
<p>内容</p>
<h3 id="主题里一些内容的简单定制"><a class="markdownIt-Anchor" href="#主题里一些内容的简单定制"></a> 主题里一些内容的简单定制</h3>
<p>内容</p>
<hr />
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<p>1、<a href="https://www.bilibili.com/video/BV1Yb411a7ty">b站大佬视频讲解</a></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>自学</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒-基础-代码初始</title>
    <url>/archives/b087ef83.html</url>
    <content><![CDATA[<h3 id="病毒基础-代码初始"><a class="markdownIt-Anchor" href="#病毒基础-代码初始"></a> 病毒基础-代码初始</h3>
<h4 id="1-代码初识"><a class="markdownIt-Anchor" href="#1-代码初识"></a> 1. 代码初识</h4>
<p>我们需要掌握的工具</p>
<ol>
<li>vc反汇编调试</li>
<li>文本编辑工具UltraEdit（UE）</li>
<li>ollydebug调试（od）</li>
<li>静态反汇编工具ida</li>
<li>汇编代码撰写工具nasm</li>
</ol>
<span id="more"></span>
<h4 id="2-大端机和小端机"><a class="markdownIt-Anchor" href="#2-大端机和小端机"></a> 2. 大端机和小端机</h4>
<p>小端机：高位地址存放高位数据、低位地址存放低位数据。例如Intel的X86系列CPU<br />
小端机：高位地址存放低位数据、低位地址存放高位数据。例如PowerPC、Sun的SPARC、Motorola 6800</p>
<h4 id="3-jmp指令解析"><a class="markdownIt-Anchor" href="#3-jmp指令解析"></a> 3. JMP指令解析</h4>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E5%88%9D%E5%A7%8B/image-20210425160344966.png" alt="image-20210425160344966" /></p>
<p>Jmp 无条件跳转指令，有以下四种用法：</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E5%88%9D%E5%A7%8B/image-20210425160536816.png" alt="image-20210425160536816" /></p>
<p>注意：在上述PPT中使用了Jmp offset的方式，其中地址2的地址是地址1的地址加上5个字节</p>
<p><strong>使用反汇编修改内存和使用工具修改硬盘文件步骤一样，工具不同，本质相同</strong></p>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第一章</title>
    <url>/archives/29225e4a.html</url>
    <content><![CDATA[<h3 id="编译原理第一章"><a class="markdownIt-Anchor" href="#编译原理第一章"></a> 编译原理第一章</h3>
<ol>
<li>
<p>语言的本质<br />
一组规则的组合</p>
<ol>
<li>字母表的定义</li>
<li>词法规则</li>
<li>语法规则</li>
<li>语义规则</li>
<li>语用规则</li>
</ol>
<span id="more"></span>
</li>
<li>
<p>与编译有关的三种语言和三种程序</p>
<table>
<thead>
<tr>
<th>源语言</th>
<th>工具语言</th>
<th>目标语言</th>
</tr>
</thead>
<tbody>
<tr>
<td>源程序</td>
<td>编译程序</td>
<td>目标程序</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>程序设计语言的分类</p>
<table>
<thead>
<tr>
<th>强制式语言</th>
<th>函数式语言</th>
<th>逻辑式语言</th>
<th>对象式语言</th>
</tr>
</thead>
<tbody>
<tr>
<td>冯·诺依曼模型</td>
<td>数学函数（函数运算）</td>
<td>数理逻辑、谓词演算</td>
<td>抽象数据类型</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>冯·诺依曼体系结构</p>
<ol>
<li>构成基础<br />
存储器、控制器、处理器、ip</li>
<li>特点
<ul>
<li>数据、指令以二进制形式存储</li>
<li>存储程序的工作方式</li>
<li>程序顺序执行，可强制修改执行顺序</li>
<li>存储器内容可以被修改</li>
</ul>
</li>
</ol>
</li>
<li>
<p>变量的4个属性</p>
<ol>
<li>
<p>作用域</p>
<blockquote>
<ul>
<li>静态绑定：依据变量定义的位置</li>
<li>动态绑定：依据过程的调用关系</li>
</ul>
</blockquote>
<ul>
<li>全局变量</li>
<li>局部变量</li>
<li>非局部变量</li>
</ul>
</li>
<li>
<p>生存期</p>
<blockquote>
<ul>
<li>全局变量静态分配</li>
<li>局部变量运行前静态分配，运行时动态分配</li>
<li>非局部变量可静态分配可动态分配</li>
<li>匿名变量是通过指针访问，是动态分配</li>
</ul>
</blockquote>
</li>
<li>
<p>值</p>
<blockquote>
<ul>
<li>二进制编码</li>
<li>按类型解释</li>
<li>变量与值的绑定是动态的</li>
<li>常量的值不能修改</li>
<li>数据对象表示存储区和它保存的值</li>
</ul>
</blockquote>
</li>
<li>
<p>类型</p>
<blockquote>
<p>静态绑定语言是面向编译的语言<br />
动态绑定语言是面向解释的语言</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>虚拟机<br />
M1是实际的机器<br />
机器语言是汇编语言的M2=M1+汇编程序<br />
机器语言是高级语言的M3=M2+编译程序</p>
</li>
<li>
<p>程序单元</p>
<ol>
<li>
<p>定义：程序执行过程中被独立调用单元，包括子程序、分程序、过程等</p>
</li>
<li>
<p>表示：</p>
<blockquote>
<ul>
<li>
<p>编译时：单元的源程序</p>
</li>
<li>
<p>运行时：一个代码段和一个活动记录组成，称为单元实例</p>
</li>
<li>
<blockquote>
<p>活动记录：执行单元需要的信息和局部变量等数据存储区</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li>
<p>实例：</p>
<blockquote>
<ul>
<li>非局部变量：一个程序单元可以引用未被本单元说明而被其它单元说明的变量</li>
<li>全局变量：一个程序中各个程序单元都可以引用的变量</li>
</ul>
</blockquote>
</li>
</ol>
</li>
<li>
<p>C程序运行时的存储空间</p>
<ol>
<li>
<p>程序代码区：存储程序代码（编译后形成的二进制机器指令序列）</p>
</li>
<li>
<p>数据静态存储区：存储程序的<strong>常量数据、全局数据、static数据</strong></p>
</li>
<li>
<p>数据动态存储区：</p>
<blockquote>
<p>栈：存储返回地址、CPU现场、临时变量、<strong>形参、局部变量</strong><br />
堆：存储动态内存申请数据</p>
</blockquote>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒_概述</title>
    <url>/archives/c513bfe.html</url>
    <content><![CDATA[<h3 id="病毒概述"><a class="markdownIt-Anchor" href="#病毒概述"></a> 病毒概述</h3>
<h4 id="你能学到什么"><a class="markdownIt-Anchor" href="#你能学到什么"></a> 你能学到什么？</h4>
<ol>
<li>代码解密</li>
<li>文件系统和硬盘数据结构</li>
<li>DOS下的病毒技术：文件型病毒，引导型病毒，中断型病毒</li>
<li>Windows下的病毒：PE病毒，导入表，导出表，病毒的入口点模糊技术</li>
</ol>
<h4 id="先决课程"><a class="markdownIt-Anchor" href="#先决课程"></a> 先决课程</h4>
<ol>
<li>汇编语言</li>
<li>计算机组成原理</li>
</ol>
<span id="more"></span>
<h4 id="11-病毒定义"><a class="markdownIt-Anchor" href="#11-病毒定义"></a> 1.1 病毒定义</h4>
<p>计算机病毒：病毒特征+程序代码</p>
<h4 id="12-病毒的本质与特征"><a class="markdownIt-Anchor" href="#12-病毒的本质与特征"></a> 1.2 病毒的本质与特征</h4>
<p><strong>病毒的固有本质属性：人为的特制程序</strong><br />
程序性和客观性决定了病毒的可防治性和可清除性<br />
人为性和主观性导致了病毒各异多变</p>
<h5 id="基本特征传染性"><a class="markdownIt-Anchor" href="#基本特征传染性"></a> 基本特征：传染性</h5>
<p>传染性是指计算机病毒把自身复制到其他程序的能力<br />
即将自身的代码<strong>强行</strong>传染到<strong>一切符合其传染条件</strong>的程序之上<br />
是否具有传染性是判别一个程序是否为计算机病毒的<strong>首要条件</strong></p>
<h5 id="基本特征隐蔽性"><a class="markdownIt-Anchor" href="#基本特征隐蔽性"></a> 基本特征：隐蔽性</h5>
<p>传染过程的隐蔽性<br />
病毒存在的隐蔽性</p>
<h5 id="基本特征可触发性"><a class="markdownIt-Anchor" href="#基本特征可触发性"></a> 基本特征：可触发性</h5>
<p>可触发性是指因某个事件或数值的出现，触发病毒实施感染或攻击破坏<br />
即隐藏又保持破坏力</p>
<h5 id="其他基本特征"><a class="markdownIt-Anchor" href="#其他基本特征"></a> 其他基本特征</h5>
<ol>
<li>欺骗性</li>
<li>非授权性</li>
<li>寄生性</li>
<li>衍生性</li>
<li>持久性</li>
<li>破坏性</li>
<li>针对性</li>
<li>不可预见性</li>
</ol>
<h4 id="13-病毒的分类"><a class="markdownIt-Anchor" href="#13-病毒的分类"></a> 1.3 病毒的分类</h4>
<ol>
<li>
<p>根据病毒表现行为分类</p>
<p><img src="/images/%E7%97%85%E6%AF%92-%E6%A6%82%E8%BF%B0/image-20210422205247089.png" alt="image-20210422205247089" /></p>
</li>
<li>
<p>根据病毒的内部机理分类<br />
<img src="/images/%E7%97%85%E6%AF%92-%E6%A6%82%E8%BF%B0/image-20210422205355394.png" alt="image-20210422205355394" /></p>
</li>
</ol>
<h4 id="14-恶意程序-蠕虫-木马"><a class="markdownIt-Anchor" href="#14-恶意程序-蠕虫-木马"></a> 1.4 恶意程序 蠕虫 木马</h4>
<p>恶意程序：未经授权便干扰或破坏计算机系统/网络的程序或代码，早期恶意代码的主要形式是计算机病毒<br />
蠕虫：独立的可执行程序，不需要寄生在宿主程序中，通过网络分发自己的副本<br />
病毒和蠕虫的区别：<br />
<img src="/images/%E7%97%85%E6%AF%92-%E6%A6%82%E8%BF%B0/image-20210422205811795.png" alt="image-20210422205811795" /><br />
特洛伊木马：在远程计算机之间建立连接，使得远程计算机能通过网络控制本地计算机的非法程序</p>
<h4 id="15-病毒的命名规则"><a class="markdownIt-Anchor" href="#15-病毒的命名规则"></a> 1.5 病毒的命名规则</h4>
<p>一些普通命名规则</p>
<ol>
<li>按病毒的发作时间命名</li>
<li>按病毒的发作症状命名</li>
<li>按病毒的发现地命名</li>
<li>按病毒的字节长度命名</li>
</ol>
<p>国际命名惯例<br />
前缀（病毒的种类）+病毒名（病毒家族的特征）+后缀（区分病毒变种）</p>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第三章</title>
    <url>/archives/542a11c0.html</url>
    <content><![CDATA[<h3 id="编译原理第三章-控制结构"><a class="markdownIt-Anchor" href="#编译原理第三章-控制结构"></a> 编译原理第三章-控制结构</h3>
<p>定义：规定程序语句和程序单元的执行流程</p>
<p>分类：语句级控制结构、单元级控制结构</p>
<h4 id="语句级控制结构"><a class="markdownIt-Anchor" href="#语句级控制结构"></a> 语句级控制结构</h4>
<p>定义：用来构造语句执行流程的机制</p>
<p>分类：顺序、选择（分支）、重复（循环）</p>
<span id="more"></span>
<ol>
<li>
<p>顺序</p>
<blockquote>
<p>语句结束标记 ；</p>
<p>复合语句：begin……end、{……}</p>
</blockquote>
</li>
<li>
<p>选择</p>
<blockquote>
<p>单选if then</p>
<p>二选一if then else</p>
<p>多选一 嵌套if then else</p>
</blockquote>
</li>
<li>
<p>重复</p>
<blockquote>
<p>计数器制导</p>
<p>条件制导</p>
</blockquote>
</li>
</ol>
<h4 id="单元级控制结构"><a class="markdownIt-Anchor" href="#单元级控制结构"></a> 单元级控制结构</h4>
<p>定义：规定程序单元之间控制流程的机制</p>
<h5 id="显式调用从属单元"><a class="markdownIt-Anchor" href="#显式调用从属单元"></a> 显式调用从属单元</h5>
<blockquote>
<p>eg：</p>
<p>FORTRAN语言的子程序和函数</p>
<p>PASCAL语言的函数和过程</p>
<p>C语言的函数</p>
</blockquote>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20210413150345535.png" alt="image-20210413150345535" /></p>
<h5 id="隐式调用单元异常处理"><a class="markdownIt-Anchor" href="#隐式调用单元异常处理"></a> 隐式调用单元——异常处理</h5>
<p>异常定义：导致程序正常执行中止的事件</p>
<p>异常处理的主要问题：</p>
<blockquote>
<ol>
<li>异常如何说明，它的作用域是什么？</li>
<li>异常如何发生？（如何捕获异常）</li>
<li>发生异常时，流程如何转移？</li>
<li>发生异常时，如何绑定相应的异常处理程序？</li>
<li>处理异常之后，控制流程转向何处？</li>
</ol>
</blockquote>
<blockquote>
<p>问题（5）的解决方法：</p>
<ol>
<li>
<p>允许控制返回发生异常事件的执行点</p>
<p>这种情况下，异常处理程序可对执行的程序进行“修补”，终止相应的异常事件，以便程序继续正常地执行。</p>
<p>解决了程序继续执行的问题，但并未真正消除发生异常的因素。</p>
</li>
<li>
<p>由异常处理程序进行控制的转移</p>
<p>意味着引起异常的单元不能恢复执行；从实现的观点来看，这意味着删除异常单元的活动记录。</p>
</li>
</ol>
</blockquote>
<p>C++语言的异常处理：</p>
<blockquote>
<p>设置陷阱 try</p>
<p>抛出异常 throw</p>
<p>捕获异常 catch</p>
<p>C++的异常处理语句的格式如下：<br />
try  {  … }<br />
catch (异常类型1) { 异常1处理程序 }<br />
catch (异常类型2) {异常2处理程序}<br />
……<br />
catch (异常类型n) {异常n处理程序}</p>
</blockquote>
<p>协同程序间的控制转移关系：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20210413151632600.png" alt="image-20210413151632600" /></p>
<h4 id="并发单元"><a class="markdownIt-Anchor" href="#并发单元"></a> 并发单元</h4>
<p>eg：“生产者-消费者”问题</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20210413151822744.png" alt="image-20210413151822744" /></p>
<h5 id="并行与并发的区别"><a class="markdownIt-Anchor" href="#并行与并发的区别"></a> 并行与并发的区别</h5>
<blockquote>
<p>并行”是指无论从微观还是宏观，二者都是一起执行的，就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。<br />
而“并发”在微观上不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行，从宏观外来看，好像是这些进程都在执行，这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。<br />
从以上本质不难看出，“并发”执行，在多个进程存在资源冲突时，并没有从根本提高执行效率。</p>
</blockquote>
<h5 id="同步问题"><a class="markdownIt-Anchor" href="#同步问题"></a> 同步问题</h5>
<blockquote>
<p>正确访问存储区</p>
<ul>
<li>不会向已满的缓冲区写数据</li>
<li>不会向空缓冲区读数据</li>
</ul>
</blockquote>
<h5 id="动作的不可分"><a class="markdownIt-Anchor" href="#动作的不可分"></a> 动作的“不可分”</h5>
<blockquote>
<p>append是生产者向缓冲区存数的操作</p>
<p>remove是消费者从缓冲区取数的操作</p>
<p>设t表示所存项目总数</p>
<p>这两个操作都要修改t的值,相应执行操作(1)t:=t+1和(2)t:=t-1来实现。</p>
<p>假定(1)和(2)是这样实现的:<br />
读t到一个专用寄存器;<br />
更新专用寄存器的值;<br />
将专用寄存器的值写到t;</p>
<p>则：</p>
<p>执行(1)时不能执行(2),反之亦然。<br />
即,(1)和(2)必须以互斥的方式执行,(1)或(2)是不可分的操作。</p>
</blockquote>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第二章</title>
    <url>/archives/1934b292.html</url>
    <content><![CDATA[<h3 id="编译原理第二章"><a class="markdownIt-Anchor" href="#编译原理第二章"></a> 编译原理第二章</h3>
<ol>
<li>
<p>数据类型的分类</p>
<ol>
<li>
<p>内部类型</p>
<blockquote>
<p>优点：</p>
<ol>
<li>基本表示的不可见性</li>
<li>编译时能检查变量使用的正确性</li>
<li>编译时可以确定无二义的操作</li>
<li>精度控制</li>
</ol>
</blockquote>
</li>
</ol>
</li>
</ol>
<span id="more"></span>
<ol start="2">
<li>
<p>用户定义类型</p>
<blockquote>
<ol>
<li>有限映像：<br />
定义：从定义域类型DT值的有限集合，到值域类型RT值的有限集合的函数（映射）<br />
eg：array[1…50] of char 中整数1至50到字符集的有限映像</li>
<li>序列：<br />
定义：任意多个数据项组成，数据项称为序列的成分，且<strong>类型相同</strong></li>
<li>判定或：<br />
定义：可以选择不同成员的构造机制<br />
eg：PASCAL的变体记录、C的联合<br />
eg：<br />
变体记录定义如下：</li>
</ol>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> dept=(house,sports,drugs,food,liquor);</span><br><span class="line">month=<span class="number">1</span>..<span class="number">12</span>;</span><br><span class="line">item=<span class="keyword">record</span></span><br><span class="line">    price:real;</span><br><span class="line">    <span class="keyword">case</span> available:boolean <span class="keyword">of</span></span><br><span class="line">        true:(amount:integer;  </span><br><span class="line">            where:dept);</span><br><span class="line">        false:(month_expected:month)</span><br><span class="line"> <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>实现代码如下：</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  i1,i2:item:</span><br><span class="line">i1.price:=<span class="number">5.24</span>;i1.available:=true;</span><br><span class="line">i1.amount:=<span class="number">29</span>;i1.where:=liquor;</span><br><span class="line">i2.price:=<span class="number">324.99</span>;i2.available:=false;</span><br><span class="line">i2.month_expect:=<span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>则空间分配情况如下：</p>
<center>i1</center>
<table>
<thead>
<tr>
<th>变量名</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>price</td>
<td>5.24</td>
</tr>
<tr>
<td>available</td>
<td>true</td>
</tr>
<tr>
<td>amount</td>
<td>29</td>
</tr>
<tr>
<td>where</td>
<td>liquor</td>
</tr>
</tbody>
</table>
<center>i2</center>
<table>
<thead>
<tr>
<th>变量名</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>price</td>
<td>324.99</td>
</tr>
<tr>
<td>available</td>
<td>false</td>
</tr>
<tr>
<td>month_expected</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ol start="4">
<li>幂集<br />
定义：类型T的元素的所有子集的集合，T为基类型</li>
</ol>
</blockquote>
</li>
<li>
<p>抽象数据类型</p>
</li>
<li>
<p>C语言的数据类型</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210414193241257.png" alt="image-20210414193241257" /></p>
<ol>
<li>非结构类型：<br />
1.内部类型<br />
整型：int、short、long、unsigned<br />
浮点型：float、double<br />
字符型：char（有限字符集的元素）</li>
<li>用户定义的非结构类型<br />
枚举：enum</li>
<li>结构类型
<ol>
<li>数组</li>
<li>结构struct</li>
<li>联合union（C的联合是不安全的）</li>
<li>文件FILE</li>
</ol>
</li>
<li>指针</li>
<li>空类型void</li>
</ol>
<blockquote>
<p>不允许定义空类型变量，可以定义空类型指针变量</p>
</blockquote>
</li>
<li>
<p>类型检查<br />
定义：对数据的操作和对应的类型是否匹配的一致性检查<br />
eg：非法运算、赋值运算、形参实参类型是否匹配</p>
<ol>
<li>静态检查和动态检查</li>
</ol>
<blockquote>
<p>静态检查使程序更有效<br />
动态检查是编程更方便，但是影响了可靠性且降低了执行效率</p>
</blockquote>
<ol start="2">
<li>语言分类</li>
</ol>
<blockquote>
<p>无类型语言：没有数据类型<br />
eg：函数式语言（FP）、泛函程序设计语言（FFP）<br />
弱类型语言：类型检查全部或部分在运行时完成<br />
eg：PASCAL<br />
强类型语言：类型检查都在编译时完成<br />
eg：C、ADA</p>
</blockquote>
</li>
<li>
<p>实现模型<br />
在程序中，数据由常量或变量表示<br />
在实现模型中，数据由描述符（描述数据对象的属性）和数据对象（存储区及其内容）表示</p>
<blockquote>
<ol>
<li>内部类型和用户定义的非结构类型：描述符一般由类型描述和指针组成<br />
<strong>多个变量的描述符形成变量名表</strong><br />
eg：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> numb;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210411152405051.png" alt="image-20210411152405051" /></p>
<ol start="2">
<li>结构类型</li>
</ol>
<ul>
<li>笛卡尔积<br />
各成分按顺序存储，每个成分占整数个存储单元<br />
描述符包含：类型名、构造符、若干三元式（选择符名、域类型、指针）（每个域对应一个三元式）<br />
eg：</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> t=recode a:real;</span><br><span class="line">              b:integer;</span><br><span class="line">       <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span> x:t;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210411155756373.png" alt="image-20210411155756373" /></p>
<ul>
<li>有限映像<br />
为每一成分分配整数个可编址的存储单元<br />
描述符包括：类型名、构造符、<strong>定义域的基类型</strong>、下界、上界、成分类型、（每个成分占）单元个数、<strong>首地址</strong><br />
eg：</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> a=<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">10</span>] <span class="keyword">of</span> real;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210411160449254.png" alt="image-20210411160449254" /></p>
<ul>
<li>序列<br />
可变长串的表示：静态描述符+动态描述符+堆</li>
</ul>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210411161113371.png" alt="image-20210411161113371" /></p>
<ul>
<li>判定或<br />
pascal的变体记录：描述符、数据对象、case表、若干变体描述符</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> v=<span class="keyword">record</span> a:integer;</span><br><span class="line">              <span class="keyword">case</span> b:boolean <span class="keyword">of</span></span><br><span class="line">                   true:(c:integer);</span><br><span class="line">                   false:(d:integer;</span><br><span class="line">                          e:real)</span><br><span class="line">       <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210411161638987.png" alt="image-20210411161638987" /></p>
<ul>
<li>
<p>指针</p>
<p>表示与内部类型相同只是其值为地址</p>
<p>指针指向的匿名数据对象分配在堆上</p>
</li>
<li>
<p><strong>编译时所有的描述符保存在一张表中以便编译时使用，甚至有些描述符要保存到运行阶段（数组），并且存储在描述符中的属性可能随运行而变化。</strong></p>
</li>
</ul>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒-基础-文件系统</title>
    <url>/archives/c3d31f32.html</url>
    <content><![CDATA[<h3 id="病毒基础-文件系统"><a class="markdownIt-Anchor" href="#病毒基础-文件系统"></a> 病毒基础-文件系统</h3>
<h4 id="初识文件系统"><a class="markdownIt-Anchor" href="#初识文件系统"></a> 初识文件系统</h4>
<p>文件系统就是组织文件的一种方式<br />
文件管理包括文件生成、删除、目录查询等<br />
eg：</p>
<ol>
<li>Windows文件系统：FAT12、FAT16、FAT32、NTFS</li>
<li>Linux文件系统：EXT2</li>
</ol>
<span id="more"></span>
<h4 id="fat12文件系统的磁盘格式"><a class="markdownIt-Anchor" href="#fat12文件系统的磁盘格式"></a> FAT12文件系统的磁盘格式</h4>
<ol>
<li>引导扇区（DBR）：记录各种参数，比如扇区大小，一簇的扇区数</li>
<li>文件分配表（FAT）：记录已分配的扇区和可用扇区</li>
<li>文件目录表（DIR）：记录根目录文件项的表，文件项包括文件，目录。</li>
<li>用户数据：存放数据的区域</li>
</ol>
<p><img src="/images/%E7%97%85%E6%AF%92-%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20210425164158141.png" alt="image-20210425164158141" /></p>
<p>注：左侧为扇区号、第二个FAT12为备用FAT</p>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第四章</title>
    <url>/archives/e30708a5.html</url>
    <content><![CDATA[<h3 id="编译原理第四章程序语言的设计"><a class="markdownIt-Anchor" href="#编译原理第四章程序语言的设计"></a> 编译原理第四章——程序语言的设计</h3>
<h4 id="1-程序设计语言的定义"><a class="markdownIt-Anchor" href="#1-程序设计语言的定义"></a> 1. （程序设计）语言的定义</h4>
<p>语言=语法（规则）+语义（规则）</p>
<p>语法：构造程序及其成分（单词、语法单位）的规则集合</p>
<p>语义：定义语言的单词符号和语法单位的作用和意义的规则组合</p>
<span id="more"></span>
<ul>
<li>
<p>可以从生成（文法）和识别（语法图）的角度描述语法</p>
<h5 id="11-文法描述语法规则生成角度"><a class="markdownIt-Anchor" href="#11-文法描述语法规则生成角度"></a> 1.1 文法描述语法规则：生成角度</h5>
<blockquote>
<p>&lt;标识符&gt;→&lt;字母&gt;<br />
&lt;标识符&gt;→&lt;标识符&gt;&lt;字母&gt;<br />
&lt;标识符&gt;→&lt;标识符&gt;&lt;数字&gt;<br />
&lt;字母&gt;→A|…|Z|a|…|z<br />
&lt;数字&gt;→0|…|9</p>
</blockquote>
<blockquote>
<p>&lt;表达式&gt;→&lt;标识符&gt;<br />
&lt;表达式&gt;→(&lt;表达式&gt;)<br />
&lt;表达式&gt;→&lt;表达式&gt;&lt;运算符&gt;&lt;表达式&gt;<br />
&lt;运算符&gt;→+|-|*|/</p>
<p><strong>注意：这里没有考虑运算符的优先级</strong></p>
</blockquote>
<h5 id="12-语法图描述语法规则识别角度"><a class="markdownIt-Anchor" href="#12-语法图描述语法规则识别角度"></a> 1.2  语法图描述语法规则：识别角度</h5>
<blockquote>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210413153851229.png" alt="image-20210413153851229" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210413153918317.png" alt="image-20210413153918317" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210413153937838.png" alt="image-20210413153937838" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210413154819595.png" alt="image-20210413154819595" /></p>
<h6 id="识别原则"><a class="markdownIt-Anchor" href="#识别原则"></a> 识别原则：</h6>
<ul>
<li>终结符框:标识的终结符与被识别的终结符刚好符合</li>
<li>非终结符框:由该非终结符的语法图识别</li>
<li>分支:若遇到分支，则任选一分支识别；</li>
<li>回溯:若一个分支识别不成功，则选另一分支识别</li>
<li>若一个终结符序列是合法的：<br />
那么,必须从语法图的入口边通过语法图而到达出口边，<br />
且在通过的过程中,恰恰能识别该终结符序列。</li>
<li>语言：语法图能识别的所有终结符序列的集合。称为语言。</li>
</ul>
<h6 id="语法图的构造"><a class="markdownIt-Anchor" href="#语法图的构造"></a> 语法图的构造</h6>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210413155020391.png" alt="image-20210413155020391" /></p>
</blockquote>
<h5 id="13-高级语言语法规则描述方法"><a class="markdownIt-Anchor" href="#13-高级语言语法规则描述方法"></a> 1.3 高级语言语法规则描述方法</h5>
<p>FORTRAN采用自然语言描述语法；<br />
ALGOL 60首次用BNF对语法进行形式描述,为语言定义做出了重要贡献；<br />
Pascal首次采用语法图来定义语言，给出了较为直观的语法结构。</p>
<h5 id="14-语法描述方法等价"><a class="markdownIt-Anchor" href="#14-语法描述方法等价"></a> 1.4 语法描述方法等价</h5>
<p>文法和语法图是语言语法的等价表示<br />
文法从产生的观点来定义语言的语法，通用性好。<br />
语法图以识别的观点定义语言的语法，更直观和清晰。</p>
<h5 id="15-语法的作用"><a class="markdownIt-Anchor" href="#15-语法的作用"></a> 1.5 语法的作用</h5>
<p>①表达语言设计者的意图和设计目标；<br />
②指导语言的使用者编写正确的程序；（先使用语义规则后使用语法规则）<br />
③指导语言的实现者识别所有语法单位。（先使用语法规则后使用语义规则）</p>
</li>
<li>
<p>本章语义使用自然语言描述、下篇语义以操作语义学的方法描述</p>
</li>
</ul>
<h4 id="2-文法"><a class="markdownIt-Anchor" href="#2-文法"></a> 2. 文法</h4>
<p>定义：文法是描述语言语法结构的形式规则</p>
<p>优点：通用、准确、易于理解、描述能力强</p>
<blockquote>
<p>文法G是一个四元式，G=（V<sub>T</sub> ，V<sub>N</sub> ，S ，P ）</p>
<p>V<sub>T</sub> 是有限字符的集合，元素称为字母或者<strong>终结符</strong></p>
<p>V<sub>N</sub> 是有限字符的集合，元素称为变量或<strong>非终结符</strong></p>
<p>S∈V，称为文法的开始符号</p>
<p>P是产生式α-&gt;β的集合</p>
</blockquote>
<blockquote>
<p>α∈(V<sub>T</sub> U V<sub>N</sub> )<sup>+</sup> ，至少包含一个非终结符，α∈V<sup>*</sup> V<sub>N</sub> V<sup>*</sup></p>
<p>β∈(V<sub>T</sub> U V<sub>N</sub> )<sup>*</sup></p>
<p>α-&gt;ε，称为空串产生式或者ε产生式</p>
</blockquote>
<h5 id="21-候选式"><a class="markdownIt-Anchor" href="#21-候选式"></a> 2.1 候选式</h5>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210420083948266.png" alt="image-20210420083948266" /></p>
<h5 id="22-文法的分类"><a class="markdownIt-Anchor" href="#22-文法的分类"></a> 2.2 文法的分类</h5>
<ol>
<li>
<p>0型文法（PSG）</p>
<p>α-&gt;β</p>
</li>
<li>
<p>1型文法（上下文有关文法CSG）</p>
<p>|α|&lt;=|β| （S-&gt;ε例外）</p>
<blockquote>
<p>标准形式：</p>
<p>yAz-&gt;yωz</p>
<p>其中：</p>
<p>A∈V<sub>N</sub> ;</p>
<p>y,z∈(V<sub>T</sub> U V<sub>N</sub> )<sup>*</sup> ;</p>
<p>ω∈(V<sub>T</sub> U V<sub>N</sub> )<sup>+</sup> ;</p>
<p>（S-&gt;ε例外）</p>
</blockquote>
</li>
<li>
<p>2型文法（上下文无关文法CFG）</p>
<p>A-&gt;β</p>
</li>
<li>
<p>3型文法（正则文法RG，或右线性文法RLG）</p>
<p>A-&gt;u或A-&gt;wB</p>
<p>其中u∈V<sub>T</sub> <sup>*</sup> ，w∈V<sub>T</sub> <sup>+</sup></p>
</li>
</ol>
<h4 id="3-文法产生的语言"><a class="markdownIt-Anchor" href="#3-文法产生的语言"></a> 3. 文法产生的语言</h4>
<h5 id="31-推导与归约"><a class="markdownIt-Anchor" href="#31-推导与归约"></a> 3.1 推导与归约</h5>
<ol>
<li>
<p>直接推导</p>
<p>wαv=&gt;wβv，即由产生式右边替换产生式左边</p>
</li>
<li>
<p>任意步推导</p>
<p>y=&gt;<sup>*</sup> z</p>
</li>
<li>
<p>多步推导</p>
<p>y=&gt;<sup>+</sup> z</p>
</li>
</ol>
<blockquote>
<p>eg：已知文法G（E）</p>
<p>E-&gt;E+E|E*E|(E)|i</p>
<ol>
<li>
<p>i+i*i的（其中一种）最左推导过程</p>
<p>E=&gt;E+E=&gt;i+E=&gt;i+E*E=&gt;i+i*E=&gt;i+i*i</p>
<p>E=&gt;E*E=&gt;E+E*E=&gt;i+E*E=&gt;i+i*E=&gt;i+i*i</p>
</li>
<li>
<p>i+i*i的最右推导（规范推导）</p>
<p>E=&gt;E+E=&gt;E+E*E=&gt;E+E*i=&gt;E+i*i=&gt;i+i*i</p>
<p>E=&gt;E*E=&gt;E*i=&gt;E+E*i=&gt;E+i*i=&gt;i+i*i</p>
</li>
</ol>
</blockquote>
<h5 id="32-句型和句子"><a class="markdownIt-Anchor" href="#32-句型和句子"></a> 3.2 句型和句子</h5>
<blockquote>
<p>文法G=（V<sub>T</sub> ,V<sub>N</sub> ,S,P）</p>
<p>S=&gt;<sup>*</sup> w</p>
<p>若w∈V<sup>*</sup> ，则w为文法G的一个句型</p>
<p>若w∈V<sub>T</sub> <sup>*</sup> ，则w是一个句子（只含终结符的句型就是一个句子）</p>
</blockquote>
<blockquote>
<p>所有句子的集合称为文法G产生的语言记为L（G）</p>
<p>即L（G）={α|S=&gt;<sup>+</sup> α且α∈V<sub>T</sub> <sup>*</sup> }</p>
</blockquote>
<h5 id="33-文法的重要特性"><a class="markdownIt-Anchor" href="#33-文法的重要特性"></a> 3.3 文法的重要特性</h5>
<p>有限规则描述无穷语言</p>
<h5 id="34-文法等价"><a class="markdownIt-Anchor" href="#34-文法等价"></a> 3.4 文法等价</h5>
<p>两个文法G和G<sup>’</sup> ，如果有L（G）=L（G<sup>’</sup> ），则称G和G<sup>’</sup> 等价</p>
<h4 id="4-推导树语法树"><a class="markdownIt-Anchor" href="#4-推导树语法树"></a> 4. 推导树（语法树）</h4>
<p>定义：推导树是一颗有序的标记树，每个结点的标记是文法G的非终结符或终结符或空串ε。其中标记为A的内部结点从左到右有子结点x1、x2、……xn，则A-&gt;x1……xn是一个产生式。</p>
<h5 id="41-推导树的边缘"><a class="markdownIt-Anchor" href="#41-推导树的边缘"></a> 4.1 推导树的边缘</h5>
<p>定义：推导树所有叶节点<strong>从左到右</strong>的连接</p>
<h5 id="42-文法的二义性"><a class="markdownIt-Anchor" href="#42-文法的二义性"></a> 4.2 文法的二义性</h5>
<p>定义：一个句子有两颗不同的推导树</p>
<h5 id="43-短语-直接短语-句柄"><a class="markdownIt-Anchor" href="#43-短语-直接短语-句柄"></a> 4.3 短语、直接短语、句柄</h5>
<p>详见第八章</p>
<h4 id="5-语言的设计"><a class="markdownIt-Anchor" href="#5-语言的设计"></a> 5. 语言的设计</h4>
<p>eg：</p>
<p>表达式的设计：</p>
<ol>
<li>逻辑表达式</li>
<li>关系表达式</li>
<li>算术表达式</li>
</ol>
<blockquote>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210426173640256.png" alt="image-20210426173640256" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210426173737710.png" alt="image-20210426173737710" /></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20210426173753654.png" alt="image-20210426173753654" /></p>
</blockquote>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第四章前导</title>
    <url>/archives/5f3d4781.html</url>
    <content><![CDATA[<h3 id="编译原理第零章形式语言与自动机"><a class="markdownIt-Anchor" href="#编译原理第零章形式语言与自动机"></a> 编译原理第零章——形式语言与自动机</h3>
<h4 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h4>
<p>字母表有非空性、有穷性、单一性</p>
<blockquote>
<p>Σ代表字母表<br />
ε代表空串<br />
{ε}代表仅含有空串的集合<br />
Φ代表空集<br />
αβ代表两个字符串α与β的连接（并置）<br />
α<sup>n</sup> 代表α的n次连接，其中α<sup>0</sup> =ε，α<sup>n</sup> =α<sup>n-1</sup> α  其中n&gt;0<br />
AB代表集合A与B的连接，A={a1,a2,a3,…,an}，B={b1,b2,b3,…,bm}</p>
<span id="more"></span>
<blockquote>
<p>则AB=<br />
{ a1b1，a1b2，a1b3，…，a1bm，<br />
a2b1，a2b2，a2b3，…，a2bm，<br />
a3b1，a3b2，a3b3，…，a3bm，<br />
…<br />
anb1，anb2，anb3，…，anbm }</p>
<p>注意：AФ=ФA=Ф，A{ε}={ε}A=A</p>
</blockquote>
<p>A<sup>n</sup> 代表集合A的n次连接（n次幂），A<sup>0</sup> = {ε}，A<sup>n</sup> = A<sup>n-1</sup>A    n ≥ 1<br />
A<sup>*</sup> 代表A上所有字符串的集合，称作集合A的克林闭包<br />
A<sup>*</sup> = A<sup>0</sup> ∪ A<sup>1</sup> ∪ A<sup>2</sup> ∪  …∪ A<sup>n</sup><br />
A<sup>+</sup> 称为A的正闭包<br />
A<sup>+</sup>=A<sup>1</sup>∪A<sup>2</sup>∪A<sup>3</sup>∪…∪A<sup>n</sup></p>
</blockquote>
<p>定义：</p>
<p>给定字母表∑，则∑*的任意子集L称为字母表∑上的一个语言。</p>
<p>设∑是一个字母表，∀L ⊆ ∑*, ∀x ∈ L, x称为L的一个句子。</p>
<blockquote>
<p>eg：Σ＝{0，1}，请给出语言的形式表示</p>
<ol>
<li>所有以0开头，以1结尾的串的语言。</li>
<li>所有以11开头，11结尾的串的语言。</li>
<li>所有长度为偶数的串的语言。</li>
<li>所有长度为奇数的串的语言。</li>
<li>所有包含子串01011的串的语言。</li>
<li>所有的第10个字符是0的串的语言。</li>
</ol>
<p>answer：</p>
<ol>
<li>{0} {0,1}<sup>*</sup> {1}</li>
<li>{11} {0,1}<sup>*</sup> {11} ∪ {11,111}</li>
<li>{00,01,10,11}<sup>*</sup></li>
<li>{00,01,10,11}<sup>*</sup> {0,1}</li>
<li>{0,1}<sup>*</sup> {011011} {0,1}<sup>*</sup></li>
<li>{0,1}<sup>9</sup> {0} {0,1}<sup>*</sup></li>
</ol>
</blockquote>
<h4 id="形式语言与自动机理论简介"><a class="markdownIt-Anchor" href="#形式语言与自动机理论简介"></a> 形式语言与自动机理论简介</h4>
<h5 id="初步认识"><a class="markdownIt-Anchor" href="#初步认识"></a> 初步认识</h5>
<p>语言的定义可以从两个方面进行：</p>
<ol>
<li>从产生语言的角度</li>
<li>从接收（识别）语言的角度</li>
</ol>
<ul>
<li>
<p>产生语言</p>
<p>根据语言中的基本句子和其他句子的形成规则，得到（产生）该语言所包含的所有句子</p>
<p>属于<strong>形式语言</strong>所研究的问题</p>
</li>
<li>
<p>接收语言</p>
<p>使用自动机模型来接收字符串，接收的所有字符串，也形成一个语言</p>
<p>属于<strong>自动机</strong>所研究的问题</p>
</li>
</ul>
<h5 id="统一的理论"><a class="markdownIt-Anchor" href="#统一的理论"></a> 统一的理论</h5>
<p>形式语言与自动机作为统一的理论，实际上包括3个方面的内容：</p>
<ol>
<li>形式语言理论（产生语言）</li>
<li>自动机理论（接收语言）</li>
<li>形式语言与自动机的等价性理论</li>
</ol>
<h5 id="括号匹配串的语言"><a class="markdownIt-Anchor" href="#括号匹配串的语言"></a> 括号匹配串的语言</h5>
<p><strong>自然语言描述：</strong></p>
<blockquote>
<ol>
<li>
<p>（）是该语言的最基本的句子</p>
</li>
<li>
<p>若S是句子，则（S）是句子</p>
</li>
<li>
<p>若S是句子，则SS是句子</p>
</li>
</ol>
</blockquote>
<p>根据以上形成规则，我们可以：</p>
<ol>
<li>产生该语言的任意的句子</li>
<li>判断某个串是否是该语言的句子——<strong>语法分析</strong></li>
</ol>
<p><strong>巴克斯-诺尔范式（BNF）描述：</strong></p>
<blockquote>
<ol>
<li>
<p>&lt;括号匹配串&gt;::=()</p>
</li>
<li>
<p>&lt;括号匹配串&gt;::=(&lt;括号匹配串&gt;)</p>
</li>
<li>
<p>&lt;括号匹配串&gt;::=&lt;括号匹配串&gt;&lt;括号匹配串&gt;</p>
</li>
</ol>
</blockquote>
<p><strong>Chomsky描述：</strong></p>
<blockquote>
<ol>
<li>
<p>S-&gt;()</p>
</li>
<li>
<p>S-&gt;(S)</p>
</li>
<li>
<p>S-&gt;SS</p>
</li>
</ol>
<p><strong>注：为方便起见，箭头打成-&gt;</strong></p>
</blockquote>
<p>术语：</p>
<blockquote>
<ol>
<li>S称为非终结符，是在推导中可以被替代的符号。</li>
<li>（）称为终结符，是在推导中不可以被替代的符号</li>
<li>-&gt;是产生式系统的元符号</li>
</ol>
</blockquote>
<p>结论：</p>
<p>一个语言，可以使用不同的产生式组合来产生。</p>
<p>注意：</p>
<p>D-&gt;0|1|2|3|4|5|6|7|8|9<strong>不能</strong>简写为D-&gt;0|…|9</p>
<p>eg：算术表达式的形成规则</p>
<blockquote>
<p>E-&gt;E+T|E-T|T<br />
T-&gt;T*F|T/F|F<br />
F-&gt;(E)|I<br />
I-&gt;L|IL|ID<br />
L-&gt;a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z<br />
D-&gt;0|1|2|3|4|5|6|7|8|9</p>
</blockquote>
<p>注意：其中E代表表达式，T代表项，F代表因子，先因子再乘除最后加减</p>
<p>注：这是算术表达式，不包含关系表达式的定义（&lt;、&lt;=、&gt;、&gt;=、&lt; &gt;、=），并且标识符没有考虑下划线和大写字母</p>
<h4 id="文法"><a class="markdownIt-Anchor" href="#文法"></a> 文法</h4>
<p>定义：</p>
<blockquote>
<p>文法G是一个四元式，G=（V<sub>T</sub> ，V<sub>N</sub> ，S ，P ）</p>
<p>V<sub>T</sub> 是有限字符的集合，元素称为字母或者<strong>终结符</strong></p>
<p>V<sub>N</sub> 是有限字符的集合，元素称为变量或<strong>非终结符</strong></p>
<p>S∈V，称为文法的开始符号</p>
<p>P是产生式α-&gt;β的集合</p>
<blockquote>
<p>α∈(V<sub>T</sub> U V<sub>N</sub> )<sup>+</sup> ，至少包含一个非终结符</p>
<p>β∈(V<sub>T</sub> U V<sub>N</sub> )<sup>*</sup></p>
<p>α-&gt;ε，称为空串产生式或者ε产生式</p>
</blockquote>
</blockquote>
<h5 id="推导派生"><a class="markdownIt-Anchor" href="#推导派生"></a> 推导（派生）</h5>
<p>定义：文法G，α和β是集合(V<sub>T</sub> ∪V<sub>N</sub> )上的串，α= pvr ，β=pur(p和r可能同时为ε)，而v→u是的一个产生式，则称α直接推导出β，记为α=&gt;β ，即pvr =&gt;pur。</p>
<p>术语：</p>
<blockquote>
<p>y=&gt;<sup>+</sup> z 多步推导<br />
y=&gt;<sup>*</sup> z 任意步推导（多了y=z的情况）</p>
<p>S=&gt;<sup>*</sup> ω 则ω是文法的一个句型<br />
进一步若ω∈V<sub>T</sub> <sup>*</sup> ，ω称为句子</p>
<p>L(G) ={ω|S=&gt;<sup>+</sup> ω，且ω∈V<sub>T</sub>*} ，则L（G）称为文法G产生的语言</p>
<blockquote>
<p>一个语言<strong>可以</strong>由多个不同的文法产生<br />
一个文法<strong>只能</strong>产生一个语言</p>
</blockquote>
</blockquote>
<p>eg：</p>
<blockquote>
<p>产生语言L（G）= { a<sup>n</sup> b<sup>n</sup> c<sup>n</sup> |n&gt;0} 文法</p>
<blockquote>
<p>解一：</p>
<p>S→aSBC        ①<br />
S→aBC          ②<br />
CB→BC         ③<br />
aB→ab          ④<br />
bB→bb          ⑤<br />
bC→bc          ⑥<br />
cC→cc           ⑦</p>
<p>解二：</p>
<p>S→abc|aSBc<br />
cB→Bc<br />
aB→ab<br />
bB→bb</p>
<p><strong>类似思想还可以写出很多文法</strong></p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第五章</title>
    <url>/archives/8c99cde2.html</url>
    <content><![CDATA[<h3 id="编译原理第五章-编译概述"><a class="markdownIt-Anchor" href="#编译原理第五章-编译概述"></a> 编译原理第五章-编译概述</h3>
<h4 id="1-不同语言程序之间的翻译"><a class="markdownIt-Anchor" href="#1-不同语言程序之间的翻译"></a> 1. 不同语言程序之间的翻译</h4>
<h5 id="11-翻译"><a class="markdownIt-Anchor" href="#11-翻译"></a> 1.1 翻译</h5>
<p>定义：语法单位之间等价的变换<br />
就是将一种语言编写的程序转换成等价的另一种语言编写的程序</p>
<h5 id="12-特殊的翻译汇编-编译"><a class="markdownIt-Anchor" href="#12-特殊的翻译汇编-编译"></a> 1.2 特殊的翻译：汇编、编译</h5>
<p>汇编：将汇编语言程序翻译为机器语言的程序<br />
编译：将高级语言程序翻译为低级语言的程序</p>
<span id="more"></span>
<h5 id="13-翻译程序"><a class="markdownIt-Anchor" href="#13-翻译程序"></a> 1.3 翻译程序</h5>
<p>定义：完成翻译工作的程序，也叫翻译器</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20210426201154954.png" alt="image-20210426201154954" /></p>
<p>宿主语言：翻译程序对应的语言<br />
宿主机：运行翻译程序的机器</p>
<h5 id="14-编译程序"><a class="markdownIt-Anchor" href="#14-编译程序"></a> 1.4 编译程序</h5>
<p>定义：实现编译的翻译程序，也叫编译器</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20210426201419434.png" alt="image-20210426201419434" /></p>
<p>自驻留的编译程序：编译程序生成宿主机执行的机器代码<br />
自编译的编译程序：编译程序是用源语言写的<br />
交叉编译：编译程序生成的不是宿主机执行的机器代码</p>
<h4 id="2-编译的步骤"><a class="markdownIt-Anchor" href="#2-编译的步骤"></a> 2. 编译的步骤</h4>
<p>逻辑上分为两部分：</p>
<ol>
<li>源程序的分析</li>
<li>目标程序的合成</li>
</ol>
<p>具体为5个步骤：</p>
<ol>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析与中间代码生成</li>
<li>中间代码优化</li>
<li>目标代码生成</li>
</ol>
<p><strong>编译的每个步骤都需要：</strong></p>
<ol>
<li>符号表管理</li>
<li>出错处理</li>
</ol>
<h5 id="21-词法分析"><a class="markdownIt-Anchor" href="#21-词法分析"></a> 2.1 词法分析</h5>
<p>分析输入的字符串，根据词法规则识别出单词符号<br />
单词符号：基本字、标识符、字面常量、运算符、界符</p>
<h5 id="22-语法规则"><a class="markdownIt-Anchor" href="#22-语法规则"></a> 2.2 语法规则</h5>
<p>根据语法规则，识别各类语法单位并进行语法检查<br />
语法单位：表达式、语句、程序单元、程序</p>
<h5 id="23-语义分析与中间代码生成"><a class="markdownIt-Anchor" href="#23-语义分析与中间代码生成"></a> 2.3 语义分析与中间代码生成</h5>
<p>根据语义规则，对语法正确的语法单位进行翻译<br />
注：可以直接生成目标程序，但目标程序执行效率低，故而生成中间代码</p>
<p>中间代码：大多数的编译器采用中间代码来描述源程序的语义，这种中间语言对应某种抽象机，结构简单，语义明确，易于翻译成目标代码，同时也便于优化和移植。</p>
<h5 id="24-优化"><a class="markdownIt-Anchor" href="#24-优化"></a> 2.4 优化</h5>
<p>对中间代码进行等价变换，提高代码的时空效率<br />
注：语义分析产生的中间代码不依赖于实际的机器，故而易于做一些等价变换，使生成的目标程序占用空间更少，执行更快。</p>
<h5 id="25-目标代码生成"><a class="markdownIt-Anchor" href="#25-目标代码生成"></a> 2.5 目标代码生成</h5>
<p>根据优化后的中间代码以及有关信息，可生成较为有效的目标代码<br />
目标代码：目标机的机器语言程序或汇编语言程序<br />
注：若生成的是汇编语言程序，还需将其汇编成机器语言程序</p>
<h5 id="26-符号表管理"><a class="markdownIt-Anchor" href="#26-符号表管理"></a> 2.6 符号表管理</h5>
<p>描述符表：存放实体属性的表格<br />
注：根据实体的不同，表格的形式也不同，其中最主要的是<strong>符号表</strong><br />
注：编译程序应有一组表格管理程序，负责表格的建立、维护、引用、查找、更新</p>
<h5 id="27-出错处理"><a class="markdownIt-Anchor" href="#27-出错处理"></a> 2.7 出错处理</h5>
<p>编译程序发现错误后进行出错处理，包括报告错误的性质和发生错误的位置等</p>
<h5 id="28-编译器的结构"><a class="markdownIt-Anchor" href="#28-编译器的结构"></a> 2.8 编译器的结构</h5>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20210426210832819.png" alt="image-20210426210832819" /></p>
<h4 id="3-完整的程序处理过程"><a class="markdownIt-Anchor" href="#3-完整的程序处理过程"></a> 3. 完整的程序处理过程</h4>
<p>从分析源程序到建立一个可执行的目标程序，处理过程还需要<strong>预处理器、汇编器、连接器、装入器</strong></p>
<h5 id="31-完整的程序处理过程"><a class="markdownIt-Anchor" href="#31-完整的程序处理过程"></a> 3.1 完整的程序处理过程</h5>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20210426211128343.png" alt="image-20210426211128343" /></p>
<h4 id="4-编译前端与后端"><a class="markdownIt-Anchor" href="#4-编译前端与后端"></a> 4. 编译前端与后端</h4>
<p>现代编译器通常将编译过程划分为前端和后端分别实现，它们通过中间代码连接，可极大提高编译器设计与实现的效率</p>
<h5 id="41-前端"><a class="markdownIt-Anchor" href="#41-前端"></a> 4.1 前端</h5>
<p>主要是与源程序相关的部分，包括词法、语法分析、语义分析、中间代码生成等</p>
<h5 id="42-后端"><a class="markdownIt-Anchor" href="#42-后端"></a> 4.2 后端</h5>
<p>主要是与目标程序相关的部分，包括优化、目标代码生成等</p>
<h4 id="5-结语"><a class="markdownIt-Anchor" href="#5-结语"></a> 5. 结语</h4>
<p>词法分析基于有限状态自动机FA<br />
语法分析基于下推自动机PDA</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
</search>
